diff --git a/README.md b/README.md
index 472115f..156d852 100644
--- a/README.md
+++ b/README.md
@@ -3,7 +3,8 @@
 [![NPM Version](https://img.shields.io/npm/v/@nulledexp/translatable-criteria.svg)](https://www.npmjs.com/package/@nulledexp/translatable-criteria)
 ![NPM Downloads](https://img.shields.io/npm/dw/%40nulledexp%2Ftranslatable-criteria)
 [![Development Stage](https://img.shields.io/badge/Development-Active%20Development-green)]()
-[![Documentation](https://img.shields.io/badge/Documentation-EN/ES-blue)](./src/docs/introduction/en.md)
+[![Documentation](https://img.shields.io/badge/Documentation-EN-blue)](./src/docs/introduction/en.md)
+[![Documentation](https://img.shields.io/badge/Documentation-ES-blue)](./src/docs/introduction/es.md)
 [![CI](https://github.com/Techscq/translatable-criteria/actions/workflows/ci.yml/badge.svg)](https://github.com/Techscq/translatable-criteria/actions/workflows/ci.yml)
 
 A TypeScript library for building data-source agnostic, translatable query criteria. Define complex filtering, ordering, and join logic in a structured, type-safe way, then translate it to your specific data source using custom translators.
@@ -16,29 +17,27 @@ npm install @nulledexp/translatable-criteria
 
 ## Overview
 
-This library simplifies the construction of complex data queries by providing a consistent and abstract way to define filtering, ordering, field selection, pagination (offset and cursor-based), and relationship (joins) configurations. The core concept revolves around the `Criteria` object hierarchy, which allows developers to define sophisticated query specifications in a data source-agnostic manner. These `Criteria` objects can then be processed by a `CriteriaTranslator` (using the Visitor pattern) to generate queries for various data sources.
+This library simplifies the construction of complex data queries by providing a consistent and abstract way to define filtering, ordering, field selection, pagination (offset and cursor-based), and relationship (joins) configurations. The core concept revolves around the `Criteria` object hierarchy, which allows developers to define sophisticated query specifications in a data source-agnostic manner, now with enhanced schema validation (including `identifier_field`) and richer context for translators (like `parent_identifier`). These `Criteria` objects can then be processed by a `CriteriaTranslator` to generate queries for various data sources.
 
 ## Key Features
 
-- **Enhanced Type-Safety:** Construct queries with a fluent, strongly-typed interface, benefiting from compile-time and runtime validation of field names, aliases, and join parameters based on your schemas.
-- **Powerful Filtering:** Define intricate filtering logic with multiple operators (including for JSON and arrays) and grouping. Filter groups are automatically normalized for consistency.
-- **Flexible Join System:** Support for various join types (inner, left, full outer) and pivot table configurations, with validation of join parameters according to the relation type.
-- **Default Join Field Selection:** When a join is added, if `setSelect()` is not explicitly called on the `JoinCriteria`, all fields from the joined schema will be automatically included in the main `SELECT` clause. This can be overridden by using `setSelect()` on the specific `JoinCriteria`.
-- **Field Selection:** Specify exactly which fields to retrieve using `setSelect()`. Use `resetSelect()` to select all fields (which is also the default behavior).
+- **Enhanced Type-Safety:** Construct queries with a fluent, strongly-typed interface, benefiting from compile-time and runtime validation of field names (including `identifier_field`), aliases, and join parameters based on your schemas.
+- **Powerful Filtering:** Define intricate filtering logic with multiple operators (including for JSON, arrays, sets, ranges, and regex) and grouping. Filter groups are automatically normalized for consistency.
+- **Flexible Join System:** Support for various join types (inner, left, full outer) and pivot table configurations. Join parameters now include `parent_identifier` to provide richer context to translators for relationship inference (e.g., for `one_to_one`).
+- **Field Selection & `identifier_field`:** Specify exactly which fields to retrieve using `setSelect()`. The `identifier_field` of an entity is automatically included when `setSelect()` is used. Use `resetSelect()` to select all fields (default behavior).
 - **Pagination:** Supports both offset-based (`setTake()`, `setSkip()`) and cursor-based (`setCursor()`) pagination.
-- **Visitor Pattern for Translation:** Criteria objects implement an `accept` method, allowing for clean and extensible translation logic via the Visitor pattern.
 - **Data Source Agnostic:** Design criteria independently of the underlying data source.
 - **Translator-Based Architecture:** The core library defines criteria; actual translation is handled by separate translator packages that implement the `CriteriaTranslator` interface.
 - **Full TypeScript Support:** Benefit from compile-time validation and autocompletion.
 
 ## Core Concepts
 
-The library is built upon a few fundamental concepts. For detailed explanations, please refer to our Core Concepts Documentation.
+The library is built upon a few fundamental concepts. For detailed explanations, please refer to our documentation guides.
 
-- **`Criteria` Hierarchy:** Abstract base for query specifications (`RootCriteria`, `InnerJoinCriteria`, etc.). Learn more.
-- **`CriteriaFactory`:** Recommended utility for creating `Criteria` instances (e.g., `CriteriaFactory.GetCriteria(...)`, `CriteriaFactory.GetInnerJoinCriteria(...)`). Learn more.
-- **Schemas (`CriteriaSchema` & `GetTypedCriteriaSchema`):** Define your data entities' structure for type-safe criteria construction. Learn more.
-- **`CriteriaTranslator`:** Abstract class for converting `Criteria` objects into specific data source queries using the Visitor pattern. Learn more.
+- [**`Criteria` Hierarchy:**](./src/docs/core-concepts/en.md#criteria-hierarchy) Abstract base for query specifications (`RootCriteria`, `InnerJoinCriteria`, etc.).
+- [**`CriteriaFactory`:**](./src/docs/core-concepts/en.md#criteriafactory) Recommended utility for creating `Criteria` instances.
+- [**Schemas (`CriteriaSchema` & `GetTypedCriteriaSchema`):**](./src/docs/guides/schema-definitions/en.md) Define your data entities' structure for type-safe criteria construction.
+- [**`CriteriaTranslator`:**](./src/docs/guides/developing-translators/en.md) Abstract class responsible for converting `Criteria` objects into specific data source queries.
 
 ## Usage Example (Core Library)
 
@@ -46,54 +45,54 @@ This package provides the tools to define your query criteria.
 
 ### 1. Define Schemas
 
+First, define your entity schemas using `GetTypedCriteriaSchema` to enable type-safety.
+
 ```typescript
 import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
 
 export const UserSchema = GetTypedCriteriaSchema({
-  source_name: 'user',
-  alias: ['users', 'user', 'publisher'],
-  fields: ['uuid', 'email', 'username', 'created_at'],
+  source_name: 'users',
+  alias: 'u',
+  fields: ['id', 'username', 'email', 'age', 'isActive', 'createdAt'],
+  identifier_field: 'id',
   joins: [
-    { alias: 'posts', relation_type: 'one_to_many' },
-    // other joins like 'permissions', 'addresses' can be defined here
+    {
+      alias: 'posts',
+      target_source_name: 'posts',
+      relation_type: 'one_to_many',
+    },
   ],
 });
-export type UserSchema = typeof UserSchema;
 
 export const PostSchema = GetTypedCriteriaSchema({
-  source_name: 'post',
-  alias: ['posts', 'post'],
-  fields: [
-    'uuid',
-    'title',
-    'body',
-    'user_uuid',
-    'created_at',
-    'categories', // Example: for array filters
-    'metadata', // Example: for JSON filters
-  ],
+  source_name: 'posts',
+  alias: 'p',
+  fields: ['id', 'title', 'content', 'userId', 'createdAt'],
+  identifier_field: 'id',
   joins: [
-    { alias: 'comments', relation_type: 'one_to_many' },
-    { alias: 'publisher', relation_type: 'many_to_one' },
+    {
+      alias: 'user',
+      target_source_name: 'users',
+      relation_type: 'many_to_one',
+    },
   ],
 });
-export type PostSchema = typeof PostSchema;
-
-// Define other schemas (PermissionSchema, PostCommentSchema, AddressSchema) as needed for your application.
-// See the full documentation for more examples.
 ```
 
 ### 2. Create Criteria
 
+Use `CriteriaFactory` to create a `Criteria` object from your schema.
+
 ```typescript
 import {
   CriteriaFactory,
   FilterOperator,
+  OrderDirection,
 } from '@nulledexp/translatable-criteria';
-import { UserSchema } from './path/to/your/criteria/schemas'; // Adjust path
+import { UserSchema } from './path/to/your/schemas'; // Adjust path
 
 // Create Criteria for the User entity
-const userCriteria = CriteriaFactory.GetCriteria(UserSchema, 'users');
+const userCriteria = CriteriaFactory.GetCriteria(UserSchema);
 
 // Example: Add a simple filter
 userCriteria.where({
@@ -103,17 +102,17 @@ userCriteria.where({
 });
 
 // Example: Add ordering
-userCriteria.orderBy('created_at', 'DESC');
+userCriteria.orderBy('createdAt', OrderDirection.DESC);
 
 // The 'userCriteria' object is now ready to be passed to a translator.
 ```
 
 ## Available Translators
 
-To interact with a database, you'll need a translator package.
+To interact with a database, you'll need a translator package. You can either build your own following our Criteria Translator Development Guide or use one from the community.
 
 - **`@nulledexp/typeorm-mysql-criteria-translator`**:
-  A translator for generating TypeORM `SelectQueryBuilder` instances for MySQL.
+  - A translator for generating TypeORM `SelectQueryBuilder` instances for MySQL.
   - **Author:** Nelson Cabrera
   - **Installation**:
 
@@ -121,58 +120,25 @@ To interact with a database, you'll need a translator package.
   npm install @nulledexp/typeorm-mysql-criteria-translator
 ```
 
-- **Usage (basic)**:
-
-```typescript
-import {
-  CriteriaFactory,
-  FilterOperator,
-} from '@nulledexp/translatable-criteria';
-import { TypeOrmMysqlTranslator } from '@nulledexp/typeorm-mysql-criteria-translator'; // Using new suggested name
-import { UserSchema } from './path/to/your/criteria/schemas'; // Your Criteria Schema
-// import { YourTypeOrmUserEntity } from './path/to/your/typeorm/entities'; // Your actual TypeORM entity
-// import { DbDatasource } from './path-to-your-datasource-config'; // Your initialized TypeORM DataSource instance
-
-// 1. Define your Criteria using @nulledexp/translatable-criteria
-const criteria = CriteriaFactory.GetCriteria(UserSchema, 'users') // 'users' is an alias from UserSchema
-  .where({
-    field: 'username', // Field from UserSchema
-    operator: FilterOperator.EQUALS,
-    value: 'testuser',
-  })
-  .setTake(10);
-
-// 2. Use the translator with your TypeORM QueryBuilder
-// (Conceptual - assuming DbDatasource and YourTypeOrmUserEntity are set up)
-
-// const queryBuilder = DbDatasource.getRepository(YourTypeOrmUserEntity)
-//   .createQueryBuilder(criteria.alias); // Alias must match root criteria alias
-
-// const translator = new TypeOrmMysqlTranslator<YourTypeOrmUserEntity>();
-// translator.translate(criteria, queryBuilder);
-
-// Now queryBuilder is populated with the translated criteria
-// console.log(queryBuilder.getSql(), queryBuilder.getParameters());
-// const results = await queryBuilder.getMany();
-```
+- **Usage:**
 
-- **Note:** This translator has been tested with integration tests. Please review its implementation at its repository (replace with actual repo link if different) to ensure it meets your specific project needs and production requirements. Contributions and bug reports are welcome!
+  - See the TypeORM Translator Usage Guide for detailed instructions.
 
 - **(More translators coming soon or can be created by the community)**
 
-### Developing Custom Translators
-
-You can create your own translators by extending the abstract `CriteriaTranslator` class. See the Developing Custom Translators Guide for details.
+**Important Note for Translator Developers:** Translators should be updated to handle the new `parent_identifier` in join parameters (especially for inferring `one_to_one` relationships) and to support the new filter operators. Refer to the Developing Custom Translators Guide for details.
 
 ## Type Safety Features
 
 - Compile-time validation of field names within criteria based on schemas.
+- Validation of `identifier_field` definition within schemas.
 - Type-checked join configurations ensuring compatibility between schemas.
 - Autocomplete support for schema fields and defined join aliases.
 - Validation of alias usage in `Criteria` constructors.
 - Robust validation of join parameters based on `join_relation_type`.
 - Validation for selected fields, cursor fields, take/skip values.
 - Strictly typed filter values based on the `FilterOperator` used.
+- Inclusion of `parent_identifier` in resolved join parameters for translator use.
 
 ## Roadmap (Core Library)
 
@@ -182,9 +148,11 @@ You can create your own translators by extending the abstract `CriteriaTranslato
 - [x] Implement `LIMIT` and `OFFSET` (take/skip) for pagination.
 - [x] Implement `PivotJoin` for many-to-many relationships.
 - [x] Strictly typed filter values based on operator.
-- [x] New filter operators (JSON, Array, Set).
-- [x] Enhanced documentation with detailed examples for translator development.
+- [x] New filter operators (JSON, Array, Set, Range, Regex, ILIKE).
 - [x] `OuterJoinCriteria` support in the core logic.
+- [x] Introduce `identifier_field` in schemas and `parent_identifier` in join parameters.
+- [x] Enforce stricter schema validation at type level.
+- [ ] Enhanced documentation with detailed examples for translator development.
 - [ ] Explore utility functions to simplify translator development.
 - [ ] Explore utility functions to simplify schema development.
 - [ ] Add more comprehensive unit test coverage for criteria construction and edge cases.
diff --git a/changes-next-v2-06-20.diff b/changes-next-v2-06-20.diff
deleted file mode 100644
index 026d09c..0000000
--- a/changes-next-v2-06-20.diff
+++ /dev/null
@@ -1,325 +0,0 @@
-diff --git a/src/criteria/criteria-factory.ts b/src/criteria/criteria-factory.ts
-index f89951e..d139131 100644
---- a/src/criteria/criteria-factory.ts
-+++ b/src/criteria/criteria-factory.ts
-@@ -3,6 +3,7 @@ import type { CriteriaSchema, SelectedAliasOf } from './types/schema.types.js';
- import { InnerJoinCriteria } from './join/inner.join-criteria.js';
- import { LeftJoinCriteria } from './join/left.join-criteria.js';
- import { OuterJoinCriteria } from './join/outer.join-criteria.js';
-+import type { ValidSchema } from './criteria.js';
- 
- /**
-  * Provides static methods for creating instances of different types of `Criteria`.
-@@ -26,7 +27,7 @@ export class CriteriaFactory {
-   static GetCriteria<
-     CSchema extends CriteriaSchema,
-     Alias extends SelectedAliasOf<CSchema>,
--  >(schema: CSchema, alias: Alias): RootCriteria<CSchema, Alias> {
-+  >(schema: ValidSchema<CSchema>, alias: Alias): RootCriteria<CSchema, Alias> {
-     return new RootCriteria(schema, alias);
-   }
- 
-@@ -47,7 +48,10 @@ export class CriteriaFactory {
-   static GetInnerJoinCriteria<
-     CSchema extends CriteriaSchema,
-     Alias extends SelectedAliasOf<CSchema>,
--  >(schema: CSchema, alias: Alias): InnerJoinCriteria<CSchema, Alias> {
-+  >(
-+    schema: ValidSchema<CSchema>,
-+    alias: Alias,
-+  ): InnerJoinCriteria<CSchema, Alias> {
-     return new InnerJoinCriteria(schema, alias);
-   }
- 
-@@ -67,7 +71,10 @@ export class CriteriaFactory {
-   static GetLeftJoinCriteria<
-     CSchema extends CriteriaSchema,
-     Alias extends SelectedAliasOf<CSchema>,
--  >(schema: CSchema, alias: Alias): LeftJoinCriteria<CSchema, Alias> {
-+  >(
-+    schema: ValidSchema<CSchema>,
-+    alias: Alias,
-+  ): LeftJoinCriteria<CSchema, Alias> {
-     return new LeftJoinCriteria(schema, alias);
-   }
- 
-@@ -87,7 +94,10 @@ export class CriteriaFactory {
-   static GetOuterJoinCriteria<
-     CSchema extends CriteriaSchema,
-     Alias extends SelectedAliasOf<CSchema>,
--  >(schema: CSchema, alias: Alias): OuterJoinCriteria<CSchema, Alias> {
-+  >(
-+    schema: ValidSchema<CSchema>,
-+    alias: Alias,
-+  ): OuterJoinCriteria<CSchema, Alias> {
-     return new OuterJoinCriteria(schema, alias);
-   }
- }
-diff --git a/src/criteria/criteria.ts b/src/criteria/criteria.ts
-index d59322c..67a7735 100644
---- a/src/criteria/criteria.ts
-+++ b/src/criteria/criteria.ts
-@@ -25,6 +25,10 @@ import type {
- import type { PivotJoin, SimpleJoin } from './types/join-parameter.types.js';
- import type { FilterGroup } from './filter/filter-group.js';
- 
-+export type ValidSchema<CSchema extends CriteriaSchema> =
-+  CSchema['identifier_field'] extends CSchema['fields'][number]
-+    ? CSchema
-+    : `Schema identifier_field '${CSchema['identifier_field']}' must be one of the schema's defined fields. Schema: ${CSchema['source_name']}`;
- /**
-  * Abstract base class for constructing query criteria.
-  * It provides a fluent API for defining filters, joins, selections, ordering, and pagination.
-@@ -71,9 +75,7 @@ export abstract class Criteria<
-    * @protected
-    */
-   constructor(
--    schema: TSchema['identifier_field'] extends TSchema['fields'][number]
--      ? TSchema
--      : `Schema identifier_field '${TSchema['identifier_field']}' must be one of the schema's defined fields. Schema: ${TSchema['source_name']}`,
-+    schema: ValidSchema<TSchema>,
-     protected _alias: CurrentAlias,
-   ) {
-     if (typeof schema === 'string') {
-@@ -93,7 +95,7 @@ export abstract class Criteria<
-     this._source_name = schema.source_name;
-   }
- 
--  private get schema(): TSchema {
-+  protected get schema(): TSchema {
-     return this._schema;
-   }
- 
-@@ -385,6 +387,7 @@ export abstract class Criteria<
-         this.schema.joins.find((join) => join.alias === criteriaToJoin.alias)
-           ?.metadata ?? {},
-       parent_schema_metadata: this.schema.metadata ?? {},
-+      parent_identifier: this.identifierField,
-     };
-     this._joinManager.addJoin(criteriaToJoin, fullJoinParameters);
-     return this;
-diff --git a/src/criteria/join/inner.join-criteria.ts b/src/criteria/join/inner.join-criteria.ts
-index d973075..bcf542d 100644
---- a/src/criteria/join/inner.join-criteria.ts
-+++ b/src/criteria/join/inner.join-criteria.ts
-@@ -4,7 +4,7 @@ import type {
-   SelectedAliasOf,
- } from '../types/schema.types.js';
- import type { PivotJoin, SimpleJoin } from '../types/join-parameter.types.js';
--import { Criteria } from '../criteria.js';
-+import { Criteria, type ValidSchema } from '../criteria.js';
- import type { ICriteriaVisitor } from '../types/visitor-interface.types.js';
- 
- /**
-@@ -48,6 +48,9 @@ export class InnerJoinCriteria<
-    * @returns {InnerJoinCriteria<CSchema, Alias>} A new, reset `RootCriteria` instance.
-    */
-   resetCriteria(): InnerJoinCriteria<CSchema, Alias> {
--    return new InnerJoinCriteria(this.schema, this._alias);
-+    return new InnerJoinCriteria(
-+      this.schema as ValidSchema<CSchema>,
-+      this._alias,
-+    );
-   }
- }
-diff --git a/src/criteria/join/left.join-criteria.ts b/src/criteria/join/left.join-criteria.ts
-index 58e2b60..1227d5a 100644
---- a/src/criteria/join/left.join-criteria.ts
-+++ b/src/criteria/join/left.join-criteria.ts
-@@ -4,7 +4,7 @@ import type {
-   SelectedAliasOf,
- } from '../types/schema.types.js';
- import type { PivotJoin, SimpleJoin } from '../types/join-parameter.types.js';
--import { Criteria } from '../criteria.js';
-+import { Criteria, type ValidSchema } from '../criteria.js';
- import type { ICriteriaVisitor } from '../types/visitor-interface.types.js';
- 
- /**
-@@ -47,6 +47,9 @@ export class LeftJoinCriteria<
-    * @returns {LeftJoinCriteria<CSchema, Alias>} A new, reset `RootCriteria` instance.
-    */
-   resetCriteria(): LeftJoinCriteria<CSchema, Alias> {
--    return new LeftJoinCriteria(this.schema, this._alias);
-+    return new LeftJoinCriteria(
-+      this.schema as ValidSchema<CSchema>,
-+      this._alias,
-+    );
-   }
- }
-diff --git a/src/criteria/join/outer.join-criteria.ts b/src/criteria/join/outer.join-criteria.ts
-index 66ff186..1ae0d07 100644
---- a/src/criteria/join/outer.join-criteria.ts
-+++ b/src/criteria/join/outer.join-criteria.ts
-@@ -4,7 +4,7 @@ import type {
-   SelectedAliasOf,
- } from '../types/schema.types.js';
- import type { PivotJoin, SimpleJoin } from '../types/join-parameter.types.js';
--import { Criteria } from '../criteria.js';
-+import { Criteria, type ValidSchema } from '../criteria.js';
- import type { ICriteriaVisitor } from '../types/visitor-interface.types.js';
- 
- /**
-@@ -47,6 +47,9 @@ export class OuterJoinCriteria<
-    * @returns {OuterJoinCriteria<CSchema, Alias>} A new, reset `RootCriteria` instance.
-    */
-   resetCriteria(): OuterJoinCriteria<CSchema, Alias> {
--    return new OuterJoinCriteria(this.schema, this._alias);
-+    return new OuterJoinCriteria(
-+      this.schema as ValidSchema<CSchema>,
-+      this._alias,
-+    );
-   }
- }
-diff --git a/src/criteria/root.criteria.ts b/src/criteria/root.criteria.ts
-index f08978d..4136946 100644
---- a/src/criteria/root.criteria.ts
-+++ b/src/criteria/root.criteria.ts
-@@ -1,4 +1,4 @@
--import { Criteria } from './criteria.js';
-+import { Criteria, type ValidSchema } from './criteria.js';
- import type { CriteriaSchema, SelectedAliasOf } from './types/schema.types.js';
- import type { ICriteriaVisitor } from './types/visitor-interface.types.js';
- 
-@@ -38,6 +38,6 @@ export class RootCriteria<
-    * @returns {RootCriteria<CSchema, Alias>} A new, reset `RootCriteria` instance.
-    */
-   resetCriteria(): RootCriteria<CSchema, Alias> {
--    return new RootCriteria(this.schema, this._alias);
-+    return new RootCriteria(this.schema as ValidSchema<CSchema>, this._alias);
-   }
- }
-diff --git a/src/criteria/test/criteria.test.ts b/src/criteria/test/criteria.test.ts
-index 4ff5813..93fdaf8 100644
---- a/src/criteria/test/criteria.test.ts
-+++ b/src/criteria/test/criteria.test.ts
-@@ -4,7 +4,7 @@ import { OrderDirection } from '../order/order.js';
- import { InnerJoinCriteria } from '../join/inner.join-criteria.js';
- import { LeftJoinCriteria } from '../join/left.join-criteria.js';
- import type { StoredJoinDetails } from '../types/join-utility.types.js';
--import type { CriteriaSchema, SelectedAliasOf } from '../types/schema.types.js';
-+
- import { FilterOperator, LogicalOperator } from '../types/operator.types.js';
- import {
-   PermissionSchema,
-@@ -12,16 +12,26 @@ import {
-   PostSchema,
-   UserSchema,
- } from './fake-entities.js';
-+import {
-+  type CriteriaSchema,
-+  GetTypedCriteriaSchema,
-+  type SelectedAliasOf,
-+} from '../types/schema.types.js';
- 
- const testJoinsData = (
-   joinDetails: StoredJoinDetails<CriteriaSchema>,
-   joinParameter: { join_field: string | object; parent_field: string | object },
--  criteria: RootCriteria<CriteriaSchema, SelectedAliasOf<CriteriaSchema>>,
-+  parentCriteria: RootCriteria<CriteriaSchema, SelectedAliasOf<CriteriaSchema>>,
- ) => {
-   expect(joinDetails.parameters.join_field).toBe(joinParameter.join_field);
-   expect(joinDetails.parameters.parent_field).toBe(joinParameter.parent_field);
--  expect(joinDetails.parameters.parent_alias).toBe(criteria.alias);
--  expect(joinDetails.parameters.parent_source_name).toBe(criteria.sourceName);
-+  expect(joinDetails.parameters.parent_alias).toBe(parentCriteria.alias);
-+  expect(joinDetails.parameters.parent_source_name).toBe(
-+    parentCriteria.sourceName,
-+  );
-+  expect(joinDetails.parameters.parent_identifier).toBe(
-+    parentCriteria.identifierField,
-+  );
- };
- 
- describe('Criteria', () => {
-@@ -418,7 +428,7 @@ describe('Criteria', () => {
-       );
-     });
- 
--    it('should add an inner join', () => {
-+    it('should add an inner join and correctly populate parent_identifier', () => {
-       const userJoinCriteria = new InnerJoinCriteria(UserSchema, 'publisher');
-       const joinParameter = {
-         parent_field: 'user_uuid',
-@@ -440,7 +450,36 @@ describe('Criteria', () => {
-       }
-     });
- 
--    it('should add multiple joins', () => {
-+    it('should add a many-to-many join and correctly populate parent_identifier', () => {
-+      const userCriteriaRoot = new RootCriteria(UserSchema, 'users');
-+      const permissionJoinCriteria = new InnerJoinCriteria(
-+        PermissionSchema,
-+        'permissions',
-+      );
-+      const joinParameter = {
-+        pivot_source_name: 'user_permission_pivot',
-+        parent_field: { pivot_field: 'user_uuid', reference: 'uuid' },
-+        join_field: { pivot_field: 'permission_uuid', reference: 'uuid' },
-+      } as const;
-+
-+      userCriteriaRoot.join(permissionJoinCriteria, joinParameter);
-+
-+      const joinsArray = userCriteriaRoot.joins;
-+      expect(joinsArray.length).toBe(1);
-+      const joinEntry = joinsArray[0];
-+      expect(joinEntry).toBeDefined();
-+      if (joinEntry) {
-+        expect(joinEntry.criteria.alias).toBe('permissions');
-+        expect(joinEntry.criteria).toBeInstanceOf(InnerJoinCriteria);
-+        testJoinsData(joinEntry, joinParameter, userCriteriaRoot);
-+        expect(joinEntry.criteria).toBe(permissionJoinCriteria);
-+        expect(joinEntry.parameters.parent_identifier).toBe(
-+          UserSchema.identifier_field,
-+        );
-+      }
-+    });
-+
-+    it('should add multiple joins and correctly populate parent_identifier for each', () => {
-       const userJoinCriteria = new InnerJoinCriteria(UserSchema, 'publisher');
-       const userJoinParameter = {
-         parent_field: 'user_uuid',
-@@ -483,7 +522,7 @@ describe('Criteria', () => {
-       }
-     });
- 
--    it('should replace a join if the same alias is used', () => {
-+    it('should replace a join if the same alias is used and check parent_identifier', () => {
-       const userJoinCriteria1 = new InnerJoinCriteria(UserSchema, 'publisher');
-       const userJoinCriteria2 = new LeftJoinCriteria(UserSchema, 'publisher');
- 
-@@ -688,14 +727,3 @@ describe('Criteria', () => {
-     });
-   });
- });
--
--/**
-- * Helper function to create a typed schema for testing.
-- * This is a simplified version of GetTypedCriteriaSchema for test purposes
-- * if the main one causes issues with complex generic inference in tests.
-- */
--function GetTypedCriteriaSchema<const TInput extends CriteriaSchema>(
--  schema: TInput,
--): TInput {
--  return schema;
--}
-diff --git a/src/criteria/types/join-parameter.types.ts b/src/criteria/types/join-parameter.types.ts
-index db7a837..fe12361 100644
---- a/src/criteria/types/join-parameter.types.ts
-+++ b/src/criteria/types/join-parameter.types.ts
-@@ -23,7 +23,7 @@ export type PivotJoin<
-   parent_source_name: ParentSchema['source_name'];
-   /** The alias used for the parent entity in the query. */
-   parent_alias: ParentSchema['alias'][number];
--
-+  parent_identifier: FieldOfSchema<ParentSchema>;
-   /** The source name (table name) of the pivot table. */
-   pivot_source_name: string;
-   /** Configuration for the join field on the parent side, referencing the pivot table. */
-@@ -82,6 +82,7 @@ export type SimpleJoin<
-   parent_source_name: ParentSchema['source_name'];
-   /** The alias used for the parent entity in the query. */
-   parent_alias: ParentSchema['alias'][number];
-+  parent_identifier: FieldOfSchema<ParentSchema>;
-   /**
-    * The field name in the parent schema used for the join condition.
-    * Must be a valid field from `ParentSchema['fields']`.
diff --git a/src/criteria/criteria-factory.ts b/src/criteria/criteria-factory.ts
index d139131..dff7d4b 100644
--- a/src/criteria/criteria-factory.ts
+++ b/src/criteria/criteria-factory.ts
@@ -1,5 +1,5 @@
 import { RootCriteria } from './root.criteria.js';
-import type { CriteriaSchema, SelectedAliasOf } from './types/schema.types.js';
+import type { CriteriaSchema } from './types/schema.types.js';
 import { InnerJoinCriteria } from './join/inner.join-criteria.js';
 import { LeftJoinCriteria } from './join/left.join-criteria.js';
 import { OuterJoinCriteria } from './join/outer.join-criteria.js';
@@ -24,11 +24,10 @@ export class CriteriaFactory {
    *
    * const userCriteria = CriteriaFactory.GetCriteria(UserSchema, 'users');
    */
-  static GetCriteria<
-    CSchema extends CriteriaSchema,
-    Alias extends SelectedAliasOf<CSchema>,
-  >(schema: ValidSchema<CSchema>, alias: Alias): RootCriteria<CSchema, Alias> {
-    return new RootCriteria(schema, alias);
+  static GetCriteria<CSchema extends CriteriaSchema>(
+    schema: ValidSchema<CSchema>,
+  ): RootCriteria<CSchema> {
+    return new RootCriteria(schema);
   }
 
   /**
@@ -45,14 +44,10 @@ export class CriteriaFactory {
    * const postJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(PostSchema, 'posts');
    * // postJoinCriteria can then be used in the .join() method of another Criteria
    */
-  static GetInnerJoinCriteria<
-    CSchema extends CriteriaSchema,
-    Alias extends SelectedAliasOf<CSchema>,
-  >(
+  static GetInnerJoinCriteria<CSchema extends CriteriaSchema>(
     schema: ValidSchema<CSchema>,
-    alias: Alias,
-  ): InnerJoinCriteria<CSchema, Alias> {
-    return new InnerJoinCriteria(schema, alias);
+  ): InnerJoinCriteria<CSchema> {
+    return new InnerJoinCriteria(schema);
   }
 
   /**
@@ -68,14 +63,10 @@ export class CriteriaFactory {
    *
    * const commentJoinCriteria = CriteriaFactory.GetLeftJoinCriteria(CommentSchema, 'comments');
    */
-  static GetLeftJoinCriteria<
-    CSchema extends CriteriaSchema,
-    Alias extends SelectedAliasOf<CSchema>,
-  >(
+  static GetLeftJoinCriteria<CSchema extends CriteriaSchema>(
     schema: ValidSchema<CSchema>,
-    alias: Alias,
-  ): LeftJoinCriteria<CSchema, Alias> {
-    return new LeftJoinCriteria(schema, alias);
+  ): LeftJoinCriteria<CSchema> {
+    return new LeftJoinCriteria(schema);
   }
 
   /**
@@ -91,13 +82,9 @@ export class CriteriaFactory {
    *
    * const profileJoinCriteria = CriteriaFactory.GetOuterJoinCriteria(ProfileSchema, 'profiles');
    */
-  static GetOuterJoinCriteria<
-    CSchema extends CriteriaSchema,
-    Alias extends SelectedAliasOf<CSchema>,
-  >(
+  static GetOuterJoinCriteria<CSchema extends CriteriaSchema>(
     schema: ValidSchema<CSchema>,
-    alias: Alias,
-  ): OuterJoinCriteria<CSchema, Alias> {
-    return new OuterJoinCriteria(schema, alias);
+  ): OuterJoinCriteria<CSchema> {
+    return new OuterJoinCriteria(schema);
   }
 }
diff --git a/src/criteria/criteria.ts b/src/criteria/criteria.ts
index 67a7735..b0d5416 100644
--- a/src/criteria/criteria.ts
+++ b/src/criteria/criteria.ts
@@ -2,7 +2,6 @@ import type {
   CriteriaSchema,
   FieldOfSchema,
   SchemaJoins,
-  SelectedAliasOf,
 } from './types/schema.types.js';
 
 import { CriteriaFilterManager } from './criteria-filter-manager.js';
@@ -35,13 +34,9 @@ export type ValidSchema<CSchema extends CriteriaSchema> =
  * Concrete criteria types (e.g., RootCriteria, JoinCriteria) will extend this class.
  *
  * @template TSchema - The schema definition for the entity this criteria operates on.
- * @template CurrentAlias - The selected alias for the entity from its schema.
  */
-export abstract class Criteria<
-  const TSchema extends CriteriaSchema,
-  const CurrentAlias extends
-    SelectedAliasOf<TSchema> = SelectedAliasOf<TSchema>,
-> implements ICriteriaBase<TSchema, CurrentAlias>
+export abstract class Criteria<const TSchema extends CriteriaSchema>
+  implements ICriteriaBase<TSchema>
 {
   private readonly _filterManager = new CriteriaFilterManager<TSchema>();
   private readonly _joinManager = new CriteriaJoinManager<TSchema>();
@@ -68,23 +63,14 @@ export abstract class Criteria<
   protected readonly _schema: TSchema;
   /**
    * Initializes a new instance of the Criteria class.
-   * @param {TSchema} schema - The schema definition for the entity.
-   * @param {CurrentAlias} _alias - The alias to use for this entity in the query.
-   * @throws {Error} If the provided alias is not supported by the schema.
+   * @param {ValidSchema<TSchema>} schema - The schema definition for the entity.
    * @throws {Error} If the schema's identifier_field is not one of its defined fields.
    * @protected
    */
-  constructor(
-    schema: ValidSchema<TSchema>,
-    protected _alias: CurrentAlias,
-  ) {
+  constructor(schema: ValidSchema<TSchema>) {
     if (typeof schema === 'string') {
       throw new Error(`Invalid Schema: ${schema}`);
     }
-    if (!schema.alias.includes(this._alias))
-      throw new Error(
-        `Unsupported alia ${this._alias} for schema ${schema.source_name}`,
-      );
     if (!schema.fields.includes(schema.identifier_field)) {
       throw new Error(
         `Schema identifier_field '${String(schema.identifier_field)}' must be one of the schema's defined fields. Schema: ${schema.source_name}`,
@@ -216,8 +202,8 @@ export abstract class Criteria<
    * Gets the alias used for the entity of this criteria.
    * @returns {CurrentAlias} The alias string.
    */
-  get alias(): CurrentAlias {
-    return this._alias;
+  get alias(): TSchema['alias'] {
+    return this.schema.alias;
   }
   /**
    * Sets the maximum number of records to return (LIMIT).
@@ -324,35 +310,36 @@ export abstract class Criteria<
   /**
    * Adds a join to another criteria.
    * @template TJoinSchema - The schema of the entity to join.
-   * @template TJoinedCriteriaAlias - The alias for the joined entity.
-   * @template TMatchingJoinConfig - The specific join configuration from the parent schema that matches the joined
-   *   alias.
-   * @param {JoinCriteriaParameterType<TSchema, TJoinSchema, TJoinedCriteriaAlias, TMatchingJoinConfig>} criteriaToJoin
-   * The criteria instance representing the entity to join (e.g., `InnerJoinCriteria`, `LeftJoinCriteria`).
-   * @param {JoinParameterType<TSchema, TJoinSchema, TMatchingJoinConfig>} joinParameter
-   * The parameters defining how the join should be performed (e.g., fields for simple join, pivot table details for
+   * @template TJoinedCriteriaSourceName - The `source_name` of the entity being joined.
+   * @template TMatchingJoinConfig - The specific join configuration from the parent schema that matches the provided `joinAlias` and `criteriaToJoin.sourceName`.
+   * @param {TMatchingJoinConfig['alias']} joinAlias - The specific alias defined in the parent schema's `joins` array for this relation.
+   * @param {JoinCriteriaParameterType<TSchema, TJoinSchema, TJoinedCriteriaSourceName, TMatchingJoinConfig>} criteriaToJoin -
+   *   The criteria instance representing the entity to join (e.g., `InnerJoinCriteria`, `LeftJoinCriteria`).
+   * @param {JoinParameterType<TSchema, TJoinSchema, TMatchingJoinConfig>} joinParameter -
+   *   The parameters defining how the join should be performed (e.g., fields for simple join, pivot table details for
    *   many-to-many).
    * @returns {this} The current criteria instance for chaining.
    * @throws {Error} If `criteriaToJoin` is a string (which is invalid).
    * @throws {Error} If `parent_field` in `joinParameter` (or `parent_field.reference` for pivot joins) is not defined
    *   in the parent schema.
-   * @throws {Error} If the join configuration for the given `criteriaToJoin.alias` is not found in the parent schema's
+   * @throws {Error} If the join configuration for the given `joinAlias` and `criteriaToJoin.sourceName` is not found in the parent schema's
    *   `joins` array.
    * @throws {Error} If `joinParameter` is invalid for the `relation_type` defined in the schema (e.g., using
    *   simple join input for many-to-many or vice-versa).
    */
   join<
     TJoinSchema extends CriteriaSchema,
-    TJoinedCriteriaAlias extends SelectedAliasOf<TJoinSchema>,
+    TJoinedCriteriaSourceName extends TJoinSchema['source_name'],
     TMatchingJoinConfig extends SpecificMatchingJoinConfig<
       TSchema,
-      TJoinedCriteriaAlias
+      TJoinedCriteriaSourceName
     >,
   >(
+    joinAlias: TMatchingJoinConfig['alias'],
     criteriaToJoin: JoinCriteriaParameterType<
       TSchema,
       TJoinSchema,
-      TJoinedCriteriaAlias,
+      TJoinedCriteriaSourceName,
       TMatchingJoinConfig
     >,
     joinParameter: JoinParameterType<TSchema, TJoinSchema, TMatchingJoinConfig>,
@@ -366,11 +353,13 @@ export abstract class Criteria<
       : this.assetFieldOnSchema(joinParameter.parent_field);
 
     const joinConfig = this.schema.joins.find(
-      (join) => join.alias === criteriaToJoin.alias,
+      (join) =>
+        join.target_source_name === criteriaToJoin.sourceName &&
+        join.alias === joinAlias,
     );
     if (!joinConfig) {
       throw new Error(
-        `Join configuration for alias '${String(criteriaToJoin.alias)}' not found in schema '${this.schema.source_name}'.`,
+        `Join configuration for '${String(joinAlias)}' of '${String(criteriaToJoin.sourceName)}' not found in schema '${this.schema.source_name}'.`,
       );
     }
 
@@ -383,9 +372,13 @@ export abstract class Criteria<
       parent_alias: this.alias,
       parent_source_name: this.sourceName,
       relation_type: joinConfig.relation_type,
+      join_alias: joinAlias,
       join_metadata:
-        this.schema.joins.find((join) => join.alias === criteriaToJoin.alias)
-          ?.metadata ?? {},
+        this.schema.joins.find(
+          (join) =>
+            join.alias === joinAlias &&
+            join.target_source_name === criteriaToJoin.sourceName,
+        )?.metadata ?? {},
       parent_schema_metadata: this.schema.metadata ?? {},
       parent_identifier: this.identifierField,
     };
diff --git a/src/criteria/cursor.ts b/src/criteria/cursor.ts
index 107eaf0..d4111a4 100644
--- a/src/criteria/cursor.ts
+++ b/src/criteria/cursor.ts
@@ -78,4 +78,8 @@ export class Cursor<
     this.filters = filterArray as typeof this.filters;
     this.order = order;
   }
+
+  get operator() {
+    return this.filters[0].operator;
+  }
 }
diff --git a/src/criteria/filter/filter-group.ts b/src/criteria/filter/filter-group.ts
index 2c5070d..86bea90 100644
--- a/src/criteria/filter/filter-group.ts
+++ b/src/criteria/filter/filter-group.ts
@@ -36,7 +36,7 @@ export class FilterGroup<T extends string = string>
     return this._logicalOperator;
   }
 
-  static createInitial<T extends string = string>(
+  public static createInitial<T extends string = string>(
     filterPrimitive: FilterPrimitive<T, FilterOperator>,
   ): FilterGroup<T> {
     return new FilterGroup({
@@ -45,14 +45,16 @@ export class FilterGroup<T extends string = string>
     });
   }
 
-  toPrimitive(): FilterGroupPrimitive<T> {
+  public toPrimitive(): FilterGroupPrimitive<T> {
     return {
       logicalOperator: this._logicalOperator,
       items: this._items.map((item) => item.toPrimitive()),
     };
   }
 
-  addAnd(filterPrimitive: FilterPrimitive<T, FilterOperator>): FilterGroup<T> {
+  public addAnd(
+    filterPrimitive: FilterPrimitive<T, FilterOperator>,
+  ): FilterGroup<T> {
     if (this._logicalOperator === LogicalOperator.AND) {
       return new FilterGroup({
         logicalOperator: LogicalOperator.AND,
@@ -88,7 +90,9 @@ export class FilterGroup<T extends string = string>
     });
   }
 
-  addOr(filterPrimitive: FilterPrimitive<T, FilterOperator>): FilterGroup<T> {
+  public addOr(
+    filterPrimitive: FilterPrimitive<T, FilterOperator>,
+  ): FilterGroup<T> {
     const currentItems = this._items.map((item) => item.toPrimitive());
 
     if (this._logicalOperator === LogicalOperator.AND) {
@@ -123,13 +127,21 @@ export class FilterGroup<T extends string = string>
     });
   }
 
-  accept<TranslationContext, TranslationOutput = TranslationContext>(
-    visitor: ICriteriaVisitor<TranslationContext, TranslationOutput>,
+  /**
+   * Accepts a visitor and calls the appropriate visit method based on the logical operator.
+   * @param visitor The visitor implementation.
+   * @param currentAlias The alias of the current entity being processed.
+   * @param context The mutable context object for the translation.
+   */
+  public accept<TranslationContext>(
+    visitor: ICriteriaVisitor<TranslationContext>,
     currentAlias: string,
     context: TranslationContext,
-  ): TranslationOutput {
-    return this.logicalOperator === LogicalOperator.AND
-      ? visitor.visitAndGroup(this, currentAlias, context)
-      : visitor.visitOrGroup(this, currentAlias, context);
+  ): void {
+    if (this.logicalOperator === LogicalOperator.AND) {
+      visitor.visitAndGroup(this, currentAlias, context);
+    } else {
+      visitor.visitOrGroup(this, currentAlias, context);
+    }
   }
 }
diff --git a/src/criteria/filter/filter.ts b/src/criteria/filter/filter.ts
index 916c91c..fcc5dfc 100644
--- a/src/criteria/filter/filter.ts
+++ b/src/criteria/filter/filter.ts
@@ -26,24 +26,27 @@ export class Filter<T extends string, Operator extends FilterOperator>
     return this.primitive.value;
   }
 
-  accept<
-    TranslationContext,
-    TranslationOutput = TranslationContext,
-    TFilterVisitorOutput extends any = any,
-  >(
-    visitor: ICriteriaVisitor<
-      TranslationContext,
-      TranslationOutput,
-      TFilterVisitorOutput
-    >,
+  /**
+   * Accepts a visitor and calls the appropriate visit method.
+   * @template TranslationContext The type of the context object.
+   * @template TFilterVisitorOutput The specific return type expected from `visitFilter`.
+   * @param visitor The visitor implementation.
+   * @param currentAlias The alias of the current entity being processed.
+   * @param context The mutable context object for the translation.
+   * @returns The result of the visitor processing this filter.
+   */
+  public accept<TranslationContext, TFilterVisitorOutput extends any>(
+    visitor: ICriteriaVisitor<TranslationContext, TFilterVisitorOutput>,
     currentAlias: string,
+    context: TranslationContext,
   ): TFilterVisitorOutput {
-    return visitor.visitFilter(this, currentAlias);
+    return visitor.visitFilter(this, currentAlias, context);
   }
 
-  toPrimitive(): FilterPrimitive<T, Operator> {
+  public toPrimitive(): FilterPrimitive<T, Operator> {
     return this.primitive;
   }
+
   private isString(value: any): value is string {
     return typeof value === 'string';
   }
diff --git a/src/criteria/index.ts b/src/criteria/index.ts
index c79689e..6b14d0e 100644
--- a/src/criteria/index.ts
+++ b/src/criteria/index.ts
@@ -19,7 +19,6 @@ export { GetTypedCriteriaSchema } from './types/schema.types.js';
 export type {
   CriteriaSchema,
   FieldOfSchema,
-  SelectedAliasOf,
   JoinRelationType,
   SchemaJoins,
 } from './types/schema.types.js';
diff --git a/src/criteria/join/inner.join-criteria.ts b/src/criteria/join/inner.join-criteria.ts
index bcf542d..fffd8d1 100644
--- a/src/criteria/join/inner.join-criteria.ts
+++ b/src/criteria/join/inner.join-criteria.ts
@@ -1,7 +1,6 @@
 import type {
   CriteriaSchema,
   JoinRelationType,
-  SelectedAliasOf,
 } from '../types/schema.types.js';
 import type { PivotJoin, SimpleJoin } from '../types/join-parameter.types.js';
 import { Criteria, type ValidSchema } from '../criteria.js';
@@ -9,48 +8,38 @@ import type { ICriteriaVisitor } from '../types/visitor-interface.types.js';
 
 /**
  * Represents an INNER JOIN criteria.
- * It extends the base {@link Criteria} and defines how it's visited by a {@link ICriteriaVisitor}.
  * @template CSchema - The {@link CriteriaSchema} of the entity being joined.
  * @template Alias - The selected alias for the joined entity from its schema.
  */
 export class InnerJoinCriteria<
   CSchema extends CriteriaSchema,
-  Alias extends SelectedAliasOf<CSchema> = SelectedAliasOf<CSchema>,
-> extends Criteria<CSchema, Alias> {
+> extends Criteria<CSchema> {
   /**
    * Accepts a criteria visitor to process this inner join criteria.
-   * It first validates the join field against the schema before dispatching to the visitor.
-   * @template TranslationContext - The type of the context object passed during traversal.
-   * @template TranslationOutput - The type of the result returned by visitor methods.
-   * @param {ICriteriaVisitor<TranslationContext, TranslationOutput>} visitor - The visitor instance.
-   * @param {PivotJoin<CriteriaSchema, CSchema, JoinRelationType> | SimpleJoin<CriteriaSchema, CSchema,
-   *   JoinRelationType>} parameters - The fully resolved parameters for this join, including parent and join field
-   *   details.
-   * @param {TranslationContext} context - The context object to be passed to the visitor.
-   * @returns {TranslationOutput} The result of the visitor processing this join.
+   * @param visitor The visitor instance.
+   * @param parameters The fully resolved parameters for this join.
+   * @param context The context object to be passed to the visitor.
    */
-  accept<TranslationContext, TranslationOutput>(
-    visitor: ICriteriaVisitor<TranslationContext, TranslationOutput>,
+  public accept<TranslationContext>(
+    visitor: ICriteriaVisitor<TranslationContext>,
     parameters:
       | PivotJoin<CriteriaSchema, CSchema, JoinRelationType>
       | SimpleJoin<CriteriaSchema, CSchema, JoinRelationType>,
     context: TranslationContext,
-  ): TranslationOutput {
+  ): void {
     typeof parameters.join_field === 'object'
       ? this.assetFieldOnSchema(parameters.join_field.reference)
       : this.assetFieldOnSchema(parameters.join_field);
 
-    return visitor.visitInnerJoin(this, parameters, context);
+    visitor.visitInnerJoin(this, parameters, context);
   }
+
   /**
-   * Returns a new instance of `RootCriteria` with the same schema and alias configuration,
-   * but with all other states (filters, joins, ordering, pagination, selection) reset to their defaults.
-   * @returns {InnerJoinCriteria<CSchema, Alias>} A new, reset `RootCriteria` instance.
+   * Returns a new instance of `InnerJoinCriteria` with the same schema and alias configuration,
+   * but with all other states reset to their defaults.
+   * @returns {InnerJoinCriteria<CSchema, Alias>} A new, reset `InnerJoinCriteria` instance.
    */
-  resetCriteria(): InnerJoinCriteria<CSchema, Alias> {
-    return new InnerJoinCriteria(
-      this.schema as ValidSchema<CSchema>,
-      this._alias,
-    );
+  public resetCriteria(): InnerJoinCriteria<CSchema> {
+    return new InnerJoinCriteria(this.schema as ValidSchema<CSchema>);
   }
 }
diff --git a/src/criteria/join/left.join-criteria.ts b/src/criteria/join/left.join-criteria.ts
index 1227d5a..4eeaa6e 100644
--- a/src/criteria/join/left.join-criteria.ts
+++ b/src/criteria/join/left.join-criteria.ts
@@ -1,7 +1,6 @@
 import type {
   CriteriaSchema,
   JoinRelationType,
-  SelectedAliasOf,
 } from '../types/schema.types.js';
 import type { PivotJoin, SimpleJoin } from '../types/join-parameter.types.js';
 import { Criteria, type ValidSchema } from '../criteria.js';
@@ -15,8 +14,7 @@ import type { ICriteriaVisitor } from '../types/visitor-interface.types.js';
  */
 export class LeftJoinCriteria<
   CSchema extends CriteriaSchema,
-  Alias extends SelectedAliasOf<CSchema> = SelectedAliasOf<CSchema>,
-> extends Criteria<CSchema, Alias> {
+> extends Criteria<CSchema> {
   /**
    * Accepts a criteria visitor to process this left join criteria.
    * It first validates the join field against the schema before dispatching to the visitor.
@@ -28,28 +26,25 @@ export class LeftJoinCriteria<
    * @param {TranslationContext} context - The context object to be passed to the visitor.
    * @returns {TranslationOutput} The result of the visitor processing this join.
    */
-  accept<TranslationContext, TranslationOutput>(
-    visitor: ICriteriaVisitor<TranslationContext, TranslationOutput>,
+  accept<TranslationContext>(
+    visitor: ICriteriaVisitor<TranslationContext>,
     parameters:
       | PivotJoin<CriteriaSchema, CSchema, JoinRelationType>
       | SimpleJoin<CriteriaSchema, CSchema, JoinRelationType>,
     context: TranslationContext,
-  ): TranslationOutput {
+  ): void {
     typeof parameters.join_field === 'object'
       ? this.assetFieldOnSchema(parameters.join_field.reference)
       : this.assetFieldOnSchema(parameters.join_field);
 
-    return visitor.visitLeftJoin(this, parameters, context);
+    visitor.visitLeftJoin(this, parameters, context);
   }
   /**
    * Returns a new instance of `RootCriteria` with the same schema and alias configuration,
    * but with all other states (filters, joins, ordering, pagination, selection) reset to their defaults.
    * @returns {LeftJoinCriteria<CSchema, Alias>} A new, reset `RootCriteria` instance.
    */
-  resetCriteria(): LeftJoinCriteria<CSchema, Alias> {
-    return new LeftJoinCriteria(
-      this.schema as ValidSchema<CSchema>,
-      this._alias,
-    );
+  resetCriteria(): LeftJoinCriteria<CSchema> {
+    return new LeftJoinCriteria(this.schema as ValidSchema<CSchema>);
   }
 }
diff --git a/src/criteria/join/outer.join-criteria.ts b/src/criteria/join/outer.join-criteria.ts
index 1ae0d07..3906396 100644
--- a/src/criteria/join/outer.join-criteria.ts
+++ b/src/criteria/join/outer.join-criteria.ts
@@ -1,7 +1,6 @@
 import type {
   CriteriaSchema,
   JoinRelationType,
-  SelectedAliasOf,
 } from '../types/schema.types.js';
 import type { PivotJoin, SimpleJoin } from '../types/join-parameter.types.js';
 import { Criteria, type ValidSchema } from '../criteria.js';
@@ -10,46 +9,39 @@ import type { ICriteriaVisitor } from '../types/visitor-interface.types.js';
 /**
  * Represents an OUTER JOIN (typically FULL OUTER JOIN) criteria.
  * It extends the base {@link Criteria} and defines how it's visited by a {@link ICriteriaVisitor}.
- * Note: Full OUTER JOIN support can vary between database systems.
  * @template CSchema - The {@link CriteriaSchema} of the entity being joined.
  * @template Alias - The selected alias for the joined entity from its schema.
  */
 export class OuterJoinCriteria<
   CSchema extends CriteriaSchema,
-  Alias extends SelectedAliasOf<CSchema> = SelectedAliasOf<CSchema>,
-> extends Criteria<CSchema, Alias> {
+> extends Criteria<CSchema> {
   /**
    * Accepts a criteria visitor to process this outer join criteria.
-   * It first validates the join field against the schema before dispatching to the visitor.
-   * @template TranslationContext - The type of the context object passed during traversal.
-   * @template TranslationOutput - The type of the result returned by visitor methods.
-   * @param {ICriteriaVisitor<TranslationContext, TranslationOutput>} visitor - The visitor instance.
-   * @param {PivotJoin<CriteriaSchema, CSchema, JoinRelationType> | SimpleJoin<CriteriaSchema, CSchema, JoinRelationType>} parameters -
-   *   The fully resolved parameters for this join, including parent and join field details.
-   * @param {TranslationContext} context - The context object to be passed to the visitor.
-   * @returns {TranslationOutput} The result of the visitor processing this join.
+   * @template TranslationContext The type of the context object passed during traversal.
+   * @template TOuterJoinVisitorOutput The specific return type expected from the visitor's `visitOuterJoin` method.
+   * @param visitor The visitor instance.
+   * @param parameters The fully resolved parameters for this join.
+   * @param context The context object to be passed to the visitor.
+   * @returns The result of the visitor processing this join.
    */
-  accept<TranslationContext, TranslationOutput>(
-    visitor: ICriteriaVisitor<TranslationContext, TranslationOutput>,
+  public accept<TranslationContext>(
+    visitor: ICriteriaVisitor<TranslationContext>,
     parameters:
       | PivotJoin<CriteriaSchema, CSchema, JoinRelationType>
       | SimpleJoin<CriteriaSchema, CSchema, JoinRelationType>,
     context: TranslationContext,
-  ): TranslationOutput {
+  ): void {
     typeof parameters.join_field === 'object'
       ? this.assetFieldOnSchema(parameters.join_field.reference)
       : this.assetFieldOnSchema(parameters.join_field);
-    return visitor.visitOuterJoin(this, parameters, context);
+    visitor.visitOuterJoin(this, parameters, context);
   }
   /**
-   * Returns a new instance of `RootCriteria` with the same schema and alias configuration,
-   * but with all other states (filters, joins, ordering, pagination, selection) reset to their defaults.
-   * @returns {OuterJoinCriteria<CSchema, Alias>} A new, reset `RootCriteria` instance.
+   * Returns a new instance of `OuterJoinCriteria` with the same schema and alias configuration,
+   * but with all other states reset to their defaults.
+   * @returns {OuterJoinCriteria<CSchema, Alias>} A new, reset `OuterJoinCriteria` instance.
    */
-  resetCriteria(): OuterJoinCriteria<CSchema, Alias> {
-    return new OuterJoinCriteria(
-      this.schema as ValidSchema<CSchema>,
-      this._alias,
-    );
+  public resetCriteria(): OuterJoinCriteria<CSchema> {
+    return new OuterJoinCriteria(this.schema as ValidSchema<CSchema>);
   }
 }
diff --git a/src/criteria/root.criteria.ts b/src/criteria/root.criteria.ts
index 4136946..bcac7f2 100644
--- a/src/criteria/root.criteria.ts
+++ b/src/criteria/root.criteria.ts
@@ -1,43 +1,33 @@
 import { Criteria, type ValidSchema } from './criteria.js';
-import type { CriteriaSchema, SelectedAliasOf } from './types/schema.types.js';
+import type { CriteriaSchema } from './types/schema.types.js';
 import type { ICriteriaVisitor } from './types/visitor-interface.types.js';
 
 /**
  * Represents the root criteria for a query.
- * This is the main entry point for building a query and defines the primary entity being queried.
- * It extends the base {@link Criteria} and defines how it's visited by a {@link ICriteriaVisitor}.
  * @template CSchema - The {@link CriteriaSchema} of the root entity.
  * @template Alias - The selected alias for the root entity from its schema.
  */
 export class RootCriteria<
   CSchema extends CriteriaSchema,
-  Alias extends SelectedAliasOf<CSchema>,
-> extends Criteria<CSchema, Alias> {
+> extends Criteria<CSchema> {
   /**
    * Accepts a criteria visitor to process this root criteria.
-   * This method is the entry point for the visitor pattern to traverse the criteria tree.
-   * @template TranslationContext - The type of the context object passed during traversal (e.g., a query builder
-   *   instance).
-   * @template TranslationOutput - The type of the result returned by visitor methods (e.g., the modified query builder
-   *   or a query string).
-   * @param {ICriteriaVisitor<TranslationContext, TranslationOutput>} visitor - The visitor instance responsible for
-   *   translating criteria parts.
-   * @param {TranslationContext} context - The context object to be passed to the visitor (e.g., an initial query
-   *   builder or an empty string for SQL).
-   * @returns {TranslationOutput} The result of the visitor processing this root criteria and its components.
+   * @param visitor The visitor instance responsible for translating criteria parts.
+   * @param context The context object to be passed to the visitor.
    */
-  accept<TranslationContext, TranslationOutput>(
-    visitor: ICriteriaVisitor<TranslationContext, TranslationOutput>,
+  public accept<TranslationContext>(
+    visitor: ICriteriaVisitor<TranslationContext>,
     context: TranslationContext,
-  ): TranslationOutput {
-    return visitor.visitRoot(this, context);
+  ): void {
+    visitor.visitRoot(this, context);
   }
+
   /**
    * Returns a new instance of `RootCriteria` with the same schema and alias configuration,
    * but with all other states (filters, joins, ordering, pagination, selection) reset to their defaults.
    * @returns {RootCriteria<CSchema, Alias>} A new, reset `RootCriteria` instance.
    */
-  resetCriteria(): RootCriteria<CSchema, Alias> {
-    return new RootCriteria(this.schema as ValidSchema<CSchema>, this._alias);
+  public resetCriteria(): RootCriteria<CSchema> {
+    return new RootCriteria(this.schema as ValidSchema<CSchema>);
   }
 }
diff --git a/src/criteria/test/criteria-factory.test.ts b/src/criteria/test/criteria-factory.test.ts
index a066af0..2be4526 100644
--- a/src/criteria/test/criteria-factory.test.ts
+++ b/src/criteria/test/criteria-factory.test.ts
@@ -8,8 +8,8 @@ import { UserSchema, PostSchema } from './fake-entities.js';
 describe('CriteriaFactory', () => {
   describe('GetCriteria', () => {
     it('should create a RootCriteria instance with correct sourceName and alias', () => {
-      const alias = UserSchema.alias[0]!;
-      const criteria = CriteriaFactory.GetCriteria(UserSchema, alias);
+      const alias = UserSchema.alias;
+      const criteria = CriteriaFactory.GetCriteria(UserSchema);
 
       expect(criteria).toBeInstanceOf(RootCriteria);
       expect(criteria.sourceName).toBe(UserSchema.source_name);
@@ -19,8 +19,8 @@ describe('CriteriaFactory', () => {
 
   describe('GetInnerJoinCriteria', () => {
     it('should create an InnerJoinCriteria instance with correct sourceName and alias', () => {
-      const alias = PostSchema.alias[0]!;
-      const criteria = CriteriaFactory.GetInnerJoinCriteria(PostSchema, alias);
+      const alias = PostSchema.alias;
+      const criteria = CriteriaFactory.GetInnerJoinCriteria(PostSchema);
 
       expect(criteria).toBeInstanceOf(InnerJoinCriteria);
       expect(criteria.sourceName).toBe(PostSchema.source_name);
@@ -30,8 +30,8 @@ describe('CriteriaFactory', () => {
 
   describe('GetLeftJoinCriteria', () => {
     it('should create a LeftJoinCriteria instance with correct sourceName and alias', () => {
-      const alias = PostSchema.alias[0]!;
-      const criteria = CriteriaFactory.GetLeftJoinCriteria(PostSchema, alias);
+      const alias = PostSchema.alias;
+      const criteria = CriteriaFactory.GetLeftJoinCriteria(PostSchema);
 
       expect(criteria).toBeInstanceOf(LeftJoinCriteria);
       expect(criteria.sourceName).toBe(PostSchema.source_name);
@@ -41,8 +41,8 @@ describe('CriteriaFactory', () => {
 
   describe('GetOuterJoinCriteria', () => {
     it('should create an OuterJoinCriteria instance with correct sourceName and alias', () => {
-      const alias = PostSchema.alias[0]!;
-      const criteria = CriteriaFactory.GetOuterJoinCriteria(PostSchema, alias);
+      const alias = PostSchema.alias;
+      const criteria = CriteriaFactory.GetOuterJoinCriteria(PostSchema);
 
       expect(criteria).toBeInstanceOf(OuterJoinCriteria);
       expect(criteria.sourceName).toBe(PostSchema.source_name);
diff --git a/src/criteria/test/criteria.test.ts b/src/criteria/test/criteria.test.ts
index 93fdaf8..ef8da55 100644
--- a/src/criteria/test/criteria.test.ts
+++ b/src/criteria/test/criteria.test.ts
@@ -1,10 +1,3 @@
-import { RootCriteria } from '../root.criteria.js';
-import { FilterGroup } from '../filter/filter-group.js';
-import { OrderDirection } from '../order/order.js';
-import { InnerJoinCriteria } from '../join/inner.join-criteria.js';
-import { LeftJoinCriteria } from '../join/left.join-criteria.js';
-import type { StoredJoinDetails } from '../types/join-utility.types.js';
-
 import { FilterOperator, LogicalOperator } from '../types/operator.types.js';
 import {
   PermissionSchema,
@@ -15,13 +8,18 @@ import {
 import {
   type CriteriaSchema,
   GetTypedCriteriaSchema,
-  type SelectedAliasOf,
 } from '../types/schema.types.js';
+import { type StoredJoinDetails } from '../types/join-utility.types.js';
+import { RootCriteria } from '../root.criteria.js';
+import { FilterGroup } from '../filter/filter-group.js';
+import { OrderDirection } from '../order/order.js';
+import { InnerJoinCriteria } from '../join/inner.join-criteria.js';
+import { LeftJoinCriteria } from '../join/left.join-criteria.js';
 
 const testJoinsData = (
   joinDetails: StoredJoinDetails<CriteriaSchema>,
   joinParameter: { join_field: string | object; parent_field: string | object },
-  parentCriteria: RootCriteria<CriteriaSchema, SelectedAliasOf<CriteriaSchema>>,
+  parentCriteria: RootCriteria<CriteriaSchema>,
 ) => {
   expect(joinDetails.parameters.join_field).toBe(joinParameter.join_field);
   expect(joinDetails.parameters.parent_field).toBe(joinParameter.parent_field);
@@ -35,10 +33,10 @@ const testJoinsData = (
 };
 
 describe('Criteria', () => {
-  let criteriaRoot: RootCriteria<typeof PostSchema, 'posts'>;
+  let criteriaRoot: RootCriteria<typeof PostSchema>;
 
   beforeEach(() => {
-    criteriaRoot = new RootCriteria(PostSchema, 'posts');
+    criteriaRoot = new RootCriteria(PostSchema);
   });
 
   describe('Initialization and Defaults', () => {
@@ -67,7 +65,7 @@ describe('Criteria', () => {
         ...PostSchema,
         metadata: { customInfo: 'testValue' },
       });
-      const criteriaWithMeta = new RootCriteria(schemaWithMetadata, 'posts');
+      const criteriaWithMeta = new RootCriteria(schemaWithMetadata);
       expect(criteriaWithMeta.schemaMetadata).toEqual({
         customInfo: 'testValue',
       });
@@ -87,7 +85,6 @@ describe('Criteria', () => {
           new RootCriteria(
             // @ts-expect-error Testing invalid schema
             invalidSchema,
-            'users',
           ),
       ).toThrow(
         `Schema identifier_field 'non_existent_field' must be one of the schema's defined fields. Schema: user`,
@@ -406,15 +403,8 @@ describe('Criteria', () => {
   });
 
   describe('Join Functionality', () => {
-    it('should throw an error if join configuration for alias is not found in schema', () => {
-      expect(() => {
-        // @ts-expect-error testing invalid join_alias type
-        new InnerJoinCriteria(UserSchema, 'non_existent_join_alias');
-      }).toThrow('Unsupported alia non_existent_join_alias for schema user');
-    });
-
     it('should throw an error if parent_field in joinParameter is not in parent schema', () => {
-      const userJoinCriteria = new InnerJoinCriteria(UserSchema, 'publisher');
+      const userJoinCriteria = new InnerJoinCriteria(UserSchema);
       const joinParameter = {
         parent_field: 'invalid_parent_field',
         join_field: 'uuid',
@@ -422,20 +412,20 @@ describe('Criteria', () => {
 
       expect(() => {
         // @ts-expect-error testing invalid parent_field type
-        criteriaRoot.join(userJoinCriteria, joinParameter);
+        criteriaRoot.join('publisher', userJoinCriteria, joinParameter);
       }).toThrow(
         "The field 'invalid_parent_field' is not defined in the schema 'post'.",
       );
     });
 
     it('should add an inner join and correctly populate parent_identifier', () => {
-      const userJoinCriteria = new InnerJoinCriteria(UserSchema, 'publisher');
+      const userJoinCriteria = new InnerJoinCriteria(UserSchema);
       const joinParameter = {
         parent_field: 'user_uuid',
         join_field: 'uuid',
       } as const;
 
-      criteriaRoot.join(userJoinCriteria, joinParameter);
+      criteriaRoot.join('publisher', userJoinCriteria, joinParameter);
 
       const joinsArray = criteriaRoot.joins;
       expect(joinsArray.length).toBe(1);
@@ -443,7 +433,7 @@ describe('Criteria', () => {
       const joinEntry = joinsArray[0];
       expect(joinEntry).toBeDefined();
       if (joinEntry) {
-        expect(joinEntry.criteria.alias).toBe('publisher');
+        expect(joinEntry.parameters.join_alias).toBe('publisher');
         expect(joinEntry.criteria).toBeInstanceOf(InnerJoinCriteria);
         testJoinsData(joinEntry, joinParameter, criteriaRoot);
         expect(joinEntry.criteria).toBe(userJoinCriteria);
@@ -451,18 +441,19 @@ describe('Criteria', () => {
     });
 
     it('should add a many-to-many join and correctly populate parent_identifier', () => {
-      const userCriteriaRoot = new RootCriteria(UserSchema, 'users');
-      const permissionJoinCriteria = new InnerJoinCriteria(
-        PermissionSchema,
-        'permissions',
-      );
+      const userCriteriaRoot = new RootCriteria(UserSchema);
+      const permissionJoinCriteria = new InnerJoinCriteria(PermissionSchema);
       const joinParameter = {
         pivot_source_name: 'user_permission_pivot',
         parent_field: { pivot_field: 'user_uuid', reference: 'uuid' },
         join_field: { pivot_field: 'permission_uuid', reference: 'uuid' },
       } as const;
 
-      userCriteriaRoot.join(permissionJoinCriteria, joinParameter);
+      userCriteriaRoot.join(
+        'permissions',
+        permissionJoinCriteria,
+        joinParameter,
+      );
 
       const joinsArray = userCriteriaRoot.joins;
       expect(joinsArray.length).toBe(1);
@@ -480,33 +471,30 @@ describe('Criteria', () => {
     });
 
     it('should add multiple joins and correctly populate parent_identifier for each', () => {
-      const userJoinCriteria = new InnerJoinCriteria(UserSchema, 'publisher');
+      const userJoinCriteria = new InnerJoinCriteria(UserSchema);
       const userJoinParameter = {
         parent_field: 'user_uuid',
         join_field: 'uuid',
       } as const;
 
-      const commentJoinCriteria = new LeftJoinCriteria(
-        PostCommentSchema,
-        'comments',
-      );
+      const commentJoinCriteria = new LeftJoinCriteria(PostCommentSchema);
       const commentJoinParameter = {
         parent_field: 'uuid',
         join_field: 'post_uuid',
       } as const;
 
       criteriaRoot
-        .join(userJoinCriteria, userJoinParameter)
-        .join(commentJoinCriteria, commentJoinParameter);
+        .join('publisher', userJoinCriteria, userJoinParameter)
+        .join('comments', commentJoinCriteria, commentJoinParameter);
 
       const joinsArray = criteriaRoot.joins;
       expect(joinsArray.length).toBe(2);
 
       const publisherJoin = joinsArray.find(
-        (entry) => entry.criteria.alias === 'publisher',
+        (entry) => entry.parameters.join_alias === 'publisher',
       );
       const commentsJoin = joinsArray.find(
-        (entry) => entry.criteria.alias === 'comments',
+        (entry) => entry.parameters.join_alias === 'comments',
       );
 
       expect(publisherJoin).toBeDefined();
@@ -523,8 +511,8 @@ describe('Criteria', () => {
     });
 
     it('should replace a join if the same alias is used and check parent_identifier', () => {
-      const userJoinCriteria1 = new InnerJoinCriteria(UserSchema, 'publisher');
-      const userJoinCriteria2 = new LeftJoinCriteria(UserSchema, 'publisher');
+      const userJoinCriteria1 = new InnerJoinCriteria(UserSchema);
+      const userJoinCriteria2 = new LeftJoinCriteria(UserSchema);
 
       const userJoinParameter = {
         parent_field: 'user_uuid',
@@ -532,8 +520,8 @@ describe('Criteria', () => {
       } as const;
 
       criteriaRoot
-        .join(userJoinCriteria1, userJoinParameter)
-        .join(userJoinCriteria2, userJoinParameter);
+        .join('publisher', userJoinCriteria1, userJoinParameter)
+        .join('publisher', userJoinCriteria2, userJoinParameter);
 
       const joinsArray = criteriaRoot.joins;
       expect(joinsArray.length).toBe(1);
@@ -541,7 +529,7 @@ describe('Criteria', () => {
       const joinEntry = joinsArray[0];
       expect(joinEntry).toBeDefined();
       if (joinEntry) {
-        expect(joinEntry.criteria.alias).toBe('publisher');
+        expect(joinEntry.parameters.join_alias).toBe('publisher');
         expect(joinEntry.criteria).toBeInstanceOf(LeftJoinCriteria);
         testJoinsData(joinEntry, userJoinParameter, criteriaRoot);
         expect(joinEntry.criteria).toBe(userJoinCriteria2);
@@ -604,17 +592,16 @@ describe('Criteria', () => {
         'should throw for $description',
         ({
           rootSchema,
-          rootAlias,
           joinSchema,
-          joinAlias,
           joinParam,
+          joinAlias,
           expectedErrorMsg,
         }) => {
-          const root = new RootCriteria(rootSchema, rootAlias);
-          const joinCrit = new InnerJoinCriteria(joinSchema, joinAlias);
+          const root = new RootCriteria(rootSchema);
+          const joinCrit = new InnerJoinCriteria(joinSchema);
           expect(() => {
             // @ts-expect-error - Testing invalid types
-            root.join(joinCrit, joinParam);
+            root.join(joinAlias, joinCrit, joinParam);
           }).toThrow(expectedErrorMsg);
         },
       );
@@ -656,11 +643,11 @@ describe('Criteria', () => {
         } as const,
       ])(
         'should pass validation for a valid $description',
-        ({ rootSchema, rootAlias, joinSchema, joinAlias, joinParam }) => {
-          const root = new RootCriteria(rootSchema, rootAlias);
-          const joinCrit = new InnerJoinCriteria(joinSchema, joinAlias);
+        ({ rootSchema, joinSchema, joinAlias, joinParam }) => {
+          const root = new RootCriteria(rootSchema);
+          const joinCrit = new InnerJoinCriteria(joinSchema);
           expect(() => {
-            root.join(joinCrit, joinParam as any);
+            root.join(joinAlias, joinCrit, joinParam as any);
           }).not.toThrow();
         },
       );
@@ -669,7 +656,7 @@ describe('Criteria', () => {
 
   describe('Complex Criteria Building', () => {
     it('should build a complete criteria with all features', () => {
-      const criteria = new RootCriteria(PostSchema, 'posts')
+      const criteria = new RootCriteria(PostSchema)
         .setSelect(['uuid', 'title', 'user_uuid'])
         .where({
           field: 'title',
@@ -677,7 +664,8 @@ describe('Criteria', () => {
           value: '%test%',
         })
         .join(
-          new InnerJoinCriteria(PostCommentSchema, 'comments')
+          'comments',
+          new InnerJoinCriteria(PostCommentSchema)
             .setSelect(['uuid', 'comment_text'])
             .where({
               field: 'comment_text',
@@ -713,8 +701,7 @@ describe('Criteria', () => {
       expect(criteria.joins).toHaveLength(1);
       expect(criteria.orders).toHaveLength(1);
       const joinCriteria = criteria.joins[0]?.criteria as InnerJoinCriteria<
-        typeof PostCommentSchema,
-        'comments'
+        typeof PostCommentSchema
       >;
       expect(joinCriteria?.select).toEqual(
         expect.arrayContaining([
diff --git a/src/criteria/test/fake-entities.ts b/src/criteria/test/fake-entities.ts
index a52af05..54a519f 100644
--- a/src/criteria/test/fake-entities.ts
+++ b/src/criteria/test/fake-entities.ts
@@ -16,21 +16,24 @@ export interface User extends EntityBase {
 
 export const UserSchema = GetTypedCriteriaSchema({
   source_name: 'user',
-  alias: ['users', 'user', 'publisher'],
+  alias: 'users',
   fields: ['uuid', 'email', 'username', 'created_at'],
   identifier_field: 'uuid',
   joins: [
     {
       alias: 'permissions',
       relation_type: 'many_to_many',
+      target_source_name: 'permission',
     },
     {
       alias: 'addresses',
       relation_type: 'one_to_many',
+      target_source_name: 'address',
     },
     {
       alias: 'posts',
       relation_type: 'one_to_many',
+      target_source_name: 'post',
     },
   ],
 });
@@ -52,7 +55,7 @@ export interface Post extends EntityBase {
 
 export const PostSchema = GetTypedCriteriaSchema({
   source_name: 'post',
-  alias: ['posts', 'post'],
+  alias: 'posts',
   identifier_field: 'uuid',
   fields: [
     'uuid',
@@ -64,8 +67,16 @@ export const PostSchema = GetTypedCriteriaSchema({
     'metadata',
   ],
   joins: [
-    { alias: 'comments', relation_type: 'one_to_many' },
-    { alias: 'publisher', relation_type: 'many_to_one' },
+    {
+      alias: 'comments',
+      relation_type: 'one_to_many',
+      target_source_name: 'post_comment',
+    },
+    {
+      alias: 'publisher',
+      relation_type: 'many_to_one',
+      target_source_name: 'user',
+    },
   ],
 });
 export type PostSchema = typeof PostSchema;
@@ -78,12 +89,12 @@ export interface Comment extends EntityBase {
 
 export const PostCommentSchema = GetTypedCriteriaSchema({
   source_name: 'post_comment',
-  alias: ['comments', 'comment'],
+  alias: 'comments',
   fields: ['uuid', 'comment_text', 'user_uuid', 'post_uuid', 'created_at'],
   identifier_field: 'uuid',
   joins: [
-    { alias: 'post', relation_type: 'many_to_one' },
-    { alias: 'user', relation_type: 'many_to_one' },
+    { alias: 'post', relation_type: 'many_to_one', target_source_name: 'post' },
+    { alias: 'user', relation_type: 'many_to_one', target_source_name: 'user' },
   ],
 });
 export type PostCommentSchema = typeof PostCommentSchema;
@@ -94,13 +105,14 @@ export interface Permission extends EntityBase {
 
 export const PermissionSchema = GetTypedCriteriaSchema({
   source_name: 'permission',
-  alias: ['permissions', 'permission'],
+  alias: 'permissions',
   fields: ['uuid', 'name', 'created_at'],
   identifier_field: 'uuid',
   joins: [
     {
       alias: 'users',
       relation_type: 'many_to_many',
+      target_source_name: 'user',
     },
   ],
 });
@@ -112,13 +124,14 @@ export interface Address extends EntityBase {
 
 export const AddressSchema = GetTypedCriteriaSchema({
   source_name: 'address',
-  alias: ['addresses', 'address'],
+  alias: 'addresses',
   fields: ['uuid', 'direction', 'user_uuid', 'created_at'],
   identifier_field: 'uuid',
   joins: [
     {
       alias: 'user',
       relation_type: 'many_to_one',
+      target_source_name: 'user',
     },
   ],
 });
@@ -168,7 +181,7 @@ export interface DomainEvent<T extends { [key: string]: any }> {
 
 export const DomainEventsSchema = GetTypedCriteriaSchema({
   source_name: 'event',
-  alias: ['event', 'events'],
+  alias: 'events',
   identifier_field: 'id',
   fields: [
     'id',
diff --git a/src/criteria/translator/criteria-translator.ts b/src/criteria/translator/criteria-translator.ts
index 67b507a..5e69f1c 100644
--- a/src/criteria/translator/criteria-translator.ts
+++ b/src/criteria/translator/criteria-translator.ts
@@ -1,124 +1,96 @@
+import type { ICriteriaVisitor } from '../types/visitor-interface.types.js';
+import type { RootCriteria } from '../root.criteria.js';
 import type {
   CriteriaSchema,
   JoinRelationType,
-  SelectedAliasOf,
 } from '../types/schema.types.js';
-import type { RootCriteria } from '../root.criteria.js';
-import type { PivotJoin, SimpleJoin } from '../types/join-parameter.types.js';
-import type { FilterGroup } from '../filter/filter-group.js';
 import type { InnerJoinCriteria } from '../join/inner.join-criteria.js';
 import type { LeftJoinCriteria } from '../join/left.join-criteria.js';
 import type { OuterJoinCriteria } from '../join/outer.join-criteria.js';
+import type { PivotJoin, SimpleJoin } from '../types/join-parameter.types.js';
 import type { Filter } from '../filter/filter.js';
-import type { ICriteriaVisitor } from '../types/visitor-interface.types.js';
+import type { FilterGroup } from '../filter/filter-group.js';
 import type { FilterOperator } from '../types/operator.types.js';
 
 /**
- * Abstract Class for translating criteria into various query formats
- * @template TranslationContext - The target format (e.g., QueryBuilder, raw SQL string, etc.)
- * @template TranslationOutput - The output format by default its Source (Only specify this if
- * you really need something like a memory translator and the output would be different
- * from the TranslationContext itself)
- * @template RootSchema - The schema type for the root criteria
- * @example
- * // TypeORM QueryBuilder translator
- * class TypeORMTranslator implements CriteriaTranslator<SelectQueryBuilder<Entity>> {
- *  ...Concrete implementation
- * }
+ * An abstract base class for creating specific criteria translators.
+ * It implements the ICriteriaVisitor interface and provides a structured way to handle the translation process.
  *
- * // Raw MySQL translator
- * export class MysqlTranslator extends CriteriaTranslator<string, string> { {
- *  ...Concrete implementation
- * }
+ * @template TranslationContext The mutable context object (e.g., a query builder) passed through the traversal.
+ * @template TranslationOutput The final result type of the translation process. Defaults to `TranslationContext`.
+ * @template TFilterVisitorOutput The specific type returned by `visitFilter`.
  */
 export abstract class CriteriaTranslator<
   TranslationContext,
   TranslationOutput = TranslationContext,
-  TFilterVisitorOutput extends any = any,
-> implements
-    ICriteriaVisitor<
-      TranslationContext,
-      TranslationOutput,
-      TFilterVisitorOutput
-    >
+  TFilterVisitorOutput = any,
+> implements ICriteriaVisitor<TranslationContext, TFilterVisitorOutput>
 {
   /**
-   * Translates a criteria into the target source format
-   * @param criteria - The criteria to translate
-   * @param source - The source object to translate into (e.g., QueryBuilder instance, or raw SQL string)
-   * @returns The modified source or the output format if specified
+   * Translates a `RootCriteria` object into a target format.
+   * This is the main entry point for the translation process.
+   * @param criteria The `RootCriteria` to translate.
+   * @param source The initial context for the translation (e.g., a new query builder).
+   * @returns The final translated output.
    */
-  translate<RootCriteriaSchema extends CriteriaSchema>(
-    criteria: RootCriteria<
-      RootCriteriaSchema,
-      SelectedAliasOf<RootCriteriaSchema>
-    >,
+  public abstract translate<RootCriteriaSchema extends CriteriaSchema>(
+    criteria: RootCriteria<RootCriteriaSchema>,
     source: TranslationContext,
-  ): TranslationOutput {
-    return criteria.accept(this, source);
-  }
+  ): TranslationOutput;
 
-  abstract visitRoot<
-    RootCriteriaSchema extends CriteriaSchema,
-    RootAlias extends SelectedAliasOf<RootCriteriaSchema>,
-  >(
-    criteria: RootCriteria<RootCriteriaSchema, RootAlias>,
+  public abstract visitRoot<RootCSchema extends CriteriaSchema>(
+    criteria: RootCriteria<RootCSchema>,
     context: TranslationContext,
-  ): TranslationOutput;
+  ): void;
 
-  abstract visitInnerJoin<
+  public abstract visitInnerJoin<
     ParentCSchema extends CriteriaSchema,
-    JoinCriteriaSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCriteriaSchema>,
+    JoinCSchema extends CriteriaSchema,
   >(
-    criteria: InnerJoinCriteria<JoinCriteriaSchema, JoinAlias>,
+    criteria: InnerJoinCriteria<JoinCSchema>,
     parameters:
-      | PivotJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>
-      | SimpleJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>,
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
     context: TranslationContext,
-  ): TranslationOutput;
+  ): void;
 
-  abstract visitLeftJoin<
+  public abstract visitLeftJoin<
     ParentCSchema extends CriteriaSchema,
-    JoinCriteriaSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCriteriaSchema>,
+    JoinCSchema extends CriteriaSchema,
   >(
-    criteria: LeftJoinCriteria<JoinCriteriaSchema, JoinAlias>,
+    criteria: LeftJoinCriteria<JoinCSchema>,
     parameters:
-      | PivotJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>
-      | SimpleJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>,
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
     context: TranslationContext,
-  ): TranslationOutput;
+  ): void;
 
-  abstract visitOuterJoin<
+  public abstract visitOuterJoin<
     ParentCSchema extends CriteriaSchema,
-    JoinCriteriaSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCriteriaSchema>,
+    JoinCSchema extends CriteriaSchema,
   >(
-    criteria: OuterJoinCriteria<JoinCriteriaSchema, JoinAlias>,
+    criteria: OuterJoinCriteria<JoinCSchema>,
     parameters:
-      | PivotJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>
-      | SimpleJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>,
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
     context: TranslationContext,
-  ): TranslationOutput;
+  ): void;
 
-  abstract visitFilter<
-    FieldType extends string,
-    Operator extends FilterOperator,
-  >(
-    filter: Filter<FieldType, Operator>,
+  public abstract visitFilter<FieldType extends string>(
+    filter: Filter<FieldType, FilterOperator>,
     currentAlias: string,
+    context: TranslationContext,
   ): TFilterVisitorOutput;
 
-  abstract visitAndGroup<FieldType extends string>(
+  public abstract visitAndGroup<FieldType extends string>(
     group: FilterGroup<FieldType>,
     currentAlias: string,
     context: TranslationContext,
-  ): TranslationOutput;
+  ): void;
 
-  abstract visitOrGroup<FieldType extends string>(
+  public abstract visitOrGroup<FieldType extends string>(
     group: FilterGroup<FieldType>,
     currentAlias: string,
     context: TranslationContext,
-  ): TranslationOutput;
+  ): void;
 }
diff --git a/src/criteria/types/criteria.interface.ts b/src/criteria/types/criteria.interface.ts
index f55e11c..76c85e7 100644
--- a/src/criteria/types/criteria.interface.ts
+++ b/src/criteria/types/criteria.interface.ts
@@ -1,8 +1,4 @@
-import type {
-  CriteriaSchema,
-  FieldOfSchema,
-  SelectedAliasOf,
-} from './schema.types.js';
+import type { CriteriaSchema, FieldOfSchema } from './schema.types.js';
 import type { FilterGroup } from '../filter/filter-group.js';
 
 import type { Cursor } from '../cursor.js';
@@ -20,12 +16,8 @@ import type { FilterPrimitive } from '../filter/types/filter-primitive.types.js'
  * Base interface for defining query criteria.
  * It provides methods for filtering, joining, selecting fields, ordering, and paginating results.
  * @template TSchema - The schema definition for the primary entity.
- * @template CurrentAlias - The selected alias for the primary entity from its schema.
  */
-export interface ICriteriaBase<
-  TSchema extends CriteriaSchema,
-  CurrentAlias extends SelectedAliasOf<TSchema>,
-> {
+export interface ICriteriaBase<TSchema extends CriteriaSchema> {
   /**
    * Gets the metadata associated with the root schema of this criteria.
    * @returns {TSchema['metadata']} The metadata object from the schema, which can be undefined.
@@ -153,9 +145,9 @@ export interface ICriteriaBase<
 
   /**
    * Gets the alias for the root entity of this criteria.
-   * @returns {CurrentAlias} The alias string.
+   * @returns {TSchema['alias']} The alias string.
    */
-  get alias(): CurrentAlias;
+  get alias(): TSchema['alias'];
 
   /**
    * Gets the source name (e.g., table name) for the root entity of this criteria.
@@ -217,29 +209,31 @@ export interface ICriteriaBase<
   /**
    * Adds a join to another criteria.
    * @template TJoinSchema - The schema of the entity to join.
-   * @template TJoinedCriteriaAlias - The alias for the joined entity.
-   * @template TMatchingJoinConfig - The specific join configuration from the parent schema that matches the joined alias.
-   * @param {JoinCriteriaParameterType<TSchema, TJoinSchema, TJoinedCriteriaAlias, TMatchingJoinConfig>} criteriaToJoin
-   * The criteria instance representing the entity to join (e.g., `InnerJoinCriteria`, `LeftJoinCriteria`).
-   * @param {JoinParameterType<TSchema, TJoinSchema, TMatchingJoinConfig>} joinParameter
-   * The parameters defining how the join should be performed (e.g., fields for simple join, pivot table details for many-to-many).
+   * @template TJoinedCriteriaSourceName - The `source_name` of the entity being joined.
+   * @template TMatchingJoinConfig - The specific join configuration from the parent schema that matches the provided `joinAlias` and `criteriaToJoin.sourceName`.
+   * @param {TMatchingJoinConfig['alias']} joinAlias - The specific alias defined in the parent schema's `joins` array for this relation.
+   * @param {JoinCriteriaParameterType<TSchema, TJoinSchema, TJoinedCriteriaSourceName, TMatchingJoinConfig>} criteriaToJoin -
+   *   The criteria instance representing the entity to join (e.g., `InnerJoinCriteria`, `LeftJoinCriteria`).
+   * @param {JoinParameterType<TSchema, TJoinSchema, TMatchingJoinConfig>} joinParameter -
+   *   The parameters defining how the join should be performed (e.g., fields for simple join, pivot table details for many-to-many).
    * @returns {this} The current criteria instance for chaining.
-   * @throws {Error} If the join configuration for the given alias is not found in the parent schema.
+   * @throws {Error} If the join configuration for the given `joinAlias` and `criteriaToJoin.sourceName` is not found in the parent schema.
    * @throws {Error} If `parent_field` in `joinParameter` is not defined in the parent schema.
    * @throws {Error} If `joinParameter` is invalid for the `relation_type` defined in the schema (e.g., using simple join input for many-to-many).
    */
   join<
     TJoinSchema extends CriteriaSchema,
-    TJoinedCriteriaAlias extends SelectedAliasOf<TJoinSchema>,
+    TJoinedCriteriaSourceName extends TJoinSchema['source_name'],
     TMatchingJoinConfig extends SpecificMatchingJoinConfig<
       TSchema,
-      TJoinedCriteriaAlias
+      TJoinedCriteriaSourceName
     >,
   >(
+    joinAlias: TMatchingJoinConfig['alias'],
     criteriaToJoin: JoinCriteriaParameterType<
       TSchema,
       TJoinSchema,
-      TJoinedCriteriaAlias,
+      TJoinedCriteriaSourceName,
       TMatchingJoinConfig
     >,
     joinParameter: JoinParameterType<TSchema, TJoinSchema, TMatchingJoinConfig>,
diff --git a/src/criteria/types/join-parameter.types.ts b/src/criteria/types/join-parameter.types.ts
index fe12361..9ab9d9a 100644
--- a/src/criteria/types/join-parameter.types.ts
+++ b/src/criteria/types/join-parameter.types.ts
@@ -23,6 +23,7 @@ export type PivotJoin<
   parent_source_name: ParentSchema['source_name'];
   /** The alias used for the parent entity in the query. */
   parent_alias: ParentSchema['alias'][number];
+  join_alias: ParentSchema['joins'][number]['alias'];
   parent_identifier: FieldOfSchema<ParentSchema>;
   /** The source name (table name) of the pivot table. */
   pivot_source_name: string;
@@ -82,6 +83,7 @@ export type SimpleJoin<
   parent_source_name: ParentSchema['source_name'];
   /** The alias used for the parent entity in the query. */
   parent_alias: ParentSchema['alias'][number];
+  join_alias: ParentSchema['joins'][number]['alias'];
   parent_identifier: FieldOfSchema<ParentSchema>;
   /**
    * The field name in the parent schema used for the join condition.
diff --git a/src/criteria/types/join-utility.types.ts b/src/criteria/types/join-utility.types.ts
index d01f6f6..466c107 100644
--- a/src/criteria/types/join-utility.types.ts
+++ b/src/criteria/types/join-utility.types.ts
@@ -2,7 +2,6 @@ import type {
   CriteriaSchema,
   JoinRelationType,
   SchemaJoins,
-  SelectedAliasOf,
 } from './schema.types.js';
 import type { PivotJoin, SimpleJoin } from './join-parameter.types.js';
 
@@ -14,15 +13,11 @@ import type { PivotJoinInput, SimpleJoinInput } from './join-input.types.js';
 /**
  * Represents any type of join criteria (Inner, Left, or Outer).
  * @template CSchema - The {@link CriteriaSchema} of the entity being joined.
- * @template Alias - The selected alias for the joined entity from its schema.
  */
-export type AnyJoinCriteria<
-  CSchema extends CriteriaSchema,
-  Alias extends SelectedAliasOf<CSchema> = SelectedAliasOf<CSchema>,
-> =
-  | InnerJoinCriteria<CSchema, Alias>
-  | LeftJoinCriteria<CSchema, Alias>
-  | OuterJoinCriteria<CSchema, Alias>;
+export type AnyJoinCriteria<CSchema extends CriteriaSchema> =
+  | InnerJoinCriteria<CSchema>
+  | LeftJoinCriteria<CSchema>
+  | OuterJoinCriteria<CSchema>;
 
 /**
  * Defines the structure for storing the details of a configured join.
@@ -39,40 +34,40 @@ export interface StoredJoinDetails<ParentSchema extends CriteriaSchema> {
   /**
    * The criteria instance representing the joined entity (e.g., InnerJoinCriteria).
    */
-  criteria: AnyJoinCriteria<CriteriaSchema, SelectedAliasOf<CriteriaSchema>>;
+  criteria: AnyJoinCriteria<CriteriaSchema>;
 }
 
 /**
  * Determines the type of the criteria object to be passed to the `.join()` method.
- * If the `ActualJoinedAlias` is not a valid join alias in the `ParentSchema`,
+ * If the `ActualJoinedSourceName` is not configured for join in the `ParentSchema`,
  * this type resolves to an error message string, providing strong type-time feedback.
  * Otherwise, it resolves to {@link AnyJoinCriteria}.
  *
  * @template ParentSchema - The {@link CriteriaSchema} of the parent entity.
  * @template JoinedSchema - The {@link CriteriaSchema} of the entity to be joined.
- * @template ActualJoinedAlias - The specific alias used for the `JoinedSchema`.
- * @template MatchingConfigForActualAlias - The join configuration from `ParentSchema` that matches `ActualJoinedAlias`.
+ * @template ActualJoinedSourceName - The specific `source_name` of the `JoinedSchema` being joined.
+ * @template MatchingConfigForActualSourceName - The join configuration from `ParentSchema` that matches `ActualJoinedSourceName`.
  *                                         Should be `never` if no match is found.
  */
 export type JoinCriteriaParameterType<
   ParentSchema extends CriteriaSchema,
   JoinedSchema extends CriteriaSchema,
-  ActualJoinedAlias extends SelectedAliasOf<JoinedSchema>,
-  MatchingConfigForActualAlias extends SchemaJoins<string> | never,
-> = [MatchingConfigForActualAlias] extends [never]
-  ? `Error: The alias '${ActualJoinedAlias}' of schema '${JoinedSchema['source_name']}' is not configured for join in '${ParentSchema['source_name']}'.`
-  : AnyJoinCriteria<JoinedSchema, ActualJoinedAlias>;
+  ActualJoinedSourceName extends JoinedSchema['source_name'],
+  MatchingConfigForActualSourceName extends SchemaJoins<string> | never,
+> = [MatchingConfigForActualSourceName] extends [never]
+  ? `Error: The joined parent source name '${ActualJoinedSourceName}' is not configured for join in '${ParentSchema['source_name']}'.`
+  : AnyJoinCriteria<JoinedSchema>;
 
 /**
  * Determines the expected shape of the join parameters object passed to the `.join()` method,
- * based on the `relation_type` defined in the `ParentSchema` for the `ActualJoinedAlias`.
- * If the `ActualJoinedAlias` is not a valid join alias, this type resolves to `never`.
+ * based on the `relation_type` defined in the `ParentSchema` for the matching join configuration.
+ * If no matching join configuration is found for the `ActualJoinedSourceName`, this type resolves to `never`.
  * For 'many_to_many' relations, it expects {@link PivotJoinInput}.
  * For other relations (one-to-one, one-to-many, many-to-one), it expects {@link SimpleJoinInput}.
  *
  * @template ParentSchema - The {@link CriteriaSchema} of the parent entity.
  * @template JoinedSchema - The {@link CriteriaSchema} of the entity to be joined.
- * @template MatchingConfigForActualAlias - The join configuration from `ParentSchema` that matches the alias of `JoinedSchema`.
+ * @template MatchingConfigForActualSourceName - The join configuration from `ParentSchema` that matches the `source_name` of `JoinedSchema`.
  *                                         Should be `never` if no match is found.
  */
 export type JoinParameterType<
@@ -87,22 +82,22 @@ export type JoinParameterType<
 
 /**
  * Extracts the specific join configuration object from the `ParentSchema`'s `joins` array
- * that matches the provided `JoinedSchemaSpecificAlias`.
+ * that matches the provided `JoinedSchemaSpecificSourceName`.
  * This utility type is crucial for inferring the `relation_type` and other
  * join-specific details defined in the parent schema.
  *
  * @template ParentSchema - The {@link CriteriaSchema} of the parent entity.
- * @template JoinedSchemaSpecificAlias - The specific alias of the joined entity,
+ * @template JoinedSchemaSpecificSourceName - The specific `source_name` of the joined entity,
  *                                       as defined in the `ParentSchema.joins` configuration.
  * @example
- * // Given UserSchema has a join defined as: { alias: 'posts', relation_type: 'one_to_many' }
- * // type UserPostsJoinConfig = SpecificMatchingJoinConfig<typeof UserSchema, 'posts'>;
- * // UserPostsJoinConfig would be: { alias: 'posts'; relation_type: 'one_to_many'; }
+ * // Given UserSchema has a join defined as: { alias: 'posts', target_source_name: 'posts_table', relation_type: 'one_to_many' }
+ * // type UserPostsJoinConfig = SpecificMatchingJoinConfig<typeof UserSchema, 'posts_table'>;
+ * // UserPostsJoinConfig would be: { alias: 'posts'; target_source_name: 'posts_table'; relation_type: 'one_to_many'; }
  */
 export type SpecificMatchingJoinConfig<
   ParentSchema extends CriteriaSchema,
-  JoinedSchemaSpecificAlias extends string,
+  JoinedSchemaSpecificSourceName extends string,
 > = Extract<
   ParentSchema['joins'][number],
-  { alias: JoinedSchemaSpecificAlias }
+  { target_source_name: JoinedSchemaSpecificSourceName }
 >;
diff --git a/src/criteria/types/manager.interface.ts b/src/criteria/types/manager.interface.ts
index d0c8688..bd6ee27 100644
--- a/src/criteria/types/manager.interface.ts
+++ b/src/criteria/types/manager.interface.ts
@@ -3,7 +3,6 @@ import type {
   CriteriaSchema,
   FieldOfSchema,
   JoinRelationType,
-  SelectedAliasOf,
 } from './schema.types.js';
 
 import type { FilterPrimitive } from '../filter/types/filter-primitive.types.js';
@@ -64,13 +63,13 @@ export interface IJoinManager<CSchema extends CriteriaSchema> {
   /**
    * Adds a join configuration to the Criteria.
    * @template JoinSchema - The {@link CriteriaSchema} of the entity being joined.
-   * @param {AnyJoinCriteria<JoinSchema, SelectedAliasOf<JoinSchema>>} criteriaToJoin -
+   * @param {AnyJoinCriteria<JoinSchema>} criteriaToJoin -
    *   The criteria instance representing the entity to join (e.g., InnerJoinCriteria, LeftJoinCriteria).
    * @param {PivotJoin<CSchema, JoinSchema, JoinRelationType> | SimpleJoin<CSchema, JoinSchema, JoinRelationType>} joinParameter -
    *   The fully resolved parameters defining how the join should be performed.
    */
   addJoin<JoinSchema extends CriteriaSchema>(
-    criteriaToJoin: AnyJoinCriteria<JoinSchema, SelectedAliasOf<JoinSchema>>,
+    criteriaToJoin: AnyJoinCriteria<JoinSchema>,
     joinParameter:
       | PivotJoin<CSchema, JoinSchema, JoinRelationType>
       | SimpleJoin<CSchema, JoinSchema, JoinRelationType>,
diff --git a/src/criteria/types/schema.types.ts b/src/criteria/types/schema.types.ts
index fb339f4..8852114 100644
--- a/src/criteria/types/schema.types.ts
+++ b/src/criteria/types/schema.types.ts
@@ -13,13 +13,15 @@ export type JoinRelationType =
 
 /**
  * Describes the configuration for a joinable relation within a {@link CriteriaSchema}.
- * @template ValidAlias - A string literal type representing a valid alias for the join.
+ * @template ValidAlias - A string literal type representing the alias to be used for the joined entity in the query.
  */
 export type SchemaJoins<ValidAlias extends string> = {
-  /** The alias used to refer to this join in criteria construction. */
+  /** The alias to be used for the joined entity in the final query (e.g., 'p' for posts). */
   alias: ValidAlias;
   /** The type of relationship this join represents (e.g., 'one_to_many'). */
   relation_type: JoinRelationType;
+  /** The `source_name` of the schema that this relation targets. Used for robust validation. */
+  target_source_name: string;
   /**
    * Optional metadata associated with this specific join configuration.
    * This allows for storing arbitrary, translator-specific information
@@ -32,23 +34,23 @@ export type SchemaJoins<ValidAlias extends string> = {
 
 /**
  * Represents the schema definition for an entity, used by the Criteria system.
- * It defines the entity's source name (e.g., table name), available aliases,
+ * It defines the entity's source name (e.g., table name), a single canonical alias,
  * fields, and joinable relations.
  * @template TFields - A readonly array of string literal types representing the entity's field names.
- * @template TAliases - A readonly array of string literal types representing the entity's valid aliases.
+ * @template TAliase - A string literal type for the entity's canonical alias.
  * @template TSourceName - A string literal type for the entity's source name.
  * @template JoinsAlias - A string literal type representing valid aliases for its joinable relations.
  */
 export type CriteriaSchema<
   TFields extends ReadonlyArray<string> = ReadonlyArray<string>,
-  TAliases extends ReadonlyArray<string> = ReadonlyArray<string>,
+  TAliase extends string = string,
   TSourceName extends string = string,
   JoinsAlias extends string = string,
 > = {
   /** The source name of the entity (e.g., database table name). */
   source_name: TSourceName;
-  /** An array of valid aliases that can be used to refer to this entity. */
-  alias: TAliases;
+  /** The canonical alias used to refer to this entity in queries. */
+  alias: TAliase;
   /** An array of field names available for this entity. */
   fields: TFields;
   /** An array of configurations for entities that can be joined from this entity. */
@@ -80,10 +82,10 @@ export type CriteriaSchema<
  * @example
  * export const UserSchema = GetTypedCriteriaSchema({
  *   source_name: 'users_table',
- *   alias: ['user', 'u'],
+ *   alias: 'u', // Single alias
  *   fields: ['id', 'name', 'email'],
  *   identifier_field: 'id', // Must be one of 'id', 'name', or 'email'
- *   joins: [{ alias: 'posts', relation_type: 'one_to_many' }]
+ *   joins: [{ alias: 'posts', target_source_name: 'posts_table', relation_type: 'one_to_many' }]
  * });
  */
 export function GetTypedCriteriaSchema<const TInput extends CriteriaSchema>(
@@ -99,11 +101,3 @@ export function GetTypedCriteriaSchema<const TInput extends CriteriaSchema>(
  */
 export type FieldOfSchema<T extends CriteriaSchema> =
   T['fields'] extends ReadonlyArray<string> ? T['fields'][number] : never;
-
-/**
- * Extracts a union type of all valid aliases from a given {@link CriteriaSchema}.
- * @template T - The {@link CriteriaSchema} from which to extract aliases.
- * @example type UserAliases = SelectedAliasOf<typeof UserSchema>; // "user" | "u"
- */
-export type SelectedAliasOf<T extends CriteriaSchema> =
-  T['alias'] extends ReadonlyArray<string> ? T['alias'][number] : never;
diff --git a/src/criteria/types/visitor-interface.types.ts b/src/criteria/types/visitor-interface.types.ts
index f9407ab..fad6c80 100644
--- a/src/criteria/types/visitor-interface.types.ts
+++ b/src/criteria/types/visitor-interface.types.ts
@@ -4,82 +4,93 @@ import type { LeftJoinCriteria } from '../join/left.join-criteria.js';
 import type { OuterJoinCriteria } from '../join/outer.join-criteria.js';
 import type { Filter } from '../filter/filter.js';
 import type { FilterGroup } from '../filter/filter-group.js';
-import type {
-  CriteriaSchema,
-  JoinRelationType,
-  SelectedAliasOf,
-} from './schema.types.js';
+import type { CriteriaSchema, JoinRelationType } from './schema.types.js';
 import type { PivotJoin, SimpleJoin } from './join-parameter.types.js';
 import type { FilterOperator } from './operator.types.js';
 
 /**
- * Visitor interface for traversing Criteria objects.
- * @template TranslationContext - The type of the context object passed during traversal.
- * @template TranslationOutput - The type of the result returned by visitor methods.
+ * Defines the contract for a visitor that traverses a Criteria object graph.
+ * @template TranslationContext The mutable context object (e.g., a query builder) passed through the traversal.
+ * @template TFilterVisitorOutput The specific type returned by `visitFilter`, typically an intermediate representation of a condition.
  */
 export interface ICriteriaVisitor<
   TranslationContext,
-  TranslationOutput = TranslationContext,
-  TFilterVisitorOutput extends any = any,
+  TFilterVisitorOutput = any,
 > {
-  visitRoot<
-    RootCSchema extends CriteriaSchema,
-    RootAlias extends SelectedAliasOf<RootCSchema>,
-  >(
-    criteria: RootCriteria<RootCSchema, RootAlias>,
+  /**
+   * Visits the root node of the Criteria tree.
+   */
+  visitRoot<RootCSchema extends CriteriaSchema>(
+    criteria: RootCriteria<RootCSchema>,
     context: TranslationContext,
-  ): TranslationOutput;
+  ): void;
 
+  /**
+   * Visits an Inner Join node.
+   */
   visitInnerJoin<
     ParentCSchema extends CriteriaSchema,
     JoinCSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCSchema>,
   >(
-    criteria: InnerJoinCriteria<JoinCSchema, JoinAlias>,
+    criteria: InnerJoinCriteria<JoinCSchema>,
     parameters:
       | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
       | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
     context: TranslationContext,
-  ): TranslationOutput;
+  ): void;
 
+  /**
+   * Visits a Left Join node.
+   */
   visitLeftJoin<
     ParentCSchema extends CriteriaSchema,
     JoinCSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCSchema>,
   >(
-    criteria: LeftJoinCriteria<JoinCSchema, JoinAlias>,
+    criteria: LeftJoinCriteria<JoinCSchema>,
     parameters:
       | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
       | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
     context: TranslationContext,
-  ): TranslationOutput;
+  ): void;
 
+  /**
+   * Visits an Outer Join node.
+   */
   visitOuterJoin<
     ParentCSchema extends CriteriaSchema,
     JoinCSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCSchema>,
   >(
-    criteria: OuterJoinCriteria<JoinCSchema, JoinAlias>,
+    criteria: OuterJoinCriteria<JoinCSchema>,
     parameters:
       | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
       | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
     context: TranslationContext,
-  ): TranslationOutput;
+  ): void;
 
+  /**
+   * Visits a single Filter node and returns an intermediate representation.
+   */
   visitFilter<FieldType extends string>(
     filter: Filter<FieldType, FilterOperator>,
     currentAlias: string,
+    context: TranslationContext,
   ): TFilterVisitorOutput;
 
+  /**
+   * Visits a group of filters joined by a logical AND.
+   */
   visitAndGroup<FieldType extends string>(
     group: FilterGroup<FieldType>,
     currentAlias: string,
     context: TranslationContext,
-  ): TranslationOutput;
+  ): void;
 
+  /**
+   * Visits a group of filters joined by a logical OR.
+   */
   visitOrGroup<FieldType extends string>(
     group: FilterGroup<FieldType>,
     currentAlias: string,
     context: TranslationContext,
-  ): TranslationOutput;
+  ): void;
 }
diff --git a/src/docs/api-reference/en.md b/src/docs/api-reference/en.md
index 396df9a..27e6131 100644
--- a/src/docs/api-reference/en.md
+++ b/src/docs/api-reference/en.md
@@ -25,7 +25,6 @@ This section provides a detailed reference for the public classes, interfaces, t
   - [`CriteriaSchema`](#criteriaschema)
   - [`GetTypedCriteriaSchema`](#gettypedcriteriaschema)
   - [`FieldOfSchema`](#fieldofschema)
-  - [`SelectedAliasOf`](#selectedaliasof)
   - [`JoinRelationType`](#joinrelationtype)
   - [`SchemaJoins`](#schemajoins)
   - [`FilterPrimitive`](#filterprimitive)
@@ -51,47 +50,47 @@ This section provides a detailed reference for the public classes, interfaces, t
 
 ### `CriteriaFactory`
 
-Provides static methods for creating instances of different types of `Criteria`. It simplifies the creation of `Criteria` objects and ensures they are instantiated with the correct schema and alias configuration.
+Provides static methods for creating instances of different types of `Criteria`. It simplifies the creation of `Criteria` objects and ensures they are instantiated with the correct schema. The alias is now inferred directly from the schema.
 
 **Static Methods:**
 
-- **`GetCriteria<CSchema extends CriteriaSchema, Alias extends SelectedAliasOf<CSchema>>(schema: CSchema, alias: Alias): RootCriteria<CSchema, Alias>`**
+- **`GetCriteria<CSchema extends CriteriaSchema>(schema: CSchema): RootCriteria<CSchema>`**
+
   - Creates an instance of `RootCriteria`. This is the starting point for building a main query.
   - **Parameters:**
     - `schema`: An instance of `CriteriaSchema` that defines the structure of the root entity.
-    - `alias`: A valid alias (string) for the root entity, defined within the `schema`.
   - **Returns:** An instance of `RootCriteria`.
   - **Example:**
 
 ```typescript
 import { CriteriaFactory, UserSchema } from '@nulledexp/translatable-criteria';
-const userCriteria = CriteriaFactory.GetCriteria(UserSchema, 'users');
+const userCriteria = CriteriaFactory.GetCriteria(UserSchema);
 ```
 
-- **`GetInnerJoinCriteria<CSchema extends CriteriaSchema, Alias extends SelectedAliasOf<CSchema>>(schema: CSchema, alias: Alias): InnerJoinCriteria<CSchema, Alias>`**
+- **`GetInnerJoinCriteria<CSchema extends CriteriaSchema>(schema: CSchema): InnerJoinCriteria<CSchema>`**
+
   - Creates an instance of `InnerJoinCriteria`. Used to define an `INNER JOIN` in a query.
   - **Parameters:**
     - `schema`: An instance of `CriteriaSchema` for the entity to be joined.
-    - `alias`: A valid alias for the joined entity, defined in its `schema`.
   - **Returns:** An instance of `InnerJoinCriteria`.
   - **Example:**
 
 ```typescript
 import { CriteriaFactory, PostSchema } from '@nulledexp/translatable-criteria';
-const postJoin = CriteriaFactory.GetInnerJoinCriteria(PostSchema, 'posts');
-// userCriteria.join(postJoin, { parent_field: 'id', join_field: 'user_id' });
+const postJoin = CriteriaFactory.GetInnerJoinCriteria(PostSchema);
+// userCriteria.join('posts', postJoin, { parent_field: 'id', join_field: 'userId' });
 ```
 
-- **`GetLeftJoinCriteria<CSchema extends CriteriaSchema, Alias extends SelectedAliasOf<CSchema>>(schema: CSchema, alias: Alias): LeftJoinCriteria<CSchema, Alias>`**
+- **`GetLeftJoinCriteria<CSchema extends CriteriaSchema>(schema: CSchema): LeftJoinCriteria<CSchema>`**
 
   - Creates an instance of `LeftJoinCriteria`. Used to define a `LEFT JOIN`.
   - **Returns:** An instance of `LeftJoinCriteria`.
 
-- **`GetOuterJoinCriteria<CSchema extends CriteriaSchema, Alias extends SelectedAliasOf<CSchema>>(schema: CSchema, alias: Alias): OuterJoinCriteria<CSchema, Alias>`**
+- **`GetOuterJoinCriteria<CSchema extends CriteriaSchema>(schema: CSchema): OuterJoinCriteria<CSchema>`**
   - Creates an instance of `OuterJoinCriteria`. Used to define a `FULL OUTER JOIN`.
   - **Returns:** An instance of `OuterJoinCriteria`.
 
-Back to Index
+[Back to Index](#index)
 
 ### `RootCriteria`
 
@@ -101,9 +100,9 @@ Instantiated via `CriteriaFactory.GetCriteria()`.
 **Main Methods (in addition to those inherited from `Criteria`):**
 
 - Implements `accept` for the Visitor pattern, calling `visitor.visitRoot()`.
-- `resetCriteria()`: Returns a new instance of `RootCriteria` with the same schema and alias configuration, but with all other states (filters, joins, etc.) reset.
+- `resetCriteria()`: Returns a new instance of `RootCriteria` with the same schema configuration, but with all other states (filters, joins, etc.) reset.
 
-Back to Index
+[Back to Index](#index)
 
 ### `InnerJoinCriteria`
 
@@ -115,7 +114,7 @@ Instantiated via `CriteriaFactory.GetInnerJoinCriteria()`.
 - Implements `accept` for the Visitor pattern, calling `visitor.visitInnerJoin()`.
 - `resetCriteria()`: Returns a new instance of `InnerJoinCriteria`.
 
-Back to Index
+[Back to Index](#index)
 
 ### `LeftJoinCriteria`
 
@@ -127,7 +126,7 @@ Instantiated via `CriteriaFactory.GetLeftJoinCriteria()`.
 - Implements `accept` for the Visitor pattern, calling `visitor.visitLeftJoin()`.
 - `resetCriteria()`: Returns a new instance of `LeftJoinCriteria`.
 
-Back to Index
+[Back to Index](#index)
 
 ### `OuterJoinCriteria`
 
@@ -139,7 +138,7 @@ Instantiated via `CriteriaFactory.GetOuterJoinCriteria()`.
 - Implements `accept` for the Visitor pattern, calling `visitor.visitOuterJoin()`.
 - `resetCriteria()`: Returns a new instance of `OuterJoinCriteria`.
 
-Back to Index
+[Back to Index](#index)
 
 ### `Criteria` (Abstract Base Class)
 
@@ -155,8 +154,10 @@ Abstract base class for all criteria types (`RootCriteria`, `InnerJoinCriteria`,
 - `joins: ReadonlyArray<StoredJoinDetails<TSchema>>`: Join configurations.
 - `rootFilterGroup: FilterGroup`: Root filter group.
 - `sourceName: TSchema['source_name']`: Source name from the schema.
-- `alias: CurrentAlias`: Current alias of the criteria.
+- `alias: TSchema['alias']`: The canonical alias from the schema.
 - `cursor: Cursor<...> | undefined`: Cursor configuration for pagination.
+- `identifierField: FieldOfSchema<TSchema>`: The name of the identifier field from the schema.
+- `schemaMetadata: TSchema['metadata']`: The metadata object from the schema.
 
 **Main Methods (chainable):**
 
@@ -168,10 +169,10 @@ Abstract base class for all criteria types (`RootCriteria`, `InnerJoinCriteria`,
 - **`where<Operator extends FilterOperator>(filterPrimitive: FilterPrimitive<...>): this`**: Initializes the filter group with a condition.
 - **`andWhere<Operator extends FilterOperator>(filterPrimitive: FilterPrimitive<...>): this`**: Adds an AND condition to the current filter group.
 - **`orWhere<Operator extends FilterOperator>(filterPrimitive: FilterPrimitive<...>): this`**: Adds an OR condition, creating a new group if necessary.
-- **`join<...>(criteriaToJoin: ..., joinParameter: ...): this`**: Adds a join condition.
+- **`join(joinAlias: string, criteriaToJoin: JoinCriteria, joinParameter: object): this`**: Adds a join condition.
 - **`setCursor(cursorFilters: [...], operator: ..., order: ...): this`**: Configures cursor-based pagination.
 
-Back to Index
+[Back to Index](#index)
 
 ### `Filter`
 
@@ -190,19 +191,14 @@ Represents an individual filter condition. Instantiated internally when using th
 
 **Methods:**
 
-- `accept(visitor: ICriteriaVisitor<...>, currentAlias: string): TFilterVisitorOutput`: For the Visitor pattern, calls `visitor.visitFilter()`.
+- `accept(visitor: ICriteriaVisitor<...>, currentAlias: string, context: ...): TFilterVisitorOutput`: For the Visitor pattern, calls `visitor.visitFilter()`.
 - `toPrimitive(): FilterPrimitive<T, Operator>`: Returns the primitive representation of the filter.
 
-Back to Index
+[Back to Index](#index)
 
 ### `FilterGroup`
 
-Represents a group of filters (`Filter` or nested `FilterGroup`) connected by a `LogicalOperator` (AND/OR). Instantiated and managed internally by `CriteriaFilterManager` when using `where`, `andWhere`, `orWhere` methods.
-
-**Constructor:**
-
-- `constructor(filterGroupPrimitive: FilterGroupPrimitive<T>)`
-  - Normalizes the primitive filter group (e.g., flattening nested AND groups).
+Represents a group of filters (`Filter` or nested `FilterGroup`) connected by a `LogicalOperator` (AND/OR). Instantiated and managed internally by `CriteriaFilterManager`.
 
 **Properties (getters):**
 
@@ -211,20 +207,15 @@ Represents a group of filters (`Filter` or nested `FilterGroup`) connected by a
 
 **Methods:**
 
-- `accept(visitor: ICriteriaVisitor<...>, currentAlias: string, context: ...): TranslationOutput`: For the Visitor pattern, calls `visitor.visitAndGroup()` or `visitor.visitOrGroup()` based on the `logicalOperator`.
+- `accept(visitor: ICriteriaVisitor<...>, currentAlias: string, context: ...): void`: For the Visitor pattern, calls `visitor.visitAndGroup()` or `visitor.visitOrGroup()` based on the `logicalOperator`.
 - `toPrimitive(): FilterGroupPrimitive<T>`: Returns the primitive representation of the filter group.
 
-Back to Index
+[Back to Index](#index)
 
 ### `Order`
 
 Represents an ordering rule. Instantiated internally when using the `orderBy()` method of a `Criteria`.
 
-**Constructor:**
-
-- `constructor(direction: OrderDirection, field: T)`
-  - Assigns a globally unique `sequenceId` to maintain a stable order.
-
 **Properties (getters):**
 
 - `sequenceId: number`: Sequence ID for stable ordering.
@@ -235,29 +226,19 @@ Represents an ordering rule. Instantiated internally when using the `orderBy()`
 
 - `toPrimitive(): OrderByPrimitive<T>`: Returns the primitive representation of the order rule.
 
-Back to Index
+[Back to Index](#index)
 
 ### `Cursor`
 
 Represents the configuration for cursor-based pagination. Instantiated internally when using the `setCursor()` method of a `Criteria`.
 
-**Constructor:**
-
-- `constructor(filterPrimitive: readonly [Omit<FilterPrimitive<...>, 'operator'>] | readonly [Omit<FilterPrimitive<...>, 'operator'>, Omit<FilterPrimitive<...>, 'operator'>], operator: FilterOperator.GREATER_THAN | FilterOperator.LESS_THAN, order: OrderDirection)`
-  - Validates that cursor fields and values are defined and valid.
-  - Supports 1 or 2 `FilterPrimitive`s for simple or composite cursors.
-  - @throws {Error} If any cursor field is not defined.
-  - @throws {Error} If any cursor value is undefined (null is allowed).
-  - @throws {Error} If two cursor fields are provided and they are identical.
-  - @throws {Error} If no filter primitives are provided.
-
 **Properties (readonly):**
 
-- `filters: [Filter<TFields, Operator>] | [Filter<TFields, Operator>, Filter<TFields, Operator>]`: The filters defining the cursor.
+- `filters: [Filter<...>] | [Filter<...>, Filter<...>]`: The filters defining the cursor.
 - `order: OrderDirection`: The ordering direction of the cursor.
 - `operator: FilterOperator.GREATER_THAN | FilterOperator.LESS_THAN`: The cursor operator.
 
-Back to Index
+[Back to Index](#index)
 
 ---
 
@@ -269,32 +250,22 @@ Abstract class that serves as the base for creating specific translators for dif
 
 - **Generics:**
 
-  - `TranslationContext`: The type of the context object that is passed and modified during translation (e.g., a TypeORM `SelectQueryBuilder`).
+  - `TranslationContext`: The type of the mutable context object (e.g., a query builder) passed through the traversal.
   - `TranslationOutput` (optional, defaults to `TranslationContext`): The type of the final translation result.
-  - `TFilterVisitorOutput` (optional, defaults to `any`): The specific output type for the `visitFilter`, `visitAndGroup`, and `visitOrGroup` methods.
-
-- **Main Method (for the translator user):**
-
-  - **`translate(criteria: RootCriteria<...>, source: TranslationContext): TranslationOutput`**
-    - Main public method to start the translation process.
-    - **Parameters:**
-      - `criteria`: The `RootCriteria` instance to translate.
-      - `source`: The initial context for the translation (e.g., a `SelectQueryBuilder` instance).
-    - **Returns:** The `TranslationOutput` (e.g., the modified `SelectQueryBuilder` or an SQL string).
+  - `TFilterVisitorOutput` (optional, defaults to `any`): The specific output type for the `visitFilter` method.
 
 - **Abstract Methods (to be implemented by child classes):**
 
-  - `visitRoot(...)`
-  - `visitInnerJoin(...)`
-  - `visitLeftJoin(...)`
-  - `visitOuterJoin(...)`
-  - `visitFilter(...)`
-  - `visitAndGroup(...)`
-  - `visitOrGroup(...)`
-
-  These methods receive the specific `Criteria` component (e.g., `RootCriteria`, `Filter`), the current alias or join parameters, and the `TranslationContext`. They should return the `TranslationOutput` or `TFilterVisitorOutput` as appropriate.
+  - **`translate(criteria: RootCriteria<...>, source: TranslationContext): TranslationOutput`**: The main public entry point to start the translation process.
+  - `visitRoot(...): void`: Visits the root node of the Criteria tree to initialize the translation.
+  - `visitInnerJoin(...): void`: Visits an Inner Join node to apply its logic.
+  - `visitLeftJoin(...): void`: Visits a Left Join node to apply its logic.
+  - `visitOuterJoin(...): void`: Visits an Outer Join node to apply its logic.
+  - `visitFilter(...): TFilterVisitorOutput`: Visits a single Filter node and returns an intermediate representation of the condition.
+  - `visitAndGroup(...): void`: Visits a group of filters joined by a logical AND.
+  - `visitOrGroup(...): void`: Visits a group of filters joined by a logical OR.
 
-Back to Index
+[Back to Index](#index)
 
 ---
 
@@ -317,27 +288,27 @@ Enumeration defining the available comparison operators for filters.
   - `NOT_IN` (`NOT IN`): The value is not within a set of values.
   - `IS_NULL` (`IS NULL`): The value is NULL.
   - `IS_NOT_NULL` (`IS NOT NULL`): The value is not NULL.
-  - `CONTAINS` (`CONTAINS`): For substring search (often case-insensitive, depends on the DB).
+  - `CONTAINS` (`CONTAINS`): For substring search.
   - `STARTS_WITH` (`STARTS_WITH`): Starts with a specific substring.
   - `ENDS_WITH` (`ENDS_WITH`): Ends with a specific substring.
   - `NOT_CONTAINS` (`NOT_CONTAINS`): Does not contain a specific substring.
   - `SET_CONTAINS`: For SET-type fields or simple arrays, checks if the set contains a value.
-  - `SET_NOT_CONTAINS`: For SET-type fields or simple arrays, checks if the set does NOT contain a value.
-  - `SET_CONTAINS_ANY` (`SET_CONTAINS_ANY`): For SET-type fields or simple arrays, checks if the set contains AT LEAST ONE of the specified values. Expects an array of values.
-  - `SET_CONTAINS_ALL` (`SET_CONTAINS_ALL`): For SET-type fields or simple arrays, checks if the set contains ALL of the specified values. Expects an array of values.
-  - `BETWEEN` (`BETWEEN`): Checks if a value is within a specified range (inclusive). Expects an array or tuple of two values: `[min, max]`.
-  - `NOT_BETWEEN` (`NOT_BETWEEN`): Checks if a value is outside a specified range (inclusive). Expects an array or tuple of two values: `[min, max]`.
-  - `MATCHES_REGEX` (`MATCHES_REGEX`): Checks if a string value matches a regular expression pattern. The specific regex syntax may depend on the database. Expects a string representing the regular expression.
-  - `ILIKE` (`ILIKE`): Checks if a string value matches a pattern (case-insensitive). Expects a string for the pattern.
-  - `NOT_ILIKE` (`NOT_ILIKE`): Checks if a string value does not match a pattern (case-insensitive). Expects a string for the pattern.
-  - `JSON_CONTAINS`: For JSON fields, checks if the JSON contains a specific structure or value at a path.
-  - `JSON_NOT_CONTAINS`: For JSON fields, checks if the JSON does NOT contain a specific structure or value.
-  - `ARRAY_CONTAINS_ELEMENT`: For Array fields (native or JSON), checks if the array contains an element.
-  - `ARRAY_CONTAINS_ALL_ELEMENTS`: For Array fields, checks if the array contains all elements from a given array.
-  - `ARRAY_CONTAINS_ANY_ELEMENT`: For Array fields, checks if the array contains any of the elements from a given array.
-  - `ARRAY_EQUALS`: For Array fields, checks if the array is exactly equal to a given array (order and elements).
-
-Back to Index
+  - `SET_NOT_CONTAINS`: The inverse of `SET_CONTAINS`.
+  - `SET_CONTAINS_ANY`: Checks if the set contains AT LEAST ONE of the specified values.
+  - `SET_CONTAINS_ALL`: Checks if the set contains ALL of the specified values.
+  - `BETWEEN` (`BETWEEN`): Checks if a value is within a specified range (inclusive).
+  - `NOT_BETWEEN` (`NOT_BETWEEN`): Checks if a value is outside a specified range.
+  - `MATCHES_REGEX` (`MATCHES_REGEX`): Checks if a string value matches a regular expression.
+  - `ILIKE` (`ILIKE`): Case-insensitive version of `LIKE`.
+  - `NOT_ILIKE` (`NOT_ILIKE`): Case-insensitive version of `NOT_ILIKE`.
+  - `JSON_CONTAINS`: For JSON fields, checks if the JSON contains a specific structure or value.
+  - `JSON_NOT_CONTAINS`: The inverse of `JSON_CONTAINS`.
+  - `ARRAY_CONTAINS_ELEMENT`: For Array fields, checks if the array contains an element.
+  - `ARRAY_CONTAINS_ALL_ELEMENTS`: Checks if the array contains all elements from a given array.
+  - `ARRAY_CONTAINS_ANY_ELEMENT`: Checks if the array contains any of the elements from a given array.
+  - `ARRAY_EQUALS`: Checks if the array is exactly equal to a given array.
+
+[Back to Index](#index)
 
 ### `LogicalOperator`
 
@@ -347,7 +318,7 @@ Enumeration defining the logical operators for combining filter groups.
   - `AND` (`AND`): All conditions must be met.
   - `OR` (`OR`): At least one condition must be met.
 
-Back to Index
+[Back to Index](#index)
 
 ### `OrderDirection`
 
@@ -357,7 +328,7 @@ Enumeration defining the direction of ordering.
   - `ASC` (`ASC`): Ascending order.
   - `DESC` (`DESC`): Descending order.
 
-Back to Index
+[Back to Index](#index)
 
 ---
 
@@ -369,40 +340,40 @@ Interface defining the structure of an entity schema. Schemas are crucial for ty
 
 - **Properties:**
   - `source_name: string`: The actual name of the table or collection in the database.
-  - `alias: readonly string[]`: An array of possible aliases for this entity. The first is usually the primary one.
+  - `alias: string`: A single, canonical alias for this entity.
   - `fields: readonly string[]`: An array of the names of queryable fields for this entity.
+  - `identifier_field: string`: **(Mandatory)** The name of the field that uniquely identifies an entity of this schema. Must be one of the names in `fields`.
   - `joins: readonly SchemaJoins<string>[]` (optional): An array defining possible join relationships with other schemas.
-    - `SchemaJoins<AliasUnion extends string>`:
-      - `alias: AliasUnion`: The alias of the joined entity (must match an alias in the joined entity's schema).
-      - `relation_type: JoinRelationType`: The type of relationship (e.g., `'one_to_many'`).
-      - `metadata?: { [key: string]: any }`: Optional metadata associated with the specific join configuration.
-  - `metadata?: { [key: string]: any }`: Optional metadata associated with the entire schema definition. Can be used by translators for custom logic or hints.
+  - `metadata?: { [key: string]: any }`: Optional metadata associated with the entire schema definition.
 
-Back to Index
+[Back to Index](#index)
 
 ### `GetTypedCriteriaSchema`
 
 Helper function for defining schemas. It preserves the literal types of `fields` and `alias`, improving autocompletion and type validation.
 
-- **Function:** `GetTypedCriteriaSchema<T extends MinimalCriteriaSchema>(schema: T): T`
-  - **Parameters:**
-    - `schema`: An object conforming to the `MinimalCriteriaSchema` structure (a looser version of `CriteriaSchema` for input).
-  - **Returns:** The same input `schema` object, but with its literal types preserved.
-  - **Example:**
+- **Function:** `GetTypedCriteriaSchema<T extends CriteriaSchema>(schema: T): T`
+- **Example:**
 
 ```typescript
 import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
 
-const MyUserSchema = GetTypedCriteriaSchema({
-  source_name: 'user_table',
-  alias: ['user', 'u'],
+export const UserSchema = GetTypedCriteriaSchema({
+  source_name: 'users',
+  alias: 'u',
   fields: ['id', 'name', 'email'],
-  joins: [{ alias: 'orders', relation_type: 'one_to_many' }],
+  identifier_field: 'id',
+  joins: [
+    {
+      alias: 'posts',
+      target_source_name: 'posts',
+      relation_type: 'one_to_many',
+    },
+  ],
 });
-// MyUserSchema now has literal types for alias and fields.
 ```
 
-Back to Index
+[Back to Index](#index)
 
 ### `FieldOfSchema`
 
@@ -410,15 +381,7 @@ Helper type that extracts the valid field names from a given `CriteriaSchema`.
 
 - **Type:** `FieldOfSchema<T extends CriteriaSchema> = T['fields'][number];`
 
-Back to Index
-
-### `SelectedAliasOf`
-
-Helper type that extracts the valid aliases from a given `CriteriaSchema`.
-
-- **Type:** `SelectedAliasOf<T extends CriteriaSchema> = T['alias'][number];`
-
-Back to Index
+[Back to Index](#index)
 
 ### `JoinRelationType`
 
@@ -426,225 +389,173 @@ String union type representing the possible types of join relationships.
 
 - **Possible Values:** `'one_to_one' | 'one_to_many' | 'many_to_one' | 'many_to_many'`
 
-Back to Index
+[Back to Index](#index)
 
 ### `SchemaJoins`
 
 Interface defining the structure of a join configuration within the `joins` property of a `CriteriaSchema`.
 
 - **Properties:**
-  - `alias: AliasUnion`: The alias of the entity being joined to.
+  - `alias: string`: The alias for this specific join relation (e.g., `'posts'`, `'author'`).
   - `relation_type: JoinRelationType`: The type of relationship.
+  - `target_source_name: string`: The `source_name` of the schema being joined to.
   - `metadata?: { [key: string]: any }`: Optional metadata associated with this specific join configuration.
 
-Back to Index
+[Back to Index](#index)
 
 ### `FilterPrimitive`
 
 Interface defining the structure for an individual filter condition before it's instantiated as a `Filter` object.
 
-- **Generics:**
-  - `Field extends FieldOfSchema<CriteriaSchema>`: The type of valid fields.
-  - `Operator extends FilterOperator`: The specific filter operator.
 - **Properties:**
-  - `field: Field`: The field to apply the filter to.
-  - `operator: Operator`: The filter operator.
+  - `field: FieldOfSchema<...>`: The field to apply the filter to.
+  - `operator: FilterOperator`: The filter operator.
   - `value: FilterValue<Operator>`: The filter value, whose type depends on the `Operator`.
 
-Back to Index
+[Back to Index](#index)
 
 ### `FilterGroupPrimitive`
 
 Interface defining the structure for a group of filters before it's instantiated as a `FilterGroup` object.
 
-- **Generics:**
-  - `Field extends string`: The type of valid fields.
 - **Properties:**
   - `logicalOperator: LogicalOperator`: The logical operator (`AND` or `OR`) joining the `items`.
-  - `items: ReadonlyArray<FilterPrimitive<Field, FilterOperator> | FilterGroupPrimitive<Field>>`: Array of filters or nested filter groups.
+  - `items: ReadonlyArray<FilterPrimitive<...> | FilterGroupPrimitive<...>>`: Array of filters or nested filter groups.
 
-Back to Index
+[Back to Index](#index)
 
 ### `FilterValue`
 
 Generic type representing the value associated with a filter, strongly typed according to the `FilterOperator` used.
 
-- **Definition (conceptual):**
-  - If `Operator` is `LIKE`, `CONTAINS`, etc. => `string`
-  - If `Operator` is `EQUALS`, `GREATER_THAN`, etc. => `PrimitiveFilterValue` (string | number | boolean | Date | null)
-  - If `Operator` is `IN`, `NOT_IN` => `Array<Exclude<PrimitiveFilterValue, null | undefined>>`
-  - If `Operator` is `SET_CONTAINS_ANY`, `SET_CONTAINS_ALL` => `Array<Exclude<PrimitiveFilterValue, null | undefined>>`
-  - If `Operator` is `BETWEEN`, `NOT_BETWEEN` => `[Exclude<PrimitiveFilterValue, null | undefined>, Exclude<PrimitiveFilterValue, null | undefined>]`
-  - If `Operator` is `MATCHES_REGEX`, `ILIKE`, `NOT_ILIKE` => `string`
-  - If `Operator` is `ARRAY_CONTAINS_ELEMENT` => `PrimitiveFilterValue | { [jsonPath: string]: PrimitiveFilterValue }`
-  - If `Operator` is `ARRAY_CONTAINS_ALL_ELEMENTS`, etc. => `Array<...> | { [jsonPath: string]: Array<...> }`
-  - If `Operator` is `IS_NULL`, `IS_NOT_NULL` => `null | undefined`
-  - If `Operator` is `JSON_CONTAINS`, etc. => `{ [jsonPath: string]: PrimitiveFilterValue | Array<any> | Record<string, any> }`
-
-Back to Index
+[Back to Index](#index)
 
 ### `OrderByPrimitive`
 
 Type defining the structure for an ordering rule before it's instantiated as an `Order` object.
 
-- **Generics:**
-  - `T extends string`: The type of valid fields.
 - **Properties:**
   - `direction: OrderDirection`: The ordering direction.
-  - `field: T`: The field to order by.
+  - `field: string`: The field to order by.
 
-Back to Index
+[Back to Index](#index)
 
 ### `PivotJoinInput`
 
 Type representing the input parameters for a `many-to-many` join via a pivot table, as provided by the user to the `.join()` method.
 
-- **Generics:**
-  - `ParentSchema extends CriteriaSchema`
-  - `JoinSchema extends CriteriaSchema`
 - **Properties:**
   - `pivot_source_name: string`: Name of the pivot table.
   - `parent_field: { pivot_field: string; reference: FieldOfSchema<ParentSchema> }`: Configuration of the parent entity's field referencing the pivot table.
   - `join_field: { pivot_field: string; reference: FieldOfSchema<JoinSchema> }`: Configuration of the joined entity's field referencing the pivot table.
 
-Back to Index
+[Back to Index](#index)
 
 ### `SimpleJoinInput`
 
 Type representing the input parameters for a simple join (one-to-one, one-to-many, many-to-one), as provided by the user to the `.join()` method.
 
-- **Generics:**
-  - `ParentSchema extends CriteriaSchema`
-  - `JoinSchema extends CriteriaSchema`
 - **Properties:**
   - `parent_field: FieldOfSchema<ParentSchema>`: Field in the parent entity for the join condition.
   - `join_field: FieldOfSchema<JoinSchema>`: Field in the joined entity for the join condition.
 
-Back to Index
+[Back to Index](#index)
 
 ### `ICriteriaBase`
 
 Base interface defining common functionality for all criteria types.
 
-- **Generics:**
-  - `TSchema extends CriteriaSchema`
-  - `CurrentAlias extends SelectedAliasOf<TSchema>`
-- **Main Methods (see `Criteria` for details):**
-  - `resetSelect()`
-  - `setSelect(...)`
-  - `setTake(...)`
-  - `setSkip(...)`
-  - `orderBy(...)`
-  - `where(...)`
-  - `andWhere(...)`
-  - `orWhere(...)`
-  - `join(...)`
-  - `setCursor(...)`
-- **Properties (getters):** `select`, `selectAll`, `take`, `skip`, `orders`, `joins`, `rootFilterGroup`, `sourceName`, `alias`, `cursor`.
-
-Back to Index
+[Back to Index](#index)
 
 ### `ICriteriaVisitor`
 
 Interface for the Visitor pattern, implemented by `CriteriaTranslator`. Defines the `visit...` methods for each type of `Criteria` node.
 
-- **Generics:**
-  - `TranslationContext`
-  - `TranslationOutput`
-  - `TFilterVisitorOutput`
-- **Methods (see `CriteriaTranslator` for details):**
-  - `visitRoot(...)`
-  - `visitInnerJoin(...)`
-  - `visitLeftJoin(...)`
-  - `visitOuterJoin(...)`
-  - `visitFilter(...)`
-  - `visitAndGroup(...)`
-  - `visitOrGroup(...)`
-
-Back to Index
+- **Methods (return `void` unless specified):**
+  - `visitRoot(...)`: Visits the root node of the Criteria tree to initialize the translation.
+  - `visitInnerJoin(...)`: Visits an Inner Join node to apply its logic.
+  - `visitLeftJoin(...)`: Visits a Left Join node to apply its logic.
+  - `visitOuterJoin(...)`: Visits an Outer Join node to apply its logic.
+  - `visitFilter(...): TFilterVisitorOutput`: Visits a single Filter node and returns an intermediate representation of the condition.
+  - `visitAndGroup(...)`: Visits a group of filters joined by a logical AND.
+  - `visitOrGroup(...)`: Visits a group of filters joined by a logical OR.
+
+[Back to Index](#index)
 
 ### `IFilterExpression`
 
 Interface implemented by `Filter` and `FilterGroup`.
 
 - **Methods:**
-  - `toPrimitive(): FilterPrimitive<...> | FilterGroupPrimitive<...>`: Returns the primitive representation of the filter expression.
+  - `toPrimitive()`: Returns the primitive representation of the filter expression.
 
-Back to Index
+[Back to Index](#index)
 
 ### `StoredJoinDetails`
 
 Interface defining the structure for storing the details of a configured join internally.
 
-- **Generics:**
-  - `ParentSchema extends CriteriaSchema`
 - **Properties:**
   - `parameters: PivotJoin<...> | SimpleJoin<...>`: The resolved join parameters.
   - `criteria: AnyJoinCriteria<...>`: The `Criteria` instance of the joined entity.
 
-Back to Index
+[Back to Index](#index)
 
 ### `AnyJoinCriteria`
 
 Union type representing any type of join `Criteria` (`InnerJoinCriteria`, `LeftJoinCriteria`, `OuterJoinCriteria`).
 
-Back to Index
+[Back to Index](#index)
 
 ### `JoinCriteriaParameterType`
 
-Helper type that determines the type of the `Criteria` object to be passed to the `.join()` method, validating that the joined entity's alias is configured in the parent schema.
+Helper type that determines the type of the `Criteria` object to be passed to the `.join()` method, validating that the joined entity's `source_name` is configured in the parent schema.
 
-Back to Index
+[Back to Index](#index)
 
 ### `JoinParameterType`
 
-Helper type that determines the expected shape of the join parameters object for the `.join()` method, based on the `join_relation_type` defined in the parent schema.
+Helper type that determines the expected shape of the join parameters object for the `.join()` method, based on the `relation_type` defined in the parent schema.
 
-Back to Index
+[Back to Index](#index)
 
 ### `SpecificMatchingJoinConfig`
 
-Helper type that extracts the specific join configuration from a parent schema that matches a given joined entity alias.
+Helper type that extracts the specific join configuration from a parent schema that matches a given `target_source_name`.
 
-Back to Index
+[Back to Index](#index)
 
 ### `PivotJoin`
 
 Type representing the fully resolved parameters for a `many-to-many` join via a pivot table, used internally.
 
-- **Generics:**
-  - `ParentSchema extends CriteriaSchema`
-  - `JoinSchema extends CriteriaSchema`
-  - `TRelationType extends JoinRelationType`
 - **Properties:**
-  - `relation_type: TRelationType`: The type of relationship from the parent to the joined entity.
-  - `parent_source_name: ParentSchema['source_name']`
-  - `parent_alias: ParentSchema['alias'][number]`
+  - `relation_type: 'many_to_many'`
+  - `parent_source_name: string`
+  - `parent_alias: string`
+  - `join_alias: string`
+  - `parent_identifier: string`
   - `pivot_source_name: string`
-  - `parent_field: { pivot_field: string; reference: FieldOfSchema<ParentSchema> }`
-  - `join_field: { pivot_field: string; reference: FieldOfSchema<JoinSchema> }`
-  - `parent_schema_metadata: { [key: string]: any }`: Optional metadata from the parent schema.
-  - `join_metadata: { [key: string]: any }`: Optional metadata from the specific join configuration.
+  - `parent_field: { pivot_field: string; reference: string }`
+  - `join_field: { pivot_field: string; reference: string }`
+  - `parent_schema_metadata: { [key: string]: any }`
+  - `join_metadata: { [key: string]: any }`
 
-Back to Index
+[Back to Index](#index)
 
 ### `SimpleJoin`
 
 Type representing the fully resolved parameters for a simple join (one-to-one, one-to-many, many-to-one), used internally.
 
-- **Generics:**
-  - `ParentSchema extends CriteriaSchema`
-  - `JoinSchema extends CriteriaSchema`
-  - `TRelationType extends JoinRelationType`
 - **Properties:**
-  - `relation_type: TRelationType`: The type of relationship from the parent to the joined entity.
-  - `parent_source_name: ParentSchema['source_name']`
-  - `parent_alias: ParentSchema['alias'][number]`
-  - `parent_field: FieldOfSchema<ParentSchema>`
-  - `join_field: FieldOfSchema<JoinSchema>`
-  - `parent_schema_metadata: { [key: string]: any }`: Optional metadata from the parent schema.
-  - `join_metadata: { [key: string]: any }`: Optional metadata from the specific join configuration.
-
-Back to Index
-
----
+  - `relation_type: 'one_to_one' | 'one_to_many' | 'many_to_one'`
+  - `parent_source_name: string`
+  - `parent_alias: string`
+  - `join_alias: string`
+  - `parent_identifier: string`
+  - `parent_field: string`
+  - `join_field: string`
+  - `parent_schema_metadata: { [key: string]: any }`
+  - `join_metadata: { [key: string]: any }`
+
+[Back to Index](#index)
diff --git a/src/docs/api-reference/es.md b/src/docs/api-reference/es.md
index 87cf6b5..1d17bac 100644
--- a/src/docs/api-reference/es.md
+++ b/src/docs/api-reference/es.md
@@ -25,7 +25,6 @@ Esta seccin proporciona una referencia detallada de las clases, interfaces, ti
   - [`CriteriaSchema`](#criteriaschema)
   - [`GetTypedCriteriaSchema`](#gettypedcriteriaschema)
   - [`FieldOfSchema`](#fieldofschema)
-  - [`SelectedAliasOf`](#selectedaliasof)
   - [`JoinRelationType`](#joinrelationtype)
   - [`SchemaJoins`](#schemajoins)
   - [`FilterPrimitive`](#filterprimitive)
@@ -51,47 +50,45 @@ Esta seccin proporciona una referencia detallada de las clases, interfaces, ti
 
 ### `CriteriaFactory`
 
-Proporciona mtodos estticos para crear instancias de diferentes tipos de `Criteria`. Simplifica la creacin de objetos `Criteria` y asegura que se instancien con la configuracin correcta de esquema y alias.
+Proporciona mtodos estticos para crear instancias de diferentes tipos de `Criteria`. Simplifica la creacin de objetos `Criteria` y asegura que se instancien con el esquema correcto. El alias ahora se infiere directamente del esquema.
 
 **Mtodos Estticos:**
 
-- **`GetCriteria<CSchema extends CriteriaSchema, Alias extends SelectedAliasOf<CSchema>>(schema: CSchema, alias: Alias): RootCriteria<CSchema, Alias>`**
+- **`GetCriteria<CSchema extends CriteriaSchema>(schema: CSchema): RootCriteria<CSchema>`**
   - Crea una instancia de `RootCriteria`. Es el punto de partida para construir una consulta principal.
   - **Parmetros:**
     - `schema`: Una instancia de `CriteriaSchema` que define la estructura de la entidad raz.
-    - `alias`: Un alias vlido (string) para la entidad raz, definido dentro del `schema`.
   - **Retorna:** Una instancia de `RootCriteria`.
   - **Ejemplo:**
 
 ```typescript
 import { CriteriaFactory, UserSchema } from '@nulledexp/translatable-criteria';
-const userCriteria = CriteriaFactory.GetCriteria(UserSchema, 'users');
+const userCriteria = CriteriaFactory.GetCriteria(UserSchema);
 ```
 
-- **`GetInnerJoinCriteria<CSchema extends CriteriaSchema, Alias extends SelectedAliasOf<CSchema>>(schema: CSchema, alias: Alias): InnerJoinCriteria<CSchema, Alias>`**
+- **`GetInnerJoinCriteria<CSchema extends CriteriaSchema>(schema: CSchema): InnerJoinCriteria<CSchema>`**
   - Crea una instancia de `InnerJoinCriteria`. Usado para definir un `INNER JOIN` en una consulta.
   - **Parmetros:**
     - `schema`: Una instancia de `CriteriaSchema` para la entidad a unir.
-    - `alias`: Un alias vlido para la entidad unida, definido en su `schema`.
   - **Retorna:** Una instancia de `InnerJoinCriteria`.
   - **Ejemplo:**
 
 ```typescript
 import { CriteriaFactory, PostSchema } from '@nulledexp/translatable-criteria';
-const postJoin = CriteriaFactory.GetInnerJoinCriteria(PostSchema, 'posts');
-// userCriteria.join(postJoin, { parent_field: 'id', join_field: 'user_id' });
+const postJoin = CriteriaFactory.GetInnerJoinCriteria(PostSchema);
+// userCriteria.join('posts', postJoin, { parent_field: 'id', join_field: 'userId' });
 ```
 
-- **`GetLeftJoinCriteria<CSchema extends CriteriaSchema, Alias extends SelectedAliasOf<CSchema>>(schema: CSchema, alias: Alias): LeftJoinCriteria<CSchema, Alias>`**
+- **`GetLeftJoinCriteria<CSchema extends CriteriaSchema>(schema: CSchema): LeftJoinCriteria<CSchema>`**
 
   - Crea una instancia de `LeftJoinCriteria`. Usado para definir un `LEFT JOIN`.
   - **Retorna:** Una instancia de `LeftJoinCriteria`.
 
-- **`GetOuterJoinCriteria<CSchema extends CriteriaSchema, Alias extends SelectedAliasOf<CSchema>>(schema: CSchema, alias: Alias): OuterJoinCriteria<CSchema, Alias>`**
+- **`GetOuterJoinCriteria<CSchema extends CriteriaSchema>(schema: CSchema): OuterJoinCriteria<CSchema>`**
   - Crea una instancia de `OuterJoinCriteria`. Usado para definir un `FULL OUTER JOIN`.
   - **Retorna:** Una instancia de `OuterJoinCriteria`.
 
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ### `RootCriteria`
 
@@ -101,9 +98,9 @@ Se instancia a travs de `CriteriaFactory.GetCriteria()`.
 **Mtodos Principales (adems de los heredados de `Criteria`):**
 
 - Implementa `accept` para el patrn Visitor, llamando a `visitor.visitRoot()`.
-- `resetCriteria()`: Devuelve una nueva instancia de `RootCriteria` con la misma configuracin de esquema y alias, pero con todos los dems estados (filtros, joins, etc.) reiniciados.
+- `resetCriteria()`: Devuelve una nueva instancia de `RootCriteria` con la misma configuracin de esquema, pero con todos los dems estados (filtros, joins, etc.) reiniciados.
 
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ### `InnerJoinCriteria`
 
@@ -115,7 +112,7 @@ Se instancia a travs de `CriteriaFactory.GetInnerJoinCriteria()`.
 - Implementa `accept` para el patrn Visitor, llamando a `visitor.visitInnerJoin()`.
 - `resetCriteria()`: Devuelve una nueva instancia de `InnerJoinCriteria`.
 
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ### `LeftJoinCriteria`
 
@@ -127,7 +124,7 @@ Se instancia a travs de `CriteriaFactory.GetLeftJoinCriteria()`.
 - Implementa `accept` para el patrn Visitor, llamando a `visitor.visitLeftJoin()`.
 - `resetCriteria()`: Devuelve una nueva instancia de `LeftJoinCriteria`.
 
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ### `OuterJoinCriteria`
 
@@ -139,7 +136,7 @@ Se instancia a travs de `CriteriaFactory.GetOuterJoinCriteria()`.
 - Implementa `accept` para el patrn Visitor, llamando a `visitor.visitOuterJoin()`.
 - `resetCriteria()`: Devuelve una nueva instancia de `OuterJoinCriteria`.
 
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ### `Criteria` (Clase Abstracta Base)
 
@@ -155,8 +152,10 @@ Clase base abstracta para todos los tipos de criterios (`RootCriteria`, `InnerJo
 - `joins: ReadonlyArray<StoredJoinDetails<TSchema>>`: Configuraciones de join.
 - `rootFilterGroup: FilterGroup`: Grupo de filtros raz.
 - `sourceName: TSchema['source_name']`: Nombre de la fuente del esquema.
-- `alias: CurrentAlias`: Alias actual del criteria.
+- `alias: TSchema['alias']`: El alias cannico del esquema.
 - `cursor: Cursor<...> | undefined`: Configuracin del cursor para paginacin.
+- `identifierField: FieldOfSchema<TSchema>`: El nombre del campo identificador del esquema.
+- `schemaMetadata: TSchema['metadata']`: El objeto de metadatos del esquema.
 
 **Mtodos Principales (encadenables):**
 
@@ -168,10 +167,10 @@ Clase base abstracta para todos los tipos de criterios (`RootCriteria`, `InnerJo
 - **`where<Operator extends FilterOperator>(filterPrimitive: FilterPrimitive<...>): this`**: Inicia el grupo de filtros con una condicin.
 - **`andWhere<Operator extends FilterOperator>(filterPrimitive: FilterPrimitive<...>): this`**: Aade una condicin AND al grupo de filtros actual.
 - **`orWhere<Operator extends FilterOperator>(filterPrimitive: FilterPrimitive<...>): this`**: Aade una condicin OR, creando un nuevo grupo si es necesario.
-- **`join<...>(criteriaToJoin: ..., joinParameter: ...): this`**: Aade una condicin de join.
+- **`join(joinAlias: string, criteriaToJoin: JoinCriteria, joinParameter: object): this`**: Aade una condicin de join.
 - **`setCursor(cursorFilters: [...], operator: ..., order: ...): this`**: Configura la paginacin basada en cursor.
 
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ### `Filter`
 
@@ -190,19 +189,14 @@ Representa una condicin de filtro individual. Se instancia internamente al usa
 
 **Mtodos:**
 
-- `accept(visitor: ICriteriaVisitor<...>, currentAlias: string): TFilterVisitorOutput`: Para el patrn Visitor, llama a `visitor.visitFilter()`.
+- `accept(visitor: ICriteriaVisitor<...>, currentAlias: string, context: ...): TFilterVisitorOutput`: Para el patrn Visitor, llama a `visitor.visitFilter()`.
 - `toPrimitive(): FilterPrimitive<T, Operator>`: Devuelve la representacin primitiva del filtro.
 
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ### `FilterGroup`
 
-Representa un grupo de filtros (`Filter` o anidados `FilterGroup`) conectados por un `LogicalOperator` (AND/OR). Se instancia y gestiona internamente por `CriteriaFilterManager` al usar los mtodos `where`, `andWhere`, `orWhere`.
-
-**Constructor:**
-
-- `constructor(filterGroupPrimitive: FilterGroupPrimitive<T>)`
-  - Normaliza el grupo de filtros primitivo (ej. aplanando grupos AND anidados).
+Representa un grupo de filtros (`Filter` o anidados `FilterGroup`) conectados por un `LogicalOperator` (AND/OR). Se instancia y gestiona internamente por `CriteriaFilterManager`.
 
 **Propiedades (getters):**
 
@@ -211,20 +205,15 @@ Representa un grupo de filtros (`Filter` o anidados `FilterGroup`) conectados po
 
 **Mtodos:**
 
-- `accept(visitor: ICriteriaVisitor<...>, currentAlias: string, context: ...): TranslationOutput`: Para el patrn Visitor, llama a `visitor.visitAndGroup()` o `visitor.visitOrGroup()` segn el `logicalOperator`.
+- `accept(visitor: ICriteriaVisitor<...>, currentAlias: string, context: ...): void`: Para el patrn Visitor, llama a `visitor.visitAndGroup()` o `visitor.visitOrGroup()` segn el `logicalOperator`.
 - `toPrimitive(): FilterGroupPrimitive<T>`: Devuelve la representacin primitiva del grupo de filtros.
 
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ### `Order`
 
 Representa una regla de ordenamiento. Se instancia internamente al usar el mtodo `orderBy()` de un `Criteria`.
 
-**Constructor:**
-
-- `constructor(direction: OrderDirection, field: T)`
-  - Asigna un `sequenceId` nico globalmente para mantener un orden estable.
-
 **Propiedades (getters):**
 
 - `sequenceId: number`: ID de secuencia para ordenamiento estable.
@@ -235,29 +224,19 @@ Representa una regla de ordenamiento. Se instancia internamente al usar el mto
 
 - `toPrimitive(): OrderByPrimitive<T>`: Devuelve la representacin primitiva de la regla de orden.
 
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ### `Cursor`
 
 Representa la configuracin para la paginacin basada en cursor. Se instancia internamente al usar el mtodo `setCursor()` de un `Criteria`.
 
-**Constructor:**
-
-- `constructor(filterPrimitive: readonly [Omit<FilterPrimitive<...>, 'operator'>] | readonly [Omit<FilterPrimitive<...>, 'operator'>, Omit<FilterPrimitive<...>, 'operator'>], operator: FilterOperator.GREATER_THAN | FilterOperator.LESS_THAN, order: OrderDirection)`
-  - Valida que los campos y valores del cursor estn definidos y sean vlidos.
-  - Soporta 1 o 2 `FilterPrimitive` para cursores simples o compuestos.
-  - @throws {Error} Si algn campo del cursor no est definido.
-  - @throws {Error} Si algn valor del cursor es undefined (se permite null).
-  - @throws {Error} Si se proporcionan dos campos de cursor y son idnticos.
-  - @throws {Error} Si no se proporcionan primitivas de filtro.
-
 **Propiedades (readonly):**
 
-- `filters: [Filter<TFields, Operator>] | [Filter<TFields, Operator>, Filter<TFields, Operator>]`: Los filtros que definen el cursor.
+- `filters: [Filter<...>] | [Filter<...>, Filter<...>]`: Los filtros que definen el cursor.
 - `order: OrderDirection`: La direccin de ordenamiento del cursor.
 - `operator: FilterOperator.GREATER_THAN | FilterOperator.LESS_THAN`: El operador del cursor.
 
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ---
 
@@ -269,32 +248,22 @@ Clase abstracta que sirve como base para crear traductores especficos para dif
 
 - **Genricos:**
 
-  - `TranslationContext`: El tipo del objeto de contexto que se pasa y se modifica durante la traduccin (ej. un `SelectQueryBuilder` de TypeORM).
+  - `TranslationContext`: El tipo del objeto de contexto mutable (ej. un constructor de consultas) que se pasa durante el recorrido.
   - `TranslationOutput` (opcional, por defecto es `TranslationContext`): El tipo del resultado final de la traduccin.
-  - `TFilterVisitorOutput` (opcional, por defecto es `any`): El tipo de salida especfico para los mtodos `visitFilter`, `visitAndGroup` y `visitOrGroup`.
-
-- **Mtodo Principal (para el usuario del traductor):**
-
-  - **`translate(criteria: RootCriteria<...>, source: TranslationContext): TranslationOutput`**
-    - Mtodo pblico principal para iniciar el proceso de traduccin.
-    - **Parmetros:**
-      - `criteria`: La instancia de `RootCriteria` a traducir.
-      - `source`: El contexto inicial para la traduccin (ej. una instancia de `SelectQueryBuilder`).
-    - **Retorna:** El `TranslationOutput` (ej. el `SelectQueryBuilder` modificado o una cadena SQL).
+  - `TFilterVisitorOutput` (opcional, por defecto es `any`): El tipo de salida especfico para el mtodo `visitFilter`.
 
 - **Mtodos Abstractos (a implementar por las clases hijas):**
 
-  - `visitRoot(...)`
-  - `visitInnerJoin(...)`
-  - `visitLeftJoin(...)`
-  - `visitOuterJoin(...)`
-  - `visitFilter(...)`
-  - `visitAndGroup(...)`
-  - `visitOrGroup(...)`
-
-  Estos mtodos reciben el componente especfico del `Criteria` (ej. `RootCriteria`, `Filter`), el alias actual o parmetros de join, y el `TranslationContext`. Deben devolver el `TranslationOutput` o el `TFilterVisitorOutput` segn corresponda.
+  - **`translate(criteria: RootCriteria<...>, source: TranslationContext): TranslationOutput`**: El punto de entrada pblico principal para iniciar el proceso de traduccin.
+  - `visitRoot(...): void`: Visita el nodo raz del rbol de Criteria para inicializar la traduccin.
+  - `visitInnerJoin(...): void`: Visita un nodo de Inner Join para aplicar su lgica.
+  - `visitLeftJoin(...): void`: Visita un nodo de Left Join para aplicar su lgica.
+  - `visitOuterJoin(...): void`: Visita un nodo de Outer Join para aplicar su lgica.
+  - `visitFilter(...): TFilterVisitorOutput`: Visita un nodo de Filtro individual y devuelve una representacin intermedia de la condicin.
+  - `visitAndGroup(...): void`: Visita un grupo de filtros unidos por un AND lgico.
+  - `visitOrGroup(...): void`: Visita un grupo de filtros unidos por un OR lgico.
 
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ---
 
@@ -304,40 +273,40 @@ Volver al ndice
 
 Enumeracin que define los operadores de comparacin disponibles para los filtros.
 
-- **Valores:**
-  - `EQUALS` (`=`): Igual a.
-  - `NOT_EQUALS` (`!=`): No igual a.
-  - `GREATER_THAN` (`>`): Mayor que.
-  - `GREATER_THAN_OR_EQUALS` (`>=`): Mayor o igual que.
-  - `LESS_THAN` (`<`): Menor que.
-  - `LESS_THAN_OR_EQUALS` (`<=`): Menor o igual que.
-  - `LIKE` (`LIKE`): Coincide con un patrn (sensible a maysculas/minsculas segn la BD).
-  - `NOT_LIKE` (`NOT LIKE`): No coincide con un patrn.
-  - `IN` (`IN`): El valor est dentro de un conjunto de valores.
-  - `NOT_IN` (`NOT IN`): El valor no est dentro de un conjunto de valores.
-  - `IS_NULL` (`IS NULL`): El valor es NULL.
-  - `IS_NOT_NULL` (`IS NOT NULL`): El valor no es NULL.
-  - `CONTAINS` (`CONTAINS`): Para bsqueda de subcadenas (a menudo insensible a maysculas/minsculas segn la BD).
-  - `STARTS_WITH` (`STARTS_WITH`): Comienza con una subcadena especfica.
-  - `ENDS_WITH` (`ENDS_WITH`): Termina con una subcadena especfica.
-  - `NOT_CONTAINS` (`NOT_CONTAINS`): No contiene una subcadena especfica.
-  - `SET_CONTAINS`: Para campos tipo SET o arrays simples, busca si el conjunto contiene un valor.
-  - `SET_NOT_CONTAINS`: Para campos tipo SET o arrays simples, busca si el conjunto NO contiene un valor.
-  - `SET_CONTAINS_ANY` (`SET_CONTAINS_ANY`): Para campos tipo SET o arrays simples, busca si el conjunto contiene AL MENOS UNO de los valores especificados. Espera un array de valores.
-  - `SET_CONTAINS_ALL` (`SET_CONTAINS_ALL`): Para campos tipo SET o arrays simples, busca si el conjunto contiene TODOS los valores especificados. Espera un array de valores.
-  - `BETWEEN` (`BETWEEN`): Comprueba si un valor est dentro de un rango especificado (inclusivo). Espera un array o tupla de dos valores: `[min, max]`.
-  - `NOT_BETWEEN` (`NOT_BETWEEN`): Comprueba si un valor est fuera de un rango especificado (inclusivo). Espera un array o tupla de dos valores: `[min, max]`.
-  - `MATCHES_REGEX` (`MATCHES_REGEX`): Comprueba si un valor de cadena coincide con un patrn de expresin regular. La sintaxis especfica de regex puede depender de la base de datos. Espera una cadena que represente la expresin regular.
-  - `ILIKE` (`ILIKE`): Comprueba si un valor de cadena coincide con un patrn (insensible a maysculas/minsculas). Espera una cadena para el patrn.
-  - `NOT_ILIKE` (`NOT_ILIKE`): Comprueba si un valor de cadena no coincide con un patrn (insensible a maysculas/minsculas). Espera una cadena para el patrn.
-  - `JSON_CONTAINS`: Para campos JSON, busca si el JSON contiene una estructura o valor especfico en una ruta.
-  - `JSON_NOT_CONTAINS`: Para campos JSON, busca si el JSON NO contiene una estructura o valor especfico.
-  - `ARRAY_CONTAINS_ELEMENT`: Para campos Array (nativo o JSON), busca si el array contiene un elemento.
-  - `ARRAY_CONTAINS_ALL_ELEMENTS`: Para campos Array, busca si el array contiene todos los elementos de un array dado.
-  - `ARRAY_CONTAINS_ANY_ELEMENT`: Para campos Array, busca si el array contiene alguno de los elementos de un array dado.
-  - `ARRAY_EQUALS`: Para campos Array, busca si el array es exactamente igual a un array dado (orden y elementos).
-
-Volver al ndice
+- **Values:**
+  - `EQUALS` (`=`): Equal to.
+  - `NOT_EQUALS` (`!=`): Not equal to.
+  - `GREATER_THAN` (`>`): Greater than.
+  - `GREATER_THAN_OR_EQUALS` (`>=`): Greater than or equal to.
+  - `LESS_THAN` (`<`): Less than.
+  - `LESS_THAN_OR_EQUALS` (`<=`): Less than or equal to.
+  - `LIKE` (`LIKE`): Matches a pattern (case sensitivity depends on the DB).
+  - `NOT_LIKE` (`NOT LIKE`): Does not match a pattern.
+  - `IN` (`IN`): The value is within a set of values.
+  - `NOT_IN` (`NOT IN`): The value is not within a set of values.
+  - `IS_NULL` (`IS NULL`): The value is NULL.
+  - `IS_NOT_NULL` (`IS NOT NULL`): The value is not NULL.
+  - `CONTAINS` (`CONTAINS`): For substring search.
+  - `STARTS_WITH` (`STARTS_WITH`): Starts with a specific substring.
+  - `ENDS_WITH` (`ENDS_WITH`): Ends with a specific substring.
+  - `NOT_CONTAINS` (`NOT_CONTAINS`): Does not contain a specific substring.
+  - `SET_CONTAINS`: For SET-type fields or simple arrays, checks if the set contains a value.
+  - `SET_NOT_CONTAINS`: The inverse of `SET_CONTAINS`.
+  - `SET_CONTAINS_ANY`: Checks if the set contains AT LEAST ONE of the specified values.
+  - `SET_CONTAINS_ALL`: Checks if the set contains ALL of the specified values.
+  - `BETWEEN` (`BETWEEN`): Checks if a value is within a specified range (inclusive).
+  - `NOT_BETWEEN` (`NOT_BETWEEN`): Checks if a value is outside a specified range.
+  - `MATCHES_REGEX` (`MATCHES_REGEX`): Checks if a string value matches a regular expression.
+  - `ILIKE` (`ILIKE`): Case-insensitive version of `LIKE`.
+  - `NOT_ILIKE` (`NOT_ILIKE`): Case-insensitive version of `NOT_ILIKE`.
+  - `JSON_CONTAINS`: For JSON fields, checks if the JSON contains a specific structure or value.
+  - `JSON_NOT_CONTAINS`: The inverse of `JSON_CONTAINS`.
+  - `ARRAY_CONTAINS_ELEMENT`: For Array fields, checks if the array contains an element.
+  - `ARRAY_CONTAINS_ALL_ELEMENTS`: Checks if the array contains all elements from a given array.
+  - `ARRAY_CONTAINS_ANY_ELEMENT`: Checks if the array contains any of the elements from a given array.
+  - `ARRAY_EQUALS`: Checks if the array is exactly equal to a given array.
+
+[Volver al ndice](#ndice)
 
 ### `LogicalOperator`
 
@@ -347,7 +316,7 @@ Enumeracin que define los operadores lgicos para combinar grupos de filtros.
   - `AND` (`AND`): Todas las condiciones deben cumplirse.
   - `OR` (`OR`): Al menos una condicin debe cumplirse.
 
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ### `OrderDirection`
 
@@ -357,7 +326,7 @@ Enumeracin que define la direccin del ordenamiento.
   - `ASC` (`ASC`): Orden ascendente.
   - `DESC` (`DESC`): Orden descendente.
 
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ---
 
@@ -369,40 +338,40 @@ Interfaz que define la estructura de un esquema de entidad. Los esquemas son cru
 
 - **Propiedades:**
   - `source_name: string`: El nombre real de la tabla o coleccin en la base de datos.
-  - `alias: readonly string[]`: Un array de posibles alias para esta entidad. El primero es usualmente el principal.
+  - `alias: string`: Un nico alias cannico para esta entidad.
   - `fields: readonly string[]`: Un array de los nombres de los campos consultables de esta entidad.
+  - `identifier_field: string`: **(Obligatorio)** El nombre del campo que identifica unvocamente una entidad de este esquema. Debe ser uno de los nombres en `fields`.
   - `joins: readonly SchemaJoins<string>[]` (opcional): Un array que define las posibles relaciones de unin con otros esquemas.
-    - `SchemaJoins<AliasUnion extends string>`:
-      - `alias: AliasUnion`: El alias de la entidad unida (debe coincidir con un alias en el esquema de la entidad unida).
-      - `relation_type: JoinRelationType`: El tipo de relacin (ej. `'one_to_many'`).
-      - `metadata?: { [key: string]: any }`: Metadatos opcionales asociados con esta configuracin de join especfica.
-  - `metadata?: { [key: string]: any }`: Metadatos opcionales asociados con la definicin completa del esquema. Pueden ser usados por los traductores para lgica o pistas personalizadas.
+  - `metadata?: { [key: string]: any }`: Metadatos opcionales asociados con la definicin completa del esquema.
 
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ### `GetTypedCriteriaSchema`
 
 Funcin helper para definir esquemas. Preserva los tipos literales de `fields` y `alias`, mejorando el autocompletado y la validacin de tipos.
 
-- **Funcin:** `GetTypedCriteriaSchema<T extends MinimalCriteriaSchema>(schema: T): T`
-  - **Parmetros:**
-    - `schema`: Un objeto que se ajusta a la estructura `MinimalCriteriaSchema` (una versin ms laxa de `CriteriaSchema` para la entrada).
-  - **Retorna:** El mismo objeto `schema` de entrada, pero con sus tipos literales preservados.
-  - **Ejemplo:**
+- **Funcin:** `GetTypedCriteriaSchema<T extends CriteriaSchema>(schema: T): T`
+- **Ejemplo:**
 
 ```typescript
 import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
 
-const MiEsquemaUsuario = GetTypedCriteriaSchema({
-  source_name: 'usuarios_tabla',
-  alias: ['usuario', 'u'],
-  fields: ['id', 'nombre', 'email'],
-  joins: [{ alias: 'pedidos', relation_type: 'one_to_many' }],
+export const UserSchema = GetTypedCriteriaSchema({
+  source_name: 'users',
+  alias: 'u',
+  fields: ['id', 'name', 'email'],
+  identifier_field: 'id',
+  joins: [
+    {
+      alias: 'posts',
+      target_source_name: 'posts',
+      relation_type: 'one_to_many',
+    },
+  ],
 });
-// MiEsquemaUsuario ahora tiene tipos literales para alias y fields.
 ```
 
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ### `FieldOfSchema`
 
@@ -410,15 +379,7 @@ Tipo helper que extrae los nombres de los campos vlidos de un `CriteriaSchema`
 
 - **Tipo:** `FieldOfSchema<T extends CriteriaSchema> = T['fields'][number];`
 
-Volver al ndice
-
-### `SelectedAliasOf`
-
-Tipo helper que extrae los alias vlidos de un `CriteriaSchema` dado.
-
-- **Tipo:** `SelectedAliasOf<T extends CriteriaSchema> = T['alias'][number];`
-
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ### `JoinRelationType`
 
@@ -426,225 +387,175 @@ Tipo unin de strings que representa los tipos de relaciones de join posibles.
 
 - **Valores Posibles:** `'one_to_one' | 'one_to_many' | 'many_to_one' | 'many_to_many'`
 
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ### `SchemaJoins`
 
 Interfaz que define la estructura de una configuracin de join dentro de la propiedad `joins` de un `CriteriaSchema`.
 
 - **Propiedades:**
-  - `alias: AliasUnion`: El alias de la entidad con la que se une.
+  - `alias: string`: El alias para esta relacin de unin especfica (ej. `'posts'`, `'autor'`).
   - `relation_type: JoinRelationType`: El tipo de relacin.
+  - `target_source_name: string`: El `source_name` del esquema al que se une.
   - `metadata?: { [key: string]: any }`: Metadatos opcionales asociados con esta configuracin de join especfica.
 
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ### `FilterPrimitive`
 
 Interfaz que define la estructura para una condicin de filtro individual antes de ser instanciada como un objeto `Filter`.
 
-- **Genricos:**
-  - `Field extends FieldOfSchema<CriteriaSchema>`: El tipo de los campos vlidos.
-  - `Operator extends FilterOperator`: El operador de filtro especfico.
 - **Propiedades:**
-  - `field: Field`: El campo al que se aplica el filtro.
-  - `operator: Operator`: El operador de filtro.
+  - `field: FieldOfSchema<...>`: El campo al que se aplica el filtro.
+  - `operator: FilterOperator`: El operador de filtro.
   - `value: FilterValue<Operator>`: El valor del filtro, cuyo tipo depende del `Operator`.
 
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ### `FilterGroupPrimitive`
 
 Interfaz que define la estructura para un grupo de filtros antes de ser instanciado como un objeto `FilterGroup`.
 
-- **Genricos:**
-  - `Field extends string`: El tipo de los campos vlidos.
 - **Propiedades:**
   - `logicalOperator: LogicalOperator`: El operador lgico (`AND` o `OR`) que une los `items`.
-  - `items: ReadonlyArray<FilterPrimitive<Field, FilterOperator> | FilterGroupPrimitive<Field>>`: Array de filtros o grupos de filtros anidados.
+  - `items: ReadonlyArray<FilterPrimitive<...> | FilterGroupPrimitive<...>>`: Array de filtros o grupos de filtros anidados.
 
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ### `FilterValue`
 
 Tipo genrico que representa el valor asociado con un filtro, fuertemente tipado segn el `FilterOperator` utilizado.
 
-- **Definicin (conceptual):**
-  - Si `Operator` es `LIKE`, `CONTAINS`, etc. => `string`
-  - Si `Operator` es `EQUALS`, `GREATER_THAN`, etc. => `PrimitiveFilterValue` (string | number | boolean | Date | null)
-  - Si `Operator` es `IN`, `NOT_IN` => `Array<Exclude<PrimitiveFilterValue, null | undefined>>`
-  - Si `Operator` es `SET_CONTAINS_ANY`, `SET_CONTAINS_ALL` => `Array<Exclude<PrimitiveFilterValue, null | undefined>>`
-  - Si `Operator` es `BETWEEN`, `NOT_BETWEEN` => `[Exclude<PrimitiveFilterValue, null | undefined>, Exclude<PrimitiveFilterValue, null | undefined>]`
-  - Si `Operator` es `MATCHES_REGEX`, `ILIKE`, `NOT_ILIKE` => `string`
-  - Si `Operator` es `ARRAY_CONTAINS_ELEMENT` => `PrimitiveFilterValue | { [jsonPath: string]: PrimitiveFilterValue }`
-  - Si `Operator` es `ARRAY_CONTAINS_ALL_ELEMENTS`, etc. => `Array<...> | { [jsonPath: string]: Array<...> }`
-  - Si `Operator` es `IS_NULL`, `IS_NOT_NULL` => `null | undefined`
-  - Si `Operator` es `JSON_CONTAINS`, etc. => `{ [jsonPath: string]: PrimitiveFilterValue | Array<any> | Record<string, any> }`
-
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ### `OrderByPrimitive`
 
 Tipo que define la estructura para una regla de ordenamiento antes de ser instanciada como un objeto `Order`.
 
-- **Genricos:**
-  - `T extends string`: El tipo de los campos vlidos.
 - **Propiedades:**
   - `direction: OrderDirection`: La direccin del ordenamiento.
-  - `field: T`: El campo por el cual ordenar.
+  - `field: string`: El campo por el cual ordenar.
 
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ### `PivotJoinInput`
 
 Tipo que representa los parmetros de entrada para una unin `many-to-many` a travs de una tabla pivote, tal como los proporciona el usuario al mtodo `.join()`.
 
-- **Genricos:**
-  - `ParentSchema extends CriteriaSchema`
-  - `JoinSchema extends CriteriaSchema`
 - **Propiedades:**
   - `pivot_source_name: string`: Nombre de la tabla pivote.
   - `parent_field: { pivot_field: string; reference: FieldOfSchema<ParentSchema> }`: Configuracin del campo de la entidad padre que referencia la tabla pivote.
   - `join_field: { pivot_field: string; reference: FieldOfSchema<JoinSchema> }`: Configuracin del campo de la entidad unida que referencia la tabla pivote.
 
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ### `SimpleJoinInput`
 
 Tipo que representa los parmetros de entrada para una unin simple (one-to-one, one-to-many, many-to-one), tal como los proporciona el usuario al mtodo `.join()`.
 
-- **Genricos:**
-  - `ParentSchema extends CriteriaSchema`
-  - `JoinSchema extends CriteriaSchema`
 - **Propiedades:**
   - `parent_field: FieldOfSchema<ParentSchema>`: Campo en la entidad padre para la condicin de join.
   - `join_field: FieldOfSchema<JoinSchema>`: Campo en la entidad unida para la condicin de join.
 
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ### `ICriteriaBase`
 
 Interfaz base que define la funcionalidad comn para todos los tipos de criterios.
 
-- **Genricos:**
-  - `TSchema extends CriteriaSchema`
-  - `CurrentAlias extends SelectedAliasOf<TSchema>`
-- **Mtodos Principales (ver `Criteria` para detalles):**
-  - `resetSelect()`
-  - `setSelect(...)`
-  - `setTake(...)`
-  - `setSkip(...)`
-  - `orderBy(...)`
-  - `where(...)`
-  - `andWhere(...)`
-  - `orWhere(...)`
-  - `join(...)`
-  - `setCursor(...)`
-- **Propiedades (getters):** `select`, `selectAll`, `take`, `skip`, `orders`, `joins`, `rootFilterGroup`, `sourceName`, `alias`, `cursor`.
-
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ### `ICriteriaVisitor`
 
 Interfaz para el patrn Visitor, implementada por `CriteriaTranslator`. Define los mtodos `visit...` para cada tipo de nodo del `Criteria`.
 
-- **Genricos:**
-  - `TranslationContext`
-  - `TranslationOutput`
-  - `TFilterVisitorOutput`
-- **Mtodos (ver `CriteriaTranslator` para detalles):**
-  - `visitRoot(...)`
-  - `visitInnerJoin(...)`
-  - `visitLeftJoin(...)`
-  - `visitOuterJoin(...)`
-  - `visitFilter(...)`
-  - `visitAndGroup(...)`
-  - `visitOrGroup(...)`
-
-Volver al ndice
+- **Mtodos (retornan `void` a menos que se especifique):**
+  - `visitRoot(...)`: Visita el nodo raz del rbol de Criteria para inicializar la traduccin.
+  - `visitInnerJoin(...)`: Visita un nodo de Inner Join para aplicar su lgica.
+  - `visitLeftJoin(...)`: Visita un nodo de Left Join para aplicar su lgica.
+  - `visitOuterJoin(...)`: Visita un nodo de Outer Join para aplicar su lgica.
+  - `visitFilter(...): TFilterVisitorOutput`: Visita un nodo de Filtro individual y devuelve una representacin intermedia de la condicin.
+  - `visitAndGroup(...)`: Visita un grupo de filtros unidos por un AND lgico.
+  - `visitOrGroup(...)`: Visita un grupo de filtros unidos por un OR lgico.
+
+[Volver al ndice](#ndice)
 
 ### `IFilterExpression`
 
 Interfaz implementada por `Filter` y `FilterGroup`.
 
 - **Mtodos:**
-  - `toPrimitive(): FilterPrimitive<...> | FilterGroupPrimitive<...>`: Devuelve la representacin primitiva de la expresin de filtro.
+  - `toPrimitive()`: Devuelve la representacin primitiva de la expresin de filtro.
 
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ### `StoredJoinDetails`
 
 Interfaz que define la estructura para almacenar los detalles de una unin configurada internamente.
 
-- **Genricos:**
-  - `ParentSchema extends CriteriaSchema`
 - **Propiedades:**
   - `parameters: PivotJoin<...> | SimpleJoin<...>`: Los parmetros resueltos del join.
   - `criteria: AnyJoinCriteria<...>`: La instancia del `Criteria` de la entidad unida.
 
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ### `AnyJoinCriteria`
 
 Tipo unin que representa cualquier tipo de `Criteria` de join (`InnerJoinCriteria`, `LeftJoinCriteria`, `OuterJoinCriteria`).
 
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ### `JoinCriteriaParameterType`
 
-Tipo helper que determina el tipo del objeto `Criteria` que se debe pasar al mtodo `.join()`, validando que el alias de la entidad unida est configurado en el esquema padre.
+Tipo helper que determina el tipo del objeto `Criteria` que se debe pasar al mtodo `.join()`, validando que el `source_name` de la entidad unida est configurado en el esquema padre.
 
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ### `JoinParameterType`
 
-Tipo helper que determina la forma esperada del objeto de parmetros de join para el mtodo `.join()`, basndose en el `join_relation_type` definido en el esquema padre.
+Tipo helper que determina la forma esperada del objeto de parmetros de join para el mtodo `.join()`, basndose en el `relation_type` definido en el esquema padre.
 
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ### `SpecificMatchingJoinConfig`
 
-Tipo helper que extrae la configuracin de join especfica de un esquema padre que coincide con un alias de entidad unida dado.
+Tipo helper que extrae la configuracin de join especfica de un esquema padre que coincide con un `target_source_name` dado.
 
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ### `PivotJoin`
 
 Tipo que representa los parmetros completamente resueltos para una unin `many-to-many` a travs de una tabla pivote, usado internamente.
 
-- **Genricos:**
-  - `ParentSchema extends CriteriaSchema`
-  - `JoinSchema extends CriteriaSchema`
-  - `TRelationType extends JoinRelationType`
 - **Propiedades:**
-  - `relation_type: TRelationType`: El tipo de relacin desde la entidad padre a la entidad unida.
-  - `parent_source_name: ParentSchema['source_name']`
-  - `parent_alias: ParentSchema['alias'][number]`
+  - `relation_type: 'many_to_many'`
+  - `parent_source_name: string`
+  - `parent_alias: string`
+  - `join_alias: string`
+  - `parent_identifier: string`
   - `pivot_source_name: string`
-  - `parent_field: { pivot_field: string; reference: FieldOfSchema<ParentSchema> }`
-  - `join_field: { pivot_field: string; reference: FieldOfSchema<JoinSchema> }`
-  - `parent_schema_metadata: { [key: string]: any }`: Metadatos opcionales del esquema padre.
-  - `join_metadata: { [key: string]: any }`: Metadatos opcionales de la configuracin especfica del join.
+  - `parent_field: { pivot_field: string; reference: string }`
+  - `join_field: { pivot_field: string; reference: string }`
+  - `parent_schema_metadata: { [key: string]: any }`
+  - `join_metadata: { [key: string]: any }`
 
-Volver al ndice
+[Volver al ndice](#ndice)
 
 ### `SimpleJoin`
 
 Tipo que representa los parmetros completamente resueltos para una unin simple (one-to-one, one-to-many, many-to-one), usado internamente.
 
-- **Genricos:**
-  - `ParentSchema extends CriteriaSchema`
-  - `JoinSchema extends CriteriaSchema`
-  - `TRelationType extends JoinRelationType`
 - **Propiedades:**
-  - `relation_type: TRelationType`: El tipo de relacin desde la entidad padre a la entidad unida.
-  - `parent_source_name: ParentSchema['source_name']`
-  - `parent_alias: ParentSchema['alias'][number]`
-  - `parent_field: FieldOfSchema<ParentSchema>`
-  - `join_field: FieldOfSchema<JoinSchema>`
-  - `parent_schema_metadata: { [key: string]: any }`: Metadatos opcionales del esquema padre.
-  - `join_metadata: { [key: string]: any }`: Metadatos opcionales de la configuracin especfica del join.
-
-Volver al ndice
+  - `relation_type: 'one_to_one' | 'one_to_many' | 'many_to_one'`
+  - `parent_source_name: string`
+  - `parent_alias: string`
+  - `join_alias: string`
+  - `parent_identifier: string`
+  - `parent_field: string`
+  - `join_field: string`
+  - `parent_schema_metadata: { [key: string]: any }`
+  - `join_metadata: { [key: string]: any }`
+
+[Volver al ndice](#ndice)
 
 ---
diff --git a/src/docs/core-concepts/en.md b/src/docs/core-concepts/en.md
index 1023549..11afbbb 100644
--- a/src/docs/core-concepts/en.md
+++ b/src/docs/core-concepts/en.md
@@ -4,18 +4,22 @@ This section delves into the fundamental components that make up the `@nulledexp
 
 ## Index of Core Concepts
 
-- **_[Hierarchy of Criteria](#hierarchy-of-criteria)_**
+- **_[Hierarchy of Criteria](#criteria-hierarchy)_**
 - **_[CriteriaFactory](#criteriafactory)_**
 - **_[Schemas (`CriteriaSchema` and `GetTypedCriteriaSchema`)](#schemas-criteriaschema-and-gettypedcriteriaschema)_**
-- **_[`CriteriaTranslator` (Abstract Class and Visitor Pattern)](#criteriatranslator-abstract-class-and-visitor-pattern)_**
+  - [_Identifier Field (`identifier_field`)_](#identifier-field-identifier_field)
+  - [_Schema and Join Metadata_](#schema-and-join-metadata)
+- **_[`CriteriaTranslator` (Abstract Class)](#criteriatranslator-abstract-class)_**
 - **_[Filters (`Filter`, `FilterGroup`, `FilterOperator`)](#filters-filter-filtergroup-filteroperator)_**
 - **_[Ordering (`Order`, `OrderDirection`)](#ordering-order-orderdirection)_**
 - **_[Pagination](#pagination)_**
+  - [_Offset-based Pagination_](#offset-based-pagination)
+  - [_Cursor-based Pagination_](#cursor-based-pagination)
 - **_[Field Selection (`setSelect`, `resetSelect`)](#field-selection-setselect-resetselect)_**
 
 ---
 
-## Hierarchy of `Criteria`
+## `Criteria` Hierarchy
 
 The abstract `Criteria` class is the base for defining query specifications. It represents a set of conditions, orderings, joins, and pagination configurations for an entity or a set of related entities.
 
@@ -29,7 +33,7 @@ There are several concrete implementations of `Criteria`:
 Each `Criteria` instance encapsulates:
 
 - The schema (`CriteriaSchema`) of the entity it applies to.
-- A unique alias to reference this entity in the query.
+- A unique, canonical alias to reference this entity in the query.
 - Internal managers for filters, joins, ordering, and field selection.
 
 [Back to Index](#index-of-core-concepts)
@@ -38,16 +42,24 @@ Each `Criteria` instance encapsulates:
 
 ## `CriteriaFactory`
 
-`CriteriaFactory` is a utility class that provides static methods for creating instances of the different types of `Criteria` (`RootCriteria`, `InnerJoinCriteria`, etc.).
+`CriteriaFactory` is a utility class that provides static methods for creating instances of the different types of `Criteria`.
 
 **Purpose:**
 
 - **Simplify Creation:** Abstracts the complexity of direct instantiation.
-- **Ensure Correct Initialization:** Guarantees that criteria are created with the necessary parameters and initial validations.
+- **Ensure Correct Initialization:** Guarantees that criteria are created with the necessary schema and validations.
 - **Improve Readability:** Makes criteria building code clearer and more concise.
 
 **Recommended Usage:**
-It is strongly recommended to use `CriteriaFactory` instead of instantiating `Criteria` classes directly.
+It is strongly recommended to use `CriteriaFactory` instead of instantiating `Criteria` classes directly. The factory methods no longer require an alias parameter, as the canonical alias is now taken directly from the schema.
+
+```typescript
+import { CriteriaFactory } from '@nulledexp/translatable-criteria';
+import { UserSchema, PostSchema } from './path/to/your/schemas';
+
+const userCriteria = CriteriaFactory.GetCriteria(UserSchema);
+const postJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(PostSchema);
+```
 
 [Back to Index](#index-of-core-concepts)
 
@@ -55,48 +67,114 @@ It is strongly recommended to use `CriteriaFactory` instead of instantiating `Cr
 
 ## Schemas (`CriteriaSchema` and `GetTypedCriteriaSchema`)
 
-Schemas are fundamental for type safety and validation in `@nulledexp/translatable-criteria`. A `CriteriaSchema` defines the "shape" of your data entities as the library understands them.
+Schemas are fundamental for type safety and validation. A `CriteriaSchema` defines the "shape" of your data entities as the library understands them. For a complete guide, see **Defining Schemas**.
 
 **What Defines a Schema?**
 
 - `source_name`: The actual name of the table or collection in the database.
-- `alias`: An array of possible aliases that can be used to refer to this entity in queries.
-- `fields`: An array with the names of the available fields for this entity.
-- `joins`: An array that defines possible join relationships with other schemas, including the `alias` of the join and the `join_relation_type` (e.g., `one_to_many`, `many_to_one`, `many_to_many`).
+- `alias`: A **single, canonical alias** for the entity.
+- `fields`: An array with the names of the available fields.
+- `identifier_field`: A **mandatory** field that uniquely identifies an entity.
+- `joins`: An array defining possible join relationships, each with its own `alias` and `target_source_name`.
+- `metadata`: (Optional) An object to store arbitrary, translator-specific information or configuration relevant to the entire entity this schema represents.
 
 **`GetTypedCriteriaSchema`:**
-This is a helper function used to define schemas. Its main advantage is that it preserves the literal types of the `fields` and `alias`, which allows for more robust autocompletion and type validation when building criteria. This avoids the need to use type assertions (like as const) in the schema definition, while also ensuring the schema structure is valid.
+This is a helper function used to define schemas. Its main advantage is that it preserves the literal types of the `fields`, `alias`, and `identifier_field`, which allows for more robust autocompletion and type validation when building criteria. This avoids the need to use type assertions (like `as const`) in the schema definition, while also ensuring the schema structure (including `identifier_field` validity) is correct.
+
 Schemas are provided to the `CriteriaFactory` when creating `Criteria` instances, allowing the library to validate that the fields, aliases, and joins used are correct.
 
+### Identifier Field (`identifier_field`)
+
+The `identifier_field` is a **mandatory** property in your `CriteriaSchema`. It specifies which field in your `fields` array serves as the unique identifier (primary key) for that entity.
+
+**Purpose:**
+
+- **Unique Identification:** Clearly designates the primary key field.
+- **Enhanced Validation:** The library validates at compile-time (and runtime) that the `identifier_field` you specify is indeed one of the `fields` defined in the schema.
+- **Automatic Selection:** When using `setSelect()` to choose specific fields, the `identifier_field` of the entity is **always implicitly included** in the selection, ensuring that the entity can always be uniquely identified.
+- **Context for Translators:** The identifier of a parent entity is passed to the translator during join operations (`parent_identifier`), which can be used for more advanced relationship inference.
+
+```typescript
+import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
+
+export const UserSchema = GetTypedCriteriaSchema({
+  source_name: 'users',
+  alias: 'u',
+  fields: ['id', 'username', 'email', 'age', 'isActive', 'createdAt', 'tags'],
+  identifier_field: 'id',
+  joins: [
+    {
+      alias: 'posts',
+      target_source_name: 'posts',
+      relation_type: 'one_to_many',
+    },
+  ],
+});
+```
+
+### Schema and Join Metadata
+
+Both the root of a `CriteriaSchema` and the individual join configurations within the `joins` array can have an optional `metadata` property.
+
+- **`CriteriaSchema.metadata`**: For information relevant to the entire entity.
+- **`SchemaJoins.metadata`**: For information specific to a particular join relationship.
+
+**Purpose for the User:**
+This `metadata` field is a flexible, open object (`{ [key: string]: any }`) designed to hold arbitrary information that might be needed by a specific `CriteriaTranslator` you are using.
+
+**How to Use:**
+You can add any key-value pairs to the `metadata` object. The specific keys and values that are meaningful depend entirely on the `CriteriaTranslator` you are using. Consult the documentation of your translator to understand what, if any, `metadata` it recognizes and utilizes.
+
+```typescript
+import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
+
+export const PostSchema = GetTypedCriteriaSchema({
+  source_name: 'posts',
+  alias: 'p',
+  fields: [
+    'id',
+    'title',
+    'content',
+    'userId',
+    'createdAt',
+    'categories',
+    'metadata',
+  ],
+  identifier_field: 'id',
+  metadata: {
+    custom_handler: 'specialPostHandler',
+    versioning_enabled: true,
+  },
+  joins: [
+    {
+      alias: 'user',
+      target_source_name: 'users',
+      relation_type: 'many_to_one',
+      metadata: {
+        typeorm_lazy_load: false,
+        custom_on_clause_template: 'user.id = post.userId_custom_fk',
+      },
+    },
+  ],
+});
+```
+
 [Back to Index](#index-of-core-concepts)
 
 ---
 
-## `CriteriaTranslator` (Abstract Class and Visitor Pattern)
+## `CriteriaTranslator` (Abstract Class)
 
-The `CriteriaTranslator` is the heart of the translation mechanism. It is an abstract class designed to be extended by concrete implementations that will convert a `Criteria` object (data source agnostic) into a specific query for a particular database or search engine (e.g., SQL, a TypeORM query, a MongoDB query, etc.).
+The `CriteriaTranslator` is the component responsible for converting a `Criteria` object (which is data-source agnostic) into a specific query for a particular database or search engine (e.g., SQL, a TypeORM query, a MongoDB query, etc.).
 
 **Main Role:**
 
 - Process a `Criteria` object (typically starting with a `RootCriteria`).
-- "Visit" each part of the `Criteria` (filters, joins, ordering, etc.).
+- Interpret the filters, joins, ordering, pagination, and selection defined in the `Criteria`.
 - Generate the corresponding native query syntax.
 
-**Visitor Pattern:**
-The library uses the Visitor design pattern.
-
-- Each `Criteria` class (and its components like `FilterGroup`, `Filter`) has an `accept(visitor, ...args)` method.
-- The `CriteriaTranslator` implements the `ICriteriaVisitor` interface, which defines `visit...` methods for each type of element it can encounter (e.g., `visitRootCriteria`, `visitInnerJoinCriteria`, `visitFilter`, `visitAndGroup`).
-
-When `criteria.accept(translator, ...)` is called:
-
-1.  The `criteria` invokes the appropriate `visit...` method on the `translator`, passing itself as an argument.
-2.  The `translator` executes the specific logic to translate that type of `criteria` or component.
-
 This allows for a clean and extensible architecture: the logic for building `Criteria` is separated from the translation logic. To support a new database, you only need to create a new translator that extends `CriteriaTranslator`.
 
-Concrete translators (like `@nulledexp/typeorm-mysql-translator`) are provided as separate packages.
-
 [Back to Index](#index-of-core-concepts)
 
 ---
@@ -105,32 +183,16 @@ Concrete translators (like `@nulledexp/typeorm-mysql-translator`) are provided a
 
 Filters allow you to specify the conditions that data must meet to be selected.
 
-- **`Filter`**: Represents a single filter condition. It consists of:
-
-  - `field`: The field the filter is applied to. This field is strongly typed with the valid fields defined in the schema of each Criteria.
-  - `operator`: The comparison operator (see `FilterOperator`).
-  - `value`: The value the field is compared against. The type of this value is strictly typed based on the `operator` used.
-
-- **`FilterOperator`**: This is an enumeration that defines the various comparison operators available, such as:
-
-  - Equality: `EQUALS`, `NOT_EQUALS`
-  - Comparison: `GREATER_THAN`, `LESS_THAN`, `GREATER_THAN_OR_EQUALS`, `LESS_THAN_OR_EQUALS`
-  - Patterns: `LIKE`, `NOT_LIKE`, `CONTAINS`, `NOT_CONTAINS`, `STARTS_WITH`, `ENDS_WITH`
-  - Membership: `IN`, `NOT_IN`
-  - Nullability: `IS_NULL`, `IS_NOT_NULL`
-  - For ranges: `BETWEEN`, `NOT_BETWEEN`
-  - For regular expressions: `MATCHES_REGEX`
-  - For case-insensitive pattern matching: `ILIKE`, `NOT_ILIKE`
-  - For SET-like fields (or equivalents): `SET_CONTAINS`, `SET_NOT_CONTAINS`
-  - For SET-like fields (or equivalents) with multiple values: `SET_CONTAINS_ANY`, `SET_CONTAINS_ALL`
-  - For JSON fields: `JSON_CONTAINS`, `JSON_NOT_CONTAINS`
-  - For Array fields: `ARRAY_CONTAINS_ELEMENT`, `ARRAY_CONTAINS_ALL_ELEMENTS`, `ARRAY_CONTAINS_ANY_ELEMENT`, `ARRAY_EQUALS`
+- **`Filter`**: Represents a single filter condition (`field`, `operator`, `value`).
+- **`FilterGroup`**: Allows grouping multiple `Filter` or even other `FilterGroup` instances using logical operators (`AND` or `OR`).
+- **`FilterOperator`**: An enumeration that defines the various comparison operators available, which can be broadly categorized:
+- **Equality & Comparison:** `EQUALS`, `NOT_EQUALS`, `GREATER_THAN`, `LESS_THAN`, etc.
+- **Pattern Matching:** `LIKE`, `CONTAINS`, `STARTS_WITH`, `ILIKE` (case-insensitive version of LIKE).
+- **Membership & Nullability:** `IN`, `NOT_IN`, `IS_NULL`, `IS_NOT_NULL`.
+- **Ranges & Regex:** `BETWEEN`, `NOT_BETWEEN`, `MATCHES_REGEX`.
+- **Complex Types:** A rich set of operators for `JSON`, `ARRAY`, and `SET` data types (e.g., `JSON_CONTAINS`, `ARRAY_CONTAINS_ANY_ELEMENT`).
 
-- **`FilterGroup`**: Allows grouping multiple `Filter` or even other `FilterGroup` instances using logical operators:
-  - `LogicalOperator.AND`: All conditions within the group must be met.
-  - `LogicalOperator.OR`: At least one condition within the group must be met.
-
-Filters are added to a `Criteria` using the `where()`, `andWhere()`, and `orWhere()` methods. The library automatically normalizes the structure of `FilterGroup` instances to maintain consistency.
+Filters are added to a `Criteria` using the `where()`, `andWhere()`, and `orWhere()` methods. The library automatically normalizes the `FilterGroup` structure to maintain consistency.
 
 [Back to Index](#index-of-core-concepts)
 
@@ -141,15 +203,15 @@ Filters are added to a `Criteria` using the `where()`, `andWhere()`, and `orWher
 Ordering defines how the query results should be sorted.
 
 - **`Order`**: Represents a single ordering rule. It consists of:
+- `field`: The field by which the results will be ordered. This field is strongly typed with the valid fields defined in the schema of each Criteria.
+- `direction`: The ordering direction (see `OrderDirection`).
+- `sequenceId`: (Internal) A unique, globally incrementing ID.
 
-  - `field`: The field by which the results will be ordered. This field is strongly typed with the valid fields defined in the schema of each Criteria.
-  - `direction`: The ordering direction (see `OrderDirection`).
-
-- **`OrderDirection`**: This is an enumeration with two possible values:
-  - `ASC`: Ascending order.
-  - `DESC`: Descending order.
+- **`OrderDirection`**: An enumeration with two possible values:
+- `ASC`: Ascending order.
+- `DESC`: Descending order.
 
-Multiple ordering rules can be added to a `Criteria` using the `orderBy()` method. The order in which they are added is significant, as it defines the sorting priority. Each `Order` also has an internal `sequenceId` that translators can use to maintain a stable order if necessary.
+Multiple ordering rules can be added to a `Criteria` using the `orderBy()` method.
 
 [Back to Index](#index-of-core-concepts)
 
@@ -157,42 +219,47 @@ Multiple ordering rules can be added to a `Criteria` using the `orderBy()` metho
 
 ## Pagination
 
-Pagination allows retrieving subsets of results, which is crucial for handling large amounts of data. The library supports two types of pagination:
+Pagination allows retrieving subsets of results, which is crucial for handling large amounts of data.
+
+### Offset-based Pagination
+
+This is the traditional way of paginating results.
+
+- **`setTake(count)`**: Specifies the maximum number of records to return (equivalent to SQL `LIMIT`).
+- **`setSkip(count)`**: Specifies the number of records to skip before starting to return results (equivalent to SQL `OFFSET`).
 
-- **Offset-based Pagination:**
+### Cursor-based Pagination
 
-  - `setTake(count)`: Specifies the maximum number of records to return (equivalent to `LIMIT`).
-  - `setSkip(count)`: Specifies the number of records to skip before starting to return results (equivalent to `OFFSET`).
+This method is generally more efficient and stable for large datasets, especially those that change frequently.
 
-- **Cursor-based Pagination:**
-  - `setCursor(cursorFilters, operator, order)`: Allows for more efficient and stable pagination, especially with frequently changing datasets.
-    - `cursorFilters`: An array of one or two `FilterPrimitive` objects (without the `operator`) that define the cursor values (e.g., the `created_at` and `uuid` of the last item from the previous page).
-    - `operator`: Must be `FilterOperator.GREATER_THAN` or `FilterOperator.LESS_THAN`, depending on the pagination direction.
-    - `order`: The direction (`OrderDirection`) in which the data is being ordered, which must match the main ordering of the `Criteria`.
-  - For cursor-based pagination to work correctly, the translator is responsible for
-    processing the cursor information (cursorFilters, operator, and order) and ensuring that the
-    necessary orderBy clauses are applied to the final query with appropriate priority, using the
-    fields defined in the cursor.
+- **`setCursor(cursorFilters, operator, order)`**: Configures cursor-based pagination.
+- `cursorFilters`: An array of one or two `FilterPrimitive` objects (without the `operator` property). These define the field(s) and value(s) of the last item from the previous page, which serve as the "cursor".
+- A single `FilterPrimitive` is used for simple cursor pagination (e.g., based on `created_at`).
+- Two `FilterPrimitive`s are used for composite cursor pagination (e.g., based on `created_at` and `uuid` as a tie-breaker).
+- `operator`: Must be `FilterOperator.GREATER_THAN` (for "next page" when ordering ASC) or `FilterOperator.LESS_THAN` (for "next page" when ordering DESC, or "previous page" when ordering ASC).
+- `order`: The `OrderDirection` that matches the primary sort order of the query.
 
 [Back to Index](#index-of-core-concepts)
 
 ---
 
-## Field Selection (setSelect, resetSelect)
+## Field Selection (`setSelect`, `resetSelect`)
 
-By default, when a `Criteria` is created (whether `RootCriteria` or a `JoinCriteria`), all fields defined in its associated schema will be selected. This behavior can be modified:
+By default, when a `Criteria` is created (whether `RootCriteria` or a `JoinCriteria`), all fields defined in its associated schema will be selected (`selectAll` is `true`). This behavior can be modified:
 
-- **`setSelect(fields: FieldOfSchema<TSchema>[])`**: Allows explicitly specifying an array
-  of fields to be selected, typed with the valid fields of that `Criteria` instance's schema. If `setSelect()` is called, only the provided fields will be selected.
+- **`setSelect(fields: FieldOfSchema<TSchema>[])`**:
+- Allows you to explicitly specify an array of fields to be selected. These fields must be valid according to the `Criteria`'s schema.
+- When `setSelect()` is called, `selectAll` becomes `false`.
+- **Important:** The `identifier_field` of the entity is **always implicitly included** in the selection if it's not already specified in the `fields` array. This ensures that the entity can always be uniquely identified. If an empty array `[]` is passed to `setSelect`, only the `identifier_field` will be selected.
 
-  - It is important to note that if `orderBy()` or `setCursor()` is used on fields not included in `setSelect()`, some translators (like the TypeORM translator) might automatically add those fields to the selection to ensure correct database functionality.
+- **`resetSelect()`**:
+- Reverts the selection behavior to the default: all fields from the schema for that `Criteria` instance will be selected (`selectAll` becomes `true`).
 
-- **`resetSelect()`**: Reverts to the default behavior of selecting all fields from the schema for that `Criteria` instance. This is useful if `setSelect()` was previously used and you want to select everything again.
+**Behavior in Joins:**
 
-- **Behavior in Joins:**
-  - If a `JoinCriteria` does not have `setSelect()` explicitly called, all its fields will be included in the main `SELECT` clause of the query, prefixed with the join's alias.
-  - If `setSelect()` is called on a `JoinCriteria`, only those selected fields from the join will be included.
+- If a `JoinCriteria` does not have `setSelect()` explicitly called, all its fields (as defined in its schema) will be included in the main `SELECT` clause of the query, typically prefixed with the join's alias.
+- If `setSelect()` is called on a `JoinCriteria`, only those selected fields (plus its `identifier_field`) from the joined entity will be included.
 
-This flexibility allows optimizing queries to retrieve only the necessary data.
+This flexibility allows optimizing queries to retrieve only the necessary data, reducing data transfer and processing overhead.
 
 [Back to Index](#index-of-core-concepts)
diff --git a/src/docs/core-concepts/es.md b/src/docs/core-concepts/es.md
index c506038..76244d0 100644
--- a/src/docs/core-concepts/es.md
+++ b/src/docs/core-concepts/es.md
@@ -1,41 +1,39 @@
 # Conceptos Clave de @nulledexp/translatable-criteria
 
-Esta seccin profundiza en los componentes fundamentales que conforman la librera
-`@nulledexp/translatable-criteria`. Comprender estos conceptos es esencial para utilizar
-eficazmente la librera y extender su funcionalidad.
+Esta seccin profundiza en los componentes fundamentales que conforman la librera `@nulledexp/translatable-criteria`. Comprender estos conceptos es esencial para utilizar eficazmente la librera y extender su funcionalidad.
 
 ## ndice de Conceptos Clave
 
 - **_[Jerarqua de Criteria](#jerarqua-de-criteria)_**
 - **_[CriteriaFactory](#criteriafactory)_**
 - **_[Esquemas `CriteriaSchema` y `GetTypedCriteriaSchema`](#esquemas-criteriaschema-y-gettypedcriteriaschema)_**
-- **_[CriteriaTranslator (`Clase Abstracta` y `Patrn Visitor`)](#criteriatranslator-clase-abstracta-y-patrn-visitor)_**
+  - [_Campo Identificador (`identifier_field`)_](#campo-identificador-identifier_field)
+  - [_Metadatos de Esquema y Join_](#metadatos-de-esquema-y-join)
+- **_[CriteriaTranslator (`Clase Abstracta`)](#criteriatranslator-clase-abstracta)_**
 - **_[Filtros (`Filter`, `FilterGroup`, `FilterOperator`)](#filtros-filter-filtergroup-filteroperator)_**
 - **_[Ordenamiento (`Order`, `OrderDirection`)](#ordenamiento-order-orderdirection)_**
 - **_[Paginacin](#paginacin)_**
+  - [_Paginacin Basada en Offset_](#paginacin-basada-en-offset)
+  - [_Paginacin Basada en Cursor_](#paginacin-basada-en-cursor)
 - **_[Seleccin de Campos (`setSelect`, `resetSelect`)](#seleccin-de-campos-setselect-resetselect)_**
 
 ---
 
 ## Jerarqua de `Criteria`
 
-La clase abstracta `Criteria` es la base para definir las especificaciones de una consulta.
-Representa un conjunto de condiciones, ordenamientos, uniones y configuraciones de paginacin
-para una entidad o un conjunto de entidades relacionadas.
+La clase abstracta `Criteria` es la base para definir las especificaciones de una consulta. Representa un conjunto de condiciones, ordenamientos, uniones y configuraciones de paginacin para una entidad o un conjunto de entidades relacionadas.
 
 Existen varias implementaciones concretas de `Criteria`:
 
-- **`RootCriteria`**: Representa el punto de partida de una consulta, dirigido a una entidad
-  principal.
+- **`RootCriteria`**: Representa el punto de partida de una consulta, dirigido a una entidad principal.
 - **`InnerJoinCriteria`**: Define una unin interna (INNER JOIN) con otra entidad.
 - **`LeftJoinCriteria`**: Define una unin externa izquierda (LEFT JOIN) con otra entidad.
-- **`OuterJoinCriteria`**: Define una unin externa completa (FULL OUTER JOIN) con otra
-  entidad (su disponibilidad puede depender del traductor especfico).
+- **`OuterJoinCriteria`**: Define una unin externa completa (FULL OUTER JOIN) con otra entidad (su disponibilidad puede depender del traductor especfico).
 
 Cada instancia de `Criteria` encapsula:
 
 - El esquema (`CriteriaSchema`) de la entidad a la que se aplica.
-- Un alias nico para referenciar esta entidad en la consulta.
+- Un alias nico y cannico para referenciar esta entidad en la consulta.
 - Gestores internos para filtros, uniones, ordenamiento y seleccin de campos.
 
 [Volver al ndice](#ndice-de-conceptos-clave)
@@ -44,20 +42,24 @@ Cada instancia de `Criteria` encapsula:
 
 ## `CriteriaFactory`
 
-`CriteriaFactory` es una clase de utilidad que proporciona mtodos estticos para crear
-instancias de los diferentes tipos de `Criteria` (`RootCriteria`, `InnerJoinCriteria`, etc.).
+`CriteriaFactory` es una clase de utilidad que proporciona mtodos estticos para crear instancias de los diferentes tipos de `Criteria`.
 
 **Propsito:**
 
 - **Simplificar la creacin:** Abstrae la complejidad de la instanciacin directa.
-- **Asegurar la correcta inicializacin:** Garantiza que los criterios se creen con los
-  parmetros necesarios y las validaciones iniciales.
-- **Mejorar la legibilidad:** Hace que el cdigo de construccin de criterios sea ms claro y
-  conciso.
+- **Asegurar la correcta inicializacin:** Garantiza que los criterios se creen con los parmetros necesarios y las validaciones iniciales.
+- **Mejorar la legibilidad:** Hace que el cdigo de construccin de criterios sea ms claro y conciso.
 
 **Uso recomendado:**
-Se recomienda utilizar `CriteriaFactory` en lugar de instanciar las clases de
-`Criteria` directamente.
+Se recomienda encarecidamente utilizar `CriteriaFactory` en lugar de instanciar las clases de `Criteria` directamente. Los mtodos de fbrica ya no requieren un parmetro de alias, ya que el alias cannico ahora se toma directamente del esquema.
+
+```typescript
+import { CriteriaFactory } from '@nulledexp/translatable-criteria';
+import { UserSchema, PostSchema } from './path/to/your/schemas';
+
+const userCriteria = CriteriaFactory.GetCriteria(UserSchema);
+const postJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(PostSchema);
+```
 
 [Volver al ndice](#ndice-de-conceptos-clave)
 
@@ -65,62 +67,113 @@ Se recomienda utilizar `CriteriaFactory` en lugar de instanciar las clases de
 
 ## Esquemas (`CriteriaSchema` y `GetTypedCriteriaSchema`)
 
-Los esquemas son fundamentales para la seguridad de tipos y la validacin en  
-`@nulledexp/translatable-criteria`. Un `CriteriaSchema` define la "forma" de tus entidades de datos tal como la librera las entiende.
+Los esquemas son fundamentales para la seguridad de tipos y la validacin. Un `CriteriaSchema` define la "forma" de tus entidades de datos tal como la librera las entiende. Para una gua completa, consulta **Definicin de Esquemas**.
 
 **Qu define un Esquema?**
 
 - `source_name`: El nombre real de la tabla o coleccin en la base de datos.
-- `alias`: Un array de posibles alias que se pueden usar para referirse a esta entidad en las
-  consultas.
-- `fields`: Un array con los nombres de los campos disponibles para esta entidad.
-- `joins`: Un array que define las posibles relaciones de unin con otros esquemas, incluyendo
-  el `alias` del join y el `join_relation_type` (ej. `one_to_many`, `many_to_one`,
-  `many_to_many`).
+- `alias`: Un **nico alias cannico** para la entidad.
+- `fields`: Un array con los nombres de los campos disponibles.
+- `identifier_field`: Un campo **obligatorio** que identifica unvocamente una entidad.
+- `joins`: Un array que define las posibles relaciones de unin, cada una con su propio `alias` y `target_source_name`.
+- `metadata`: (Opcional) Un objeto para almacenar informacin arbitraria, especfica del traductor o configuracin relevante para toda la entidad que este esquema representa.
 
 **`GetTypedCriteriaSchema`:**
-Es una funcin helper que se utiliza para definir esquemas. Su principal ventaja es que preserva los
-tipos literales de los `fields` y `alias`, lo que permite un autocompletado y una validacin de
-tipos ms robusta al construir los criterios. Esto evita la necesidad de usar aserciones de tipo
-(como as const) en la definicin del esquema, al tiempo que asegura que la estructura del esquema sea vlida.
-Los esquemas se proporcionan al `CriteriaFactory` al crear instancias de `Criteria`, permitiendo
-que la librera valide que los campos, alias y uniones utilizados sean correctos.
+Es una funcin helper que se utiliza para definir esquemas. Su principal ventaja es que preserva los tipos literales de los `fields`, `alias` e `identifier_field`, lo que permite un autocompletado y una validacin de tipos ms robusta al construir los criterios. Esto evita la necesidad de usar aserciones de tipo (como `as const`) en la definicin del esquema, al tiempo que asegura que la estructura del esquema (incluyendo la validez de `identifier_field`) sea correcta.
 
-[Volver al ndice](#ndice-de-conceptos-clave)
+Los esquemas se proporcionan al `CriteriaFactory` al crear instancias de `Criteria`, permitiendo que la librera valide que los campos, alias y uniones utilizados sean correctos.
 
----
+### Campo Identificador (`identifier_field`)
 
-## `CriteriaTranslator` (Clase Abstracta y Patrn Visitor)
+El `identifier_field` es una propiedad **obligatoria** en tu `CriteriaSchema`. Especifica qu campo de tu array `fields` sirve como identificador nico (clave primaria) para esa entidad.
 
-El `CriteriaTranslator` es el corazn del mecanismo de traduccin. Es una clase abstracta
-diseada para ser extendida por implementaciones concretas que convertirn un objeto `Criteria`
-(agnstico a la fuente de datos) en una consulta especfica para una base de datos o motor de  
-bsqueda particular (ej. SQL, una query de TypeORM, una consulta de MongoDB, etc.).
+**Propsito:**
 
-**Rol Principal:**
+- **Identificacin nica:** Designa claramente el campo de clave primaria.
+- **Validacin Mejorada:** La librera valida en tiempo de compilacin (y ejecucin) que el `identifier_field` que especificas es realmente uno de los `fields` definidos en el esquema.
+- **Seleccin Automtica:** Al usar `setSelect()` para elegir campos especficos, el `identifier_field` de la entidad **siempre se incluye implcitamente** en la seleccin, asegurando que la entidad siempre pueda ser identificada unvocamente.
+- **Contexto para Traductores:** El identificador de una entidad padre se pasa al traductor durante las operaciones de unin (`parent_identifier`), lo que puede usarse para una inferencia de relaciones ms avanzada.
+
+```typescript
+import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
+
+export const UserSchema = GetTypedCriteriaSchema({
+  source_name: 'users',
+  alias: 'u',
+  fields: ['id', 'username', 'email', 'age', 'isActive', 'createdAt', 'tags'],
+  identifier_field: 'id',
+  joins: [
+    {
+      alias: 'posts',
+      target_source_name: 'posts',
+      relation_type: 'one_to_many',
+    },
+  ],
+});
+```
+
+### Metadatos de Esquema y Join
+
+Tanto la raz de un `CriteriaSchema` como las configuraciones individuales de join dentro del array `joins` pueden tener una propiedad `metadata` opcional.
+
+- **`CriteriaSchema.metadata`**: Para informacin relevante para toda la entidad.
+- **`SchemaJoins.metadata`**: Para informacin especfica de una relacin de join particular.
+
+**Propsito para el Usuario:**
+Este campo `metadata` es un objeto flexible y abierto (`{ [key: string]: any }`) diseado para contener informacin arbitraria que podra ser necesaria para un `CriteriaTranslator` especfico que ests utilizando.
+
+**Cmo Usar:**
+Puedes aadir cualquier par clave-valor al objeto `metadata`. Las claves y valores especficos que son significativos dependen enteramente del `CriteriaTranslator` que ests usando. Consulta la documentacin de tu traductor para entender qu `metadata` (si alguna) reconoce y utiliza.
+
+```typescript
+import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
+
+export const PostSchema = GetTypedCriteriaSchema({
+  source_name: 'posts',
+  alias: 'p',
+  fields: [
+    'id',
+    'title',
+    'content',
+    'userId',
+    'createdAt',
+    'categories',
+    'metadata',
+  ],
+  identifier_field: 'id',
+  metadata: {
+    custom_handler: 'specialPostHandler',
+    versioning_enabled: true,
+  },
+  joins: [
+    {
+      alias: 'user',
+      target_source_name: 'users',
+      relation_type: 'many_to_one',
+      metadata: {
+        typeorm_lazy_load: false,
+        custom_on_clause_template: 'user.id = post.userId_custom_fk',
+      },
+    },
+  ],
+});
+```
 
-- Procesar un objeto `Criteria` (comenzando tpicamente por un `RootCriteria`).
-- "Visitar" cada parte del `Criteria` (filtros, joins, ordenamiento, etc.).
-- Generar la sintaxis de consulta nativa correspondiente.
+[Volver al ndice](#ndice-de-conceptos-clave)
 
-**Patrn Visitor:**
-La librera utiliza el patrn de diseo Visitor.
+---
 
-- Cada clase de `Criteria` (y sus componentes como `FilterGroup`, `Filter`) tiene un mtodo `accept(visitor, ...args)`.
-- El `CriteriaTranslator` implementa la interfaz `ICriteriaVisitor`, que define mtodos `visit...
-` para cada tipo de elemento que puede encontrar (ej. `visitRootCriteria`, `visitInnerJoinCriteria`, `visitFilter`, `visitAndGroup`).
+## `CriteriaTranslator` (Clase Abstracta)
 
-Cuando se llama a `criteria.accept(translator, ...)`:
+El `CriteriaTranslator` es el componente responsable de convertir un objeto `Criteria` (agnstico a la fuente de datos) en una consulta especfica para una base de datos o motor de bsqueda particular (ej. SQL, una query de TypeORM, una consulta de MongoDB, etc.).
 
-1.  El `criteria` invoca el mtodo `visit...` apropiado en el `translator`, pasndose a s mismo como argumento.
-2.  El `translator` ejecuta la lgica especfica para traducir ese tipo de `criteria` o componente.
+**Rol Principal:**
 
-Esto permite una arquitectura limpia y extensible: la lgica de construccin de `Criteria` est
-separada de la lgica de traduccin. Para soportar una nueva base de datos, solo necesitas crear
-un nuevo traductor que extienda `CriteriaTranslator`.
+- Procesar un objeto `Criteria` (comenzando tpicamente por un `RootCriteria`).
+- Interpretar los filtros, uniones, ordenamiento, paginacin y seleccin definidos en el `Criteria`.
+- Generar la sintaxis de consulta nativa correspondiente.
 
-Los traductores concretos (como `@nulledexp/typeorm-mysql-translator`) se proporcionan como
-paquetes separados.
+Esto permite una arquitectura limpia y extensible: la lgica de construccin de `Criteria` est separada de la lgica de traduccin. Para soportar una nueva base de datos, solo necesitas crear un nuevo traductor que extienda `CriteriaTranslator`.
 
 [Volver al ndice](#ndice-de-conceptos-clave)
 
@@ -130,31 +183,14 @@ paquetes separados.
 
 Los filtros permiten especificar las condiciones que deben cumplir los datos para ser seleccionados.
 
-- **`Filter`**: Representa una condicin de filtro individual. Se compone de:
-
-  - `field`: El campo sobre el que se aplica el filtro. Este campo est fuertemente tipado con
-    los campos vlidos definidos en el esquema de cada Criteria.
-  - `operator`: El operador de comparacin (ver `FilterOperator`).
-  - `value`: El valor con el que se compara el campo. El tipo de este valor est estrictamente tipado segn el `operator` utilizado.
-
-- **`FilterOperator`**: Es una enumeracin que define los diversos operadores de comparacin disponibles, tales como:
-
-  - Igualdad: `EQUALS`, `NOT_EQUALS`
-  - Comparacin: `GREATER_THAN`, `LESS_THAN`, `GREATER_THAN_OR_EQUALS`, `LESS_THAN_OR_EQUALS`
-  - Patrones: `LIKE`, `NOT_LIKE`, `CONTAINS`, `NOT_CONTAINS`, `STARTS_WITH`, `ENDS_WITH`
-  - Pertenencia: `IN`, `NOT_IN`
-  - Nulidad: `IS_NULL`, `IS_NOT_NULL`
-  - Para rangos: `BETWEEN`, `NOT_BETWEEN`
-  - Para expresiones regulares: `MATCHES_REGEX`
-  - Para patrones insensibles a maysculas/minsculas: `ILIKE`, `NOT_ILIKE`
-  - Para campos tipo SET (o equivalentes): `SET_CONTAINS`, `SET_NOT_CONTAINS`
-  - Para campos tipo SET (o equivalentes) con mltiples valores: `SET_CONTAINS_ANY`, `SET_CONTAINS_ALL`
-  - Para campos JSON: `JSON_CONTAINS`, `JSON_NOT_CONTAINS`
-  - Para campos Array: `ARRAY_CONTAINS_ELEMENT`, `ARRAY_CONTAINS_ALL_ELEMENTS`, `ARRAY_CONTAINS_ANY_ELEMENT`, `ARRAY_EQUALS`
-
-- **`FilterGroup`**: Permite agrupar mltiples `Filter` o incluso otros `FilterGroup` utilizando operadores lgicos:
-  - `LogicalOperator.AND`: Todas las condiciones dentro del grupo deben cumplirse.
-  - `LogicalOperator.OR`: Al menos una de las condiciones dentro del grupo debe cumplirse.
+- **`Filter`**: Representa una condicin de filtro individual (`field`, `operator`, `value`).
+- **`FilterGroup`**: Permite agrupar mltiples `Filter` o incluso otros `FilterGroup` utilizando operadores lgicos (`AND` u `OR`).
+- **`FilterOperator`**: Es una enumeracin que define los diversos operadores de comparacin disponibles, que se pueden clasificar a grandes rasgos:
+- **Igualdad y Comparacin:** `EQUALS`, `NOT_EQUALS`, `GREATER_THAN`, `LESS_THAN`, etc.
+- **Coincidencia de Patrones:** `LIKE`, `CONTAINS`, `STARTS_WITH`, `ILIKE` (versin de LIKE insensible a maysculas/minsculas).
+- **Pertenencia y Nulidad:** `IN`, `NOT_IN`, `IS_NULL`, `IS_NOT_NULL`.
+- **Rangos y Regex:** `BETWEEN`, `NOT_BETWEEN`, `MATCHES_REGEX`.
+- **Tipos Complejos:** Un amplio conjunto de operadores para tipos de datos `JSON`, `ARRAY` y `SET` (ej. `JSON_CONTAINS`, `ARRAY_CONTAINS_ANY_ELEMENT`).
 
 Los filtros se aaden a un `Criteria` usando los mtodos `where()`, `andWhere()`, y `orWhere()`. La librera normaliza automticamente la estructura de los `FilterGroup` para mantener la consistencia.
 
@@ -167,16 +203,15 @@ Los filtros se aaden a un `Criteria` usando los mtodos `where()`, `andWhere(
 El ordenamiento define cmo se deben clasificar los resultados de la consulta.
 
 - **`Order`**: Representa una regla de ordenamiento individual. Se compone de:
-
-  - `field`: El campo por el cual se ordenarn los resultados. Este campo est fuertemente
-    tipado con los campos vlidos definidos en el esquema de cada Criteria.
-  - `direction`: La direccin del ordenamiento (ver `OrderDirection`).
+- `field`: El campo por el cual se ordenarn los resultados. Este campo est fuertemente tipado con los campos vlidos definidos en el esquema de cada Criteria.
+- `direction`: La direccin del ordenamiento (ver `OrderDirection`).
+- `sequenceId`: (Interno) Un ID nico e incremental globalmente.
 
 - **`OrderDirection`**: Es una enumeracin con dos posibles valores:
-  - `ASC`: Orden ascendente.
-  - `DESC`: Orden descendente.
+- `ASC`: Orden ascendente.
+- `DESC`: Orden descendente.
 
-Se pueden aadir mltiples reglas de ordenamiento a un `Criteria` usando el mtodo `orderBy()`. El orden en que se aaden es significativo, ya que define la prioridad del ordenamiento. Cada `Order` tambin tiene un `sequenceId` interno que los traductores pueden usar para mantener un orden estable si es necesario.
+Se pueden aadir mltiples reglas de ordenamiento a un `Criteria` usando el mtodo `orderBy()`.
 
 [Volver al ndice](#ndice-de-conceptos-clave)
 
@@ -184,44 +219,47 @@ Se pueden aadir mltiples reglas de ordenamiento a un `Criteria` usando el m
 
 ## Paginacin
 
-La paginacin permite recuperar subconjuntos de resultados, lo cual es crucial para manejar grandes cantidades de datos. La librera soporta dos tipos de paginacin:
+La paginacin permite recuperar subconjuntos de resultados, lo cual es crucial para manejar grandes cantidades de datos.
+
+### Paginacin Basada en Offset
+
+Esta es la forma tradicional de paginar resultados.
+
+- **`setTake(count)`**: Especifica el nmero mximo de registros a devolver (equivalente a SQL `LIMIT`).
+- **`setSkip(count)`**: Especifica el nmero de registros a omitir antes de empezar a devolver resultados (equivalente a SQL `OFFSET`).
 
-- **Paginacin basada en Offset:**
+### Paginacin Basada en Cursor
 
-  - `setTake(count)`: Especifica el nmero mximo de registros a devolver (equivalente a `LIMIT`).
-  - `setSkip(count)`: Especifica el nmero de registros a omitir antes de empezar a devolver resultados (equivalente a `OFFSET`).
+Este mtodo es generalmente ms eficiente y estable para grandes conjuntos de datos, especialmente aquellos que cambian frecuentemente.
 
-- **Paginacin basada en Cursor:**
-  - `setCursor(cursorFilters, operator, order)`: Permite una paginacin ms eficiente y estable, especialmente con conjuntos de datos que cambian frecuentemente.
-    - `cursorFilters`: Un array de uno o dos objetos `FilterPrimitive` (sin el `operator`) que definen los valores del cursor (ej. el `created_at` y el `uuid` del ltimo tem de la pgina anterior).
-    - `operator`: Debe ser `FilterOperator.GREATER_THAN` o `FilterOperator.LESS_THAN`, dependiendo de la direccin de paginacin.
-    - `order`: La direccin (`OrderDirection`) en la que se est ordenando, que debe coincidir con el ordenamiento principal del `Criteria`.
-  - Para que la paginacin por cursor funcione correctamente, el traductor es responsable de
-    procesar la informacin del cursor (cursorFilters, operator y order) y asegurar que los
-    orderBy necesarios se apliquen a la consulta final con la prioridad adecuada, utilizando los
-    campos definidos en el cursor.
+- **`setCursor(cursorFilters, operator, order)`**: Configura la paginacin basada en cursor.
+- `cursorFilters`: Un array de uno o dos objetos `FilterPrimitive` (sin la propiedad `operator`). Estos definen el/los campo(s) y valor(es) del ltimo tem de la pgina anterior, que sirven como "cursor".
+- Un solo `FilterPrimitive` se usa para paginacin por cursor simple (ej., basada en `created_at`).
+- Dos `FilterPrimitive` se usan para paginacin por cursor compuesta (ej., basada en `created_at` y `uuid` como desempate).
+- `operator`: Debe ser `FilterOperator.GREATER_THAN` (para "pgina siguiente" al ordenar ASC) o `FilterOperator.LESS_THAN` (para "pgina siguiente" al ordenar DESC, o "pgina anterior" al ordenar ASC).
+- `order`: La `OrderDirection` que coincide con el orden de clasificacin principal de la consulta.
 
 [Volver al ndice](#ndice-de-conceptos-clave)
 
 ---
 
-## Seleccin de Campos (setSelect, resetSelect)
+## Seleccin de Campos (`setSelect`, `resetSelect`)
 
-Por defecto, cuando se crea un `Criteria` (ya sea `RootCriteria` o un `JoinCriteria`), se seleccionarn todos los campos definidos en su esquema asociado. Este comportamiento se puede modificar:
+Por defecto, cuando se crea un `Criteria` (ya sea `RootCriteria` o un `JoinCriteria`), se seleccionarn todos los campos definidos en su esquema asociado (`selectAll` es `true`). Este comportamiento se puede modificar:
 
-- **`setSelect(fields: FieldOfSchema<TSchema>[])`**: Permite especificar explcitamente un array
-  de campos que se deben seleccionar tipado con los field
-  validos del esquema de esa instancia de `Criteria`. Si se llama a `setSelect()`, solo se seleccionarn los campos
-  proporcionados.
+- **`setSelect(fields: FieldOfSchema<TSchema>[])`**:
+- Permite especificar explcitamente un array de campos que se deben seleccionar. Estos campos deben ser vlidos segn el esquema del `Criteria`.
+- Cuando se llama a `setSelect()`, `selectAll` se vuelve `false`.
+- **Importante:** El `identifier_field` de la entidad **siempre se incluye implcitamente** en la seleccin si no est ya especificado en el array `fields`. Esto asegura que la entidad siempre pueda ser identificada unvocamente. Si se pasa un array vaco `[]` a `setSelect`, solo se seleccionar el `identifier_field`.
 
-  - Es importante notar que si se utiliza `orderBy()` o `setCursor()` sobre campos que no estn incluidos en `setSelect()`, algunos traductores (como el de TypeORM) podran aadir automticamente esos campos a la seleccin para asegurar el correcto funcionamiento de la base de datos.
+- **`resetSelect()`**:
+- Revierte el comportamiento de seleccin al predeterminado: se seleccionarn todos los campos del esquema para esa instancia de `Criteria` (`selectAll` se vuelve `true`).
 
-- **`resetSelect()`**: Revierte al comportamiento por defecto de seleccionar todos los campos del esquema para esa instancia de `Criteria`. Esto es til si previamente se us `setSelect()` y se desea volver a seleccionar todo.
+**Comportamiento en Joins:**
 
-- **Comportamiento en Joins:**
-  - Si un `JoinCriteria` no tiene `setSelect()` llamado explcitamente, todos sus campos se incluirn en la clusula `SELECT` principal de la consulta, prefijados con el alias del join.
-  - Si se llama a `setSelect()` en un `JoinCriteria`, solo esos campos seleccionados del join se incluirn.
+- Si un `JoinCriteria` no tiene `setSelect()` llamado explcitamente, todos sus campos (definidos en su esquema) se incluirn en la clusula `SELECT` principal de la consulta, tpicamente prefijados con el alias del join.
+- Si se llama a `setSelect()` en un `JoinCriteria`, solo esos campos seleccionados (ms su `identifier_field`) de la entidad unida se incluirn.
 
-Esta flexibilidad permite optimizar las consultas para recuperar solo los datos necesarios.
+Esta flexibilidad permite optimizar las consultas para recuperar solo los datos necesarios, reduciendo la transferencia de datos y la sobrecarga de procesamiento.
 
 [Volver al ndice](#ndice-de-conceptos-clave)
diff --git a/src/docs/guides/building-criteria/en.md b/src/docs/guides/building-criteria/en.md
index a099fac..572231f 100644
--- a/src/docs/guides/building-criteria/en.md
+++ b/src/docs/guides/building-criteria/en.md
@@ -12,11 +12,12 @@ This guide will show you how to use `CriteriaFactory` and the fluent methods of
   - [Logical Grouping (AND/OR)](#logical-grouping-andor)
   - [Advanced Filters (JSON, Array, Set)](#advanced-filters-json-array-set)
     - [Filtering JSON Fields (`JSON_CONTAINS`, `JSON_NOT_CONTAINS`)](#filtering-json-fields-json_contains-json_not_contains)
-    - [Filtering Array Fields (`ARRAY_CONTAINS_ELEMENT`, etc.)](#filtering-array-fields-array_contains_element-array_contains_all_elements-array_contains_any_element-array_equals)
+    - [Filtering Array Fields (`ARRAY_CONTAINS_ELEMENT`, etc.)](#filtering-array-fields-array_contains_element-etc)
     - [Filtering SET Fields (`SET_CONTAINS`, `SET_NOT_CONTAINS`, `SET_CONTAINS_ANY`, `SET_CONTAINS_ALL`)](#filtering-set-fields-set_contains-set_not_contains-set_contains_any-set_contains_all)
     - [Filtering by Ranges (`BETWEEN`, `NOT_BETWEEN`)](#filtering-by-ranges-between-not_between)
     - [Filtering with Regular Expressions (`MATCHES_REGEX`)](#filtering-with-regular-expressions-matches_regex)
     - [Case-Insensitive Pattern Matching (`ILIKE`, `NOT_ILIKE`)](#case-insensitive-pattern-matching-ilike-not_ilike)
+  - [Filter Operator Reference](#filter-operator-reference)
 - 3. [Adding Joins](#3-adding-joins)
   - [Simple Joins (one-to-many, many-to-one, one-to-one)](#simple-joins-one-to-many-many-to-one-one-to-one)
   - [Joins with Pivot Table (many-to-many)](#joins-with-pivot-table-many-to-many)
@@ -36,23 +37,86 @@ This guide will show you how to use `CriteriaFactory` and the fluent methods of
 
 ---
 
+## Example Schemas
+
+To make the examples in this guide self-contained, we will use the following simplified schemas:
+
+```typescript
+import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
+
+export const UserSchema = GetTypedCriteriaSchema({
+  source_name: 'users',
+  alias: 'u',
+  fields: ['id', 'username', 'email', 'age', 'isActive', 'createdAt', 'tags'],
+  identifier_field: 'id',
+  joins: [
+    {
+      alias: 'posts',
+      target_source_name: 'posts',
+      relation_type: 'one_to_many',
+    },
+    {
+      alias: 'roles',
+      target_source_name: 'roles',
+      relation_type: 'many_to_many',
+    },
+  ],
+});
+
+export const PostSchema = GetTypedCriteriaSchema({
+  source_name: 'posts',
+  alias: 'p',
+  fields: [
+    'id',
+    'title',
+    'content',
+    'userId',
+    'createdAt',
+    'categories',
+    'metadata',
+  ],
+  identifier_field: 'id',
+  joins: [
+    {
+      alias: 'user',
+      target_source_name: 'users',
+      relation_type: 'many_to_one',
+    },
+  ],
+});
+
+export const RoleSchema = GetTypedCriteriaSchema({
+  source_name: 'roles',
+  alias: 'r',
+  fields: ['id', 'name'],
+  identifier_field: 'id',
+  joins: [],
+});
+
+export const ProductSchema = GetTypedCriteriaSchema({
+  source_name: 'products',
+  alias: 'prod',
+  fields: ['id', 'name', 'price', 'createdAt'],
+  identifier_field: 'id',
+  joins: [],
+});
+```
+
+---
+
 ## 1. Creating a `RootCriteria`
 
-Every query starts with a `RootCriteria`, which represents the main entity from which the query will begin. It is created using `CriteriaFactory.GetCriteria()`:
+Every query starts with a `RootCriteria`, which represents the main entity from which the query will begin. It is created using `CriteriaFactory.GetCriteria()`. The alias is now taken directly from the `alias` property of the provided schema.
 
 ```typescript
 import { CriteriaFactory } from '@nulledexp/translatable-criteria';
-import { UserSchema, PostSchema } from './path/to/your/schemas'; // Ensure the path is correct
-
-// Create Criteria for the User entity, using the 'users' alias
-const userCriteria = CriteriaFactory.GetCriteria(UserSchema, 'users');
+import { UserSchema, PostSchema } from './path/to/your/schemas';
 
-// Create Criteria for the Post entity, using the 'posts' alias
-const postCriteria = CriteriaFactory.GetCriteria(PostSchema, 'posts');
+const userCriteria = CriteriaFactory.GetCriteria(UserSchema);
+const postCriteria = CriteriaFactory.GetCriteria(PostSchema);
 ```
 
-- The first argument is the entity's schema (`UserSchema`, `PostSchema`).
-- The second argument is one of the aliases defined in the `alias` array of that schema. Using the correct alias is crucial for proper interpretation by translators.
+---
 
 ## 2. Applying Filters
 
@@ -61,25 +125,26 @@ Filters are added using the `where()`, `andWhere()`, and `orWhere()` methods. Th
 ### Basic Filters
 
 ```typescript
-import { FilterOperator } from '@nulledexp/translatable-criteria';
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { UserSchema, PostSchema } from './path/to/your/schemas';
 
-// Find users with a specific email
-userCriteria.where({
-  field: 'email', // Field from UserSchema
+const userEmailCriteria = CriteriaFactory.GetCriteria(UserSchema).where({
+  field: 'email',
   operator: FilterOperator.EQUALS,
   value: 'test@example.com',
 });
 
-// Find posts whose title contains "TypeScript"
-postCriteria.where({
-  field: 'title', // Field from PostSchema
-  operator: FilterOperator.CONTAINS, // or FilterOperator.LIKE with '%'
-  value: '%TypeScript%',
+const postTitleCriteria = CriteriaFactory.GetCriteria(PostSchema).where({
+  field: 'title',
+  operator: FilterOperator.CONTAINS,
+  value: 'TypeScript',
 });
 
-// Find posts created after a specific date
-postCriteria.where({
-  field: 'created_at',
+const postDateCriteria = CriteriaFactory.GetCriteria(PostSchema).where({
+  field: 'createdAt',
   operator: FilterOperator.GREATER_THAN,
   value: new Date('2023-01-01'),
 });
@@ -91,8 +156,13 @@ postCriteria.where({
 - `orWhere()`: Adds a condition that, if met, makes the filter group true, even if previous conditions (grouped by AND) are not (logical OR). The library normalizes this to maintain a structure of `OR ( (cond1 AND cond2), (cond3) )`.
 
 ```typescript
-// Users whose username is 'admin' AND their email contains '@example.com'
-userCriteria
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { UserSchema, PostSchema } from './path/to/your/schemas';
+
+const adminUserCriteria = CriteriaFactory.GetCriteria(UserSchema)
   .where({ field: 'username', operator: FilterOperator.EQUALS, value: 'admin' })
   .andWhere({
     field: 'email',
@@ -100,22 +170,19 @@ userCriteria
     value: '@example.com',
   });
 
-// Posts that contain "Tutorial" in the title OR in the post body
-postCriteria
+const tutorialPostCriteria = CriteriaFactory.GetCriteria(PostSchema)
   .where({
     field: 'title',
     operator: FilterOperator.CONTAINS,
     value: 'Tutorial',
   })
   .orWhere({
-    field: 'body',
+    field: 'content',
     operator: FilterOperator.CONTAINS,
     value: 'Tutorial',
   });
 
-// More complex combination:
-// (username = 'editor' AND email LIKE '%@editor.com%') OR (username = 'guest')
-userCriteria
+const editorOrGuestCriteria = CriteriaFactory.GetCriteria(UserSchema)
   .where({
     field: 'username',
     operator: FilterOperator.EQUALS,
@@ -123,8 +190,8 @@ userCriteria
   })
   .andWhere({
     field: 'email',
-    operator: FilterOperator.LIKE,
-    value: '%@editor.com%',
+    operator: FilterOperator.CONTAINS,
+    value: '@editor.com',
   })
   .orWhere({
     field: 'username',
@@ -135,38 +202,31 @@ userCriteria
 
 ### Advanced Filters (JSON, Array, Set)
 
-The library supports operators for more complex data types like JSON, arrays, and SET-type fields.
+The library supports a wide range of operators for complex data types. For a full list, see the Core Concepts guide. Here are a few examples:
 
 #### Filtering JSON Fields (`JSON_CONTAINS`, `JSON_NOT_CONTAINS`)
 
 The value for these operators is an object where keys are JSON paths (the translator will determine if it needs `$.` at the beginning) and values are what is being searched for in that path.
 
 ```typescript
-// Assuming PostSchema has a 'metadata' field of JSON type
-// with a structure like: { tags: ["tech", "code"], views: 100 }
-
-// Find posts where metadata.tags contains "tech" AND metadata.views is 100
-postCriteria.where({
-  field: 'metadata', // The JSON field
-  operator: FilterOperator.JSON_CONTAINS,
-  value: {
-    tags: 'tech', // Searches for "tech" within the metadata.tags array
-    views: 100, // Searches for metadata.views to be 100
-    // "extra.source": "import" // You can also nest paths
-  },
-});
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema } from './path/to/your/schemas';
 
-// Find posts where metadata.extra.quality IS NOT "low"
-postCriteria.where({
+const jsonCriteria = CriteriaFactory.GetCriteria(PostSchema).where({
   field: 'metadata',
-  operator: FilterOperator.JSON_NOT_CONTAINS,
+  operator: FilterOperator.JSON_CONTAINS,
   value: {
-    'extra.quality': 'low',
+    tags: 'tech',
+    views: 100,
+    'extra.source': 'import',
   },
 });
 ```
 
-#### Filtering Array Fields (`ARRAY_CONTAINS_ELEMENT`, `ARRAY_CONTAINS_ALL_ELEMENTS`, `ARRAY_CONTAINS_ANY_ELEMENT`, `ARRAY_EQUALS`)
+#### Filtering Array Fields (`ARRAY_CONTAINS_ELEMENT`, etc.)
 
 These operators can be used for fields that are native arrays or arrays within JSON.
 
@@ -174,39 +234,16 @@ These operators can be used for fields that are native arrays or arrays within J
 - **For arrays within JSON:** The `value` is an object with a single key (the JSON path to the array) and the value is the element or array of elements.
 
 ```typescript
-// 1. Native Array Column: Find posts that have the "TypeScript" category
-postCriteria.where({
-  field: 'categories',
-  operator: FilterOperator.ARRAY_CONTAINS_ELEMENT,
-  value: 'TypeScript',
-});
-
-// 2. Array within JSON: Find posts where metadata.tags contains "typeorm"
-postCriteria.where({
-  field: 'metadata', // Main JSON field
-  operator: FilterOperator.ARRAY_CONTAINS_ELEMENT,
-  value: { tags: 'typeorm' }, // { "path.to.array": element }
-});
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema } from './path/to/your/schemas';
 
-// 3. Native Array Column: Find posts that have ALL categories ["nestjs", "api"]
-postCriteria.where({
+const arrayCriteria = CriteriaFactory.GetCriteria(PostSchema).where({
   field: 'categories',
-  operator: FilterOperator.ARRAY_CONTAINS_ALL_ELEMENTS,
-  value: ['nestjs', 'api'],
-});
-
-// 4. Array within JSON: Find posts where metadata.ratings contains AT LEAST ONE of [4, 5]
-postCriteria.where({
-  field: 'metadata',
   operator: FilterOperator.ARRAY_CONTAINS_ANY_ELEMENT,
-  value: { ratings: [4, 5] },
-});
-
-// 5. Native Array Column: Find posts whose categories are EXACTLY ["news", "updates"] (order matters)
-postCriteria.where({
-  field: 'categories',
-  operator: FilterOperator.ARRAY_EQUALS,
-  value: ['news', 'updates'],
+  value: ['nestjs', 'api'],
 });
 ```
 
@@ -215,28 +252,16 @@ postCriteria.where({
 Similar to `CONTAINS` but conceptually for fields representing a set of values (like MySQL's `SET` type or a delimited string).
 
 ```typescript
-// Assuming a 'flags' field in UserSchema which is a SET('active', 'verified', 'beta_tester')
-// or a text field 'tags' like "typescript,javascript,nodejs"
-
-// Find users who have the 'verified' flag
-userCriteria.where({
-  field: 'flags',
-  operator: FilterOperator.SET_CONTAINS,
-  value: 'verified',
-});
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { UserSchema } from './path/to/your/schemas';
 
-// Find users who have AT LEAST ONE of the tags "typescript" or "javascript"
-userCriteria.where({
+const setCriteria = CriteriaFactory.GetCriteria(UserSchema).where({
   field: 'tags',
   operator: FilterOperator.SET_CONTAINS_ANY,
-  value: ['typescript', 'javascript'], // Expects an array of values
-});
-
-// Find users who have ALL the flags "active" AND "beta_tester"
-userCriteria.where({
-  field: 'flags',
-  operator: FilterOperator.SET_CONTAINS_ALL,
-  value: ['active', 'beta_tester'], // Expects an array of values
+  value: ['typescript', 'javascript'],
 });
 ```
 
@@ -245,15 +270,21 @@ userCriteria.where({
 These operators allow you to check if a numeric or date value falls within or outside a specific range.
 
 ```typescript
-// Find posts created between two dates
-postCriteria.where({
-  field: 'created_at',
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema, ProductSchema } from './path/to/your/schemas';
+
+const betweenDatesCriteria = CriteriaFactory.GetCriteria(PostSchema).where({
+  field: 'createdAt',
   operator: FilterOperator.BETWEEN,
-  value: [new Date('2023-01-01'), new Date('2023-03-31')], // [min, max]
+  value: [new Date('2023-01-01'), new Date('2023-03-31')],
 });
 
-// Find products whose price IS NOT between 100 and 200
-productCriteria.where({
+const notBetweenPriceCriteria = CriteriaFactory.GetCriteria(
+  ProductSchema,
+).where({
   field: 'price',
   operator: FilterOperator.NOT_BETWEEN,
   value: [100, 200],
@@ -265,12 +296,16 @@ productCriteria.where({
 Allows for more powerful pattern matching using regular expressions. The specific syntax of the regular expression may depend on the underlying database.
 
 ```typescript
-// Find users whose username starts with "admin" followed by numbers
-// (conceptual example, REGEX syntax varies)
-userCriteria.where({
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { UserSchema } from './path/to/your/schemas';
+
+const regexCriteria = CriteriaFactory.GetCriteria(UserSchema).where({
   field: 'username',
   operator: FilterOperator.MATCHES_REGEX,
-  value: '^admin[0-9]+', // The regular expression as a string
+  value: '^admin[0-9]+',
 });
 ```
 
@@ -279,109 +314,162 @@ userCriteria.where({
 Similar to `LIKE` and `NOT_LIKE`, but they ensure that pattern comparison is case-insensitive, regardless of the database's default collation.
 
 ```typescript
-// Find posts whose title contains "typescript" (case-insensitive)
-postCriteria.where({
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema } from './path/to/your/schemas';
+
+const ilikeCriteria = CriteriaFactory.GetCriteria(PostSchema).where({
   field: 'title',
   operator: FilterOperator.ILIKE,
   value: '%typescript%',
 });
-
-// Find users whose email DOES NOT start with "test" (case-insensitive)
-userCriteria.where({
-  field: 'email',
-  operator: FilterOperator.NOT_ILIKE,
-  value: 'test%',
-});
 ```
 
+### Filter Operator Reference
+
+Here is a detailed list of the available `FilterOperator` values and the type of `value` they expect.
+
+#### Equality & Comparison
+
+- `EQUALS`: Checks for exact equality. Expects a primitive value (`string`, `number`, `boolean`, `Date`, `null`).
+- `NOT_EQUALS`: Checks for inequality. Expects a primitive value.
+- `GREATER_THAN`: Checks if a value is greater than the provided one. Expects a `number` or `Date`.
+- `GREATER_THAN_OR_EQUALS`: Checks if a value is greater than or equal to the provided one. Expects a `number` or `Date`.
+- `LESS_THAN`: Checks if a value is less than the provided one. Expects a `number` or `Date`.
+- `LESS_THAN_OR_EQUALS`: Checks if a value is less than or equal to the provided one. Expects a `number` or `Date`.
+
+#### Pattern Matching
+
+- `LIKE`: Matches a pattern (case-sensitivity depends on the database). Expects a `string`. The translator is responsible for handling wildcards (`%`, `_`).
+- `NOT_LIKE`: Checks if a value does not match a pattern. Expects a `string`.
+- `CONTAINS`: Checks if a string contains a substring. Expects a `string`. The translator will typically wrap the value with wildcards (e.g., `'%value%'`).
+- `NOT_CONTAINS`: Checks if a string does not contain a substring. Expects a `string`.
+- `STARTS_WITH`: Checks if a string starts with a specific substring. Expects a `string`. The translator will typically append a wildcard (e.g., `'value%'`).
+- `ENDS_WITH`: Checks if a string ends with a specific substring. Expects a `string`. The translator will typically prepend a wildcard (e.g., `'%value'`).
+- `ILIKE`: Case-insensitive version of `LIKE`. Expects a `string`.
+- `NOT_ILIKE`: Case-insensitive version of `NOT_LIKE`. Expects a `string`.
+
+#### Membership & Nullability
+
+- `IN`: Checks if a value is within a given array. Expects an `Array<string | number | boolean | Date>`.
+- `NOT_IN`: Checks if a value is not within a given array. Expects an `Array<string | number | boolean | Date>`.
+- `IS_NULL`: Checks if a value is `NULL`. The `value` property should be `null` or `undefined`.
+- `IS_NOT_NULL`: Checks if a value is not `NULL`. The `value` property should be `null` or `undefined`.
+
+#### Ranges & Regex
+
+- `BETWEEN`: Checks if a value is within a specified range (inclusive). Expects a tuple of two values: `[min, max]`.
+- `NOT_BETWEEN`: Checks if a value is outside a specified range. Expects a tuple of two values: `[min, max]`.
+- `MATCHES_REGEX`: Checks if a string value matches a regular expression. Expects a `string` representing the regex pattern.
+
+#### Complex Types (JSON, Array, SET)
+
+- **JSON Operators**
+- `JSON_CONTAINS`: Checks if a JSON document contains a specific structure or value at a given path. Expects an object where keys are JSON paths and values are the data to find (e.g., `{ "tags": "tech", "views": 100 }`).
+- `JSON_NOT_CONTAINS`: The inverse of `JSON_CONTAINS`.
+- **Array Operators**
+- `ARRAY_CONTAINS_ELEMENT`: Checks if an array contains a specific element. For native array columns, expects a primitive value. For JSON arrays, expects an object like `{ "path.to.array": elementValue }`.
+- `ARRAY_CONTAINS_ALL_ELEMENTS`: Checks if an array contains all elements from a given array. Expects an `Array<primitive>` or `{ "path.to.array": [elements] }`.
+- `ARRAY_CONTAINS_ANY_ELEMENT`: Checks if an array contains at least one element from a given array. Expects an `Array<primitive>` or `{ "path.to.array": [elements] }`.
+- `ARRAY_EQUALS`: Checks if an array is exactly equal to a given array (order and elements). Expects an `Array<primitive>` or `{ "path.to.array": [elements] }`.
+- **SET Operators** (Conceptually for sets, often used on string or array fields)
+- `SET_CONTAINS`: Checks if a set contains a specific value. Expects a `string`.
+- `SET_NOT_CONTAINS`: The inverse of `SET_CONTAINS`.
+- `SET_CONTAINS_ANY`: Checks if a set contains at least one of the specified values. Expects an `Array<string>`.
+- `SET_CONTAINS_ALL`: Checks if a set contains all of the specified values. Expects an `Array<string>`.
+
+---
+
 ## 3. Adding Joins
 
-Joins are added with the `join()` method. This method takes two arguments:
+Joins are added with the `join()` method. This method's signature has been updated for clarity and type safety:
+
+`criteria.join(joinAlias, criteriaToJoin, joinParameters)`
 
-1. An instance of a join `Criteria` (`InnerJoinCriteria`, `LeftJoinCriteria`, `OuterJoinCriteria`), also created with `CriteriaFactory`.
-2. A join parameters object that defines how the entities are related.
+- **`joinAlias` (string):** This is the **alias of the relationship** as defined in the `joins` array within the _parent schema_. It acts as a unique identifier for that specific relationship configuration. The library uses this `joinAlias` along with the `source_name` of the `criteriaToJoin` (the schema of the entity being joined) to find the exact relationship definition in the parent schema.
+- **`criteriaToJoin` (JoinCriteria):** An instance of a join `Criteria` (`InnerJoinCriteria`, `LeftJoinCriteria`, etc.), created with `CriteriaFactory`.
+- **`joinParameters` (object):** An object that defines how the entities are related (`parent_field`, `join_field`, etc.).
 
 ### Simple Joins (one-to-many, many-to-one, one-to-one)
 
 For these relationships, the join parameters are `parent_field` and `join_field`.
 
 ```typescript
-// Get posts and their author (publisher)
-// PostSchema defines a 'publisher' join (many-to-one) with UserSchema
-const postsWithAuthorCriteria = CriteriaFactory.GetCriteria(
-  PostSchema,
-  'posts',
-).join(
-  CriteriaFactory.GetInnerJoinCriteria(UserSchema, 'publisher'), // 'publisher' is an alias in UserSchema
+import { CriteriaFactory } from '@nulledexp/translatable-criteria';
+import { UserSchema, PostSchema } from './path/to/your/schemas';
+
+const postsWithAuthorCriteria = CriteriaFactory.GetCriteria(PostSchema).join(
+  'user',
+  CriteriaFactory.GetInnerJoinCriteria(UserSchema),
   {
-    parent_field: 'user_uuid', // FK field in PostSchema
-    join_field: 'uuid', // PK field in UserSchema (the 'publisher')
+    parent_field: 'userId',
+    join_field: 'id',
   },
 );
 
-// Get users and their posts
-// UserSchema defines a 'posts' join (one-to-many) with PostSchema
-const usersWithPostsCriteria = CriteriaFactory.GetCriteria(
-  UserSchema,
-  'users',
-).join(
-  CriteriaFactory.GetLeftJoinCriteria(PostSchema, 'posts'), // 'posts' is an alias in PostSchema
+const usersWithPostsCriteria = CriteriaFactory.GetCriteria(UserSchema).join(
+  'posts',
+  CriteriaFactory.GetLeftJoinCriteria(PostSchema),
   {
-    parent_field: 'uuid', // PK field in UserSchema
-    join_field: 'user_uuid', // FK field in PostSchema
+    parent_field: 'id',
+    join_field: 'userId',
   },
 );
 ```
 
-**Note:** The `alias` used in `GetInnerJoinCriteria` (e.g., `'publisher'`) must be one of the `alias` defined in the schema of the entity being joined (in this case, `UserSchema`). The library validates this.
-
 ### Joins with Pivot Table (many-to-many)
 
-For `many_to_many` relationships, the join parameters require a more detailed object that includes `pivot_source_name` and objects for `parent_field` and `join_field` specifying both the field in the entity and the field in the pivot table.
+For `many_to_many` relationships, the join parameters require a more detailed object that includes `pivot_source_name` and objects for `parent_field` and `join_field`.
 
 ```typescript
-// Get users and their permissions
-// UserSchema defines a 'permissions' join (many-to-many) with PermissionSchema
-const usersWithPermissionsCriteria = CriteriaFactory.GetCriteria(
-  UserSchema,
-  'users',
-).join(CriteriaFactory.GetInnerJoinCriteria(PermissionSchema, 'permissions'), {
-  pivot_source_name: 'user_permission_pivot', // Name of your pivot table
-  parent_field: {
-    pivot_field: 'user_id_in_pivot', // FK of User in the pivot table
-    reference: 'uuid', // PK of User
-  },
-  join_field: {
-    pivot_field: 'permission_id_in_pivot', // FK of Permission in the pivot table
-    reference: 'uuid', // PK of Permission
+import { CriteriaFactory } from '@nulledexp/translatable-criteria';
+import { UserSchema, RoleSchema } from './path/to/your/schemas';
+
+const usersWithRolesCriteria = CriteriaFactory.GetCriteria(UserSchema).join(
+  'roles',
+  CriteriaFactory.GetInnerJoinCriteria(RoleSchema),
+  {
+    pivot_source_name: 'user_roles',
+    parent_field: { pivot_field: 'user_id', reference: 'id' },
+    join_field: { pivot_field: 'role_id', reference: 'id' },
   },
-});
+);
 ```
 
 ### Filtering on Joined Entities
 
-You can apply filters directly to the join `Criteria`:
+You can apply filters directly to the `JoinCriteria` instance before passing it to the `.join()` method.
 
 ```typescript
-// Get posts and only comments that DO NOT contain "spam"
-const postsWithFilteredComments = CriteriaFactory.GetCriteria(
-  PostSchema,
-  'posts',
-).join(
-  CriteriaFactory.GetLeftJoinCriteria(PostCommentSchema, 'comments').where({
-    // Filter applied to the JoinCriteria (comments)
-    field: 'comment_text',
-    operator: FilterOperator.NOT_CONTAINS,
-    value: 'spam',
-  }),
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema, UserSchema } from './path/to/your/schemas';
+
+const activeUserJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(
+  UserSchema,
+).where({
+  field: 'isActive',
+  operator: FilterOperator.EQUALS,
+  value: true,
+});
+
+const postsFromActiveUsers = CriteriaFactory.GetCriteria(PostSchema).join(
+  'user',
+  activeUserJoinCriteria,
   {
-    parent_field: 'uuid',
-    join_field: 'post_uuid',
+    parent_field: 'userId',
+    join_field: 'id',
   },
 );
 ```
 
-These filters on the `JoinCriteria` typically translate to conditions in the `ON` clause of the JOIN (or `AND` after the `ON` for some translators/databases).
+These filters on the `JoinCriteria` typically translate to conditions in the `ON` clause of the JOIN.
+
+---
 
 ## 4. Ordering Results
 
@@ -390,12 +478,14 @@ Ordering is applied with the `orderBy()` method, which takes the field name and
 ### Ordering by Root Entity Fields
 
 ```typescript
-// Get users ordered by email ascending
-userCriteria.orderBy('email', OrderDirection.ASC);
-
-// Get posts ordered by creation date descending, then by title ascending
-postCriteria
-  .orderBy('created_at', OrderDirection.DESC)
+import {
+  CriteriaFactory,
+  OrderDirection,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema } from './path/to/your/schemas';
+
+const postOrderCriteria = CriteriaFactory.GetCriteria(PostSchema)
+  .orderBy('createdAt', OrderDirection.DESC)
   .orderBy('title', OrderDirection.ASC);
 ```
 
@@ -404,23 +494,27 @@ postCriteria
 To order by a field from a joined entity, call `orderBy()` on the corresponding `JoinCriteria` instance.
 
 ```typescript
-// Get posts, ordered by the author's (publisher) username
-const postsOrderedByAuthorUsername = CriteriaFactory.GetCriteria(
-  PostSchema,
-  'posts',
-).join(
-  CriteriaFactory.GetInnerJoinCriteria(UserSchema, 'publisher').orderBy(
-    'username',
-    OrderDirection.ASC,
-  ), // Ordering on the JoinCriteria
-  { parent_field: 'user_uuid', join_field: 'uuid' },
+import {
+  CriteriaFactory,
+  OrderDirection,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema, UserSchema } from './path/to/your/schemas';
+
+const userJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(
+  UserSchema,
+).orderBy('username', OrderDirection.ASC);
+
+const postsOrderedByAuthor = CriteriaFactory.GetCriteria(PostSchema).join(
+  'user',
+  userJoinCriteria,
+  { parent_field: 'userId', join_field: 'id' },
 );
 
-// You can also combine orderings from the root and joins.
-// The translator will handle applying the global order based on the internal `sequenceId` of each `Order`.
-postsOrderedByAuthorUsername.orderBy('created_at', OrderDirection.DESC);
+postsOrderedByAuthor.orderBy('createdAt', OrderDirection.DESC);
 ```
 
+---
+
 ## 5. Pagination
 
 The library supports offset-based and cursor-based pagination.
@@ -431,167 +525,170 @@ The library supports offset-based and cursor-based pagination.
 - `setSkip(count)`: Skips a number of results (SQL `OFFSET`).
 
 ```typescript
-// Get the first 10 posts
-postCriteria.setTake(10);
+import { CriteriaFactory } from '@nulledexp/translatable-criteria';
+import { PostSchema } from './path/to/your/schemas';
+
+const firstPageCriteria = CriteriaFactory.GetCriteria(PostSchema).setTake(10);
 
-// Get posts from page 3 (assuming 10 per page)
-postCriteria.setTake(10).setSkip(20); // (3-1) * 10
+const thirdPageCriteria = CriteriaFactory.GetCriteria(PostSchema)
+  .setTake(10)
+  .setSkip(20);
 ```
 
 ### Cursor-Based Pagination
 
-This is more efficient for large and frequently changing datasets. Use `setCursor()`.
+This is more efficient for large datasets. Use `setCursor()`.
 
-Requires:
-
-1. `cursorFilters`: An array with one or two `FilterPrimitive` objects (without the `operator`). These define the values of the last item from the previous page. The `value` for these filters can be `null` if the field itself is null, but it cannot be `undefined`.
-
-- If it's a single object, it's used for simple pagination over a unique field (usually an ordered and unique field, or a timestamp).
-- If there are two objects, it's used for composite pagination (keyset pagination), typically over a primary sort field (e.g., `created_at`) and a unique tie-breaker field (e.g., `uuid`).
-
-2. `operator`: `FilterOperator.GREATER_THAN` (for next page) or `FilterOperator.LESS_THAN` (for previous page, if order is inverted).
-3. `order`: The main `OrderDirection` in which pagination is occurring.
-
-**Important:** For cursor-based pagination to work, the `Criteria` (root and/or relevant joins) **must** have `orderBy()` defined for the same fields used in `cursorFilters` and in the same order. The translator will use this information.
+**Important:** For cursor-based pagination to work, the `Criteria` **must** have `orderBy()` defined for the same fields used in `setCursor()` and in the same order.
 
 ```typescript
-// Simple cursor pagination (e.g., on 'created_at')
-// Assume the last seen post had created_at = '2023-05-10T10:00:00.000Z'
-// And we are ordering by created_at ASC
-postCriteria
+import {
+  CriteriaFactory,
+  FilterOperator,
+  OrderDirection,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema } from './path/to/your/schemas';
+
+const simpleCursorCriteria = CriteriaFactory.GetCriteria(PostSchema)
   .setCursor(
-    [{ field: 'created_at', value: '2023-05-10T10:00:00.000Z' }], // Single filter for simple cursor
+    [{ field: 'createdAt', value: '2023-05-10T10:00:00.000Z' }],
     FilterOperator.GREATER_THAN,
     OrderDirection.ASC,
   )
-  .orderBy('created_at', OrderDirection.ASC) // orderBy must match
+  .orderBy('createdAt', OrderDirection.ASC)
   .setTake(10);
 
-// Composite cursor pagination (e.g., on 'created_at' and 'uuid')
-// Assume the last seen post had:
-// created_at = '2023-05-10T10:00:00.000Z'
-// uuid = 'some-last-uuid'
-// And we are ordering by created_at ASC, then uuid ASC
-postCriteria
+const compositeCursorCriteria = CriteriaFactory.GetCriteria(PostSchema)
   .setCursor(
     [
-      // Two filters for composite cursor
-      { field: 'created_at', value: '2023-05-10T10:00:00.000Z' },
-      { field: 'uuid', value: 'some-last-uuid' },
+      { field: 'createdAt', value: '2023-05-10T10:00:00.000Z' },
+      { field: 'id', value: 'some-last-id' },
     ],
     FilterOperator.GREATER_THAN,
     OrderDirection.ASC,
   )
-  .orderBy('created_at', OrderDirection.ASC) // Orderings must match
-  .orderBy('uuid', OrderDirection.ASC)
+  .orderBy('createdAt', OrderDirection.ASC)
+  .orderBy('id', OrderDirection.ASC)
   .setTake(10);
 ```
 
+---
+
 ## 6. Field Selection
 
-By default, a `Criteria` (root or join) will select all fields defined in its schema. You can modify this with `setSelect()` and `resetSelect()`.
+By default, a `Criteria` will select all fields defined in its schema. You can modify this with `setSelect()` and `resetSelect()`.
 
 ### Selection on the Root Entity
 
 ```typescript
-// Select only uuid and email from the user
-userCriteria.setSelect(['uuid', 'email']);
+import { CriteriaFactory } from '@nulledexp/translatable-criteria';
+import { UserSchema } from './path/to/your/schemas';
+
+const userSelectCriteria = CriteriaFactory.GetCriteria(UserSchema).setSelect([
+  'id',
+  'email',
+]);
 ```
 
+**Note:** When `setSelect` is used, the `identifier_field` of the entity is always implicitly included.
+
 ### Selection on Joined Entities
 
 Call `setSelect()` on the `JoinCriteria` instance.
 
 ```typescript
-// Get posts and only the username of their author
+import { CriteriaFactory } from '@nulledexp/translatable-criteria';
+import { PostSchema, UserSchema } from './path/to/your/schemas';
+
+const userJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(
+  UserSchema,
+).setSelect(['username']);
+
 const postsWithAuthorUsernameOnly = CriteriaFactory.GetCriteria(
   PostSchema,
-  'posts',
-).join(
-  CriteriaFactory.GetInnerJoinCriteria(UserSchema, 'publisher').setSelect([
-    'username',
-  ]), // Select only 'username' from the publisher
-  { parent_field: 'user_uuid', join_field: 'uuid' },
-);
+).join('user', userJoinCriteria, { parent_field: 'userId', join_field: 'id' });
 ```
 
 ### Reverting to Select All Fields (`resetSelect`)
 
-If you previously used `setSelect()` and want to revert to the default behavior of selecting all fields from the schema for that `Criteria` instance (root or join):
+If you previously used `setSelect()` and want to revert to the default behavior:
 
 ```typescript
-userCriteria.setSelect(['uuid']); // Selects only uuid
-// ... other operations ...
-userCriteria.resetSelect(); // Now selects all fields from UserSchema again
+import { CriteriaFactory } from '@nulledexp/translatable-criteria';
+import { UserSchema } from './path/to/your/schemas';
+
+const userCriteria = CriteriaFactory.GetCriteria(UserSchema);
+userCriteria.setSelect(['id']);
+userCriteria.resetSelect();
 ```
 
-**Important Note:** If you use `orderBy()` or `setCursor()` on fields that are _not_ included in your `setSelect()`, some translators (like TypeORM's) might automatically add those fields to the selection to ensure correct database operation.
+---
 
 ## 7. Combining Everything
 
-You can chain all these methods to build complex queries:
+You can chain all these methods to build complex queries. The following example demonstrates how to combine multiple features, including nested joins, filtering on both root and joined entities, field selection, and cursor-based pagination, to construct a sophisticated query specification.
 
 ```typescript
-// Complex example:
-// Get the 5 most recent posts (ordered by created_at DESC)
-// that contain "TypeORM" in the title or body,
-// including their author's (publisher) username and only the text of their comments (if any),
-// and the author (publisher) has the email "author@example.com".
-// Also, paginate using cursor if 'lastPostCreatedAt' and 'lastPostUuid' are defined.
-
-let lastPostCreatedAt: string | undefined = undefined; // '2023-10-26T12:00:00.000Z';
-let lastPostUuid: string | undefined = undefined; // 'a1b2c3d4-e5f6-7890-1234-567890abcdef';
-
-const complexPostCriteria = CriteriaFactory.GetCriteria(PostSchema, 'posts')
-  .setSelect(['uuid', 'title', 'created_at']) // Select specific post fields
+import {
+  CriteriaFactory,
+  FilterOperator,
+  OrderDirection,
+} from '@nulledexp/translatable-criteria';
+import { UserSchema, PostSchema, RoleSchema } from './path/to/your/schemas';
+
+let lastPostCreatedAt: string | undefined = undefined;
+let lastPostUuid: string | undefined = undefined;
+
+// 1. Define the criteria for the innermost join (Roles)
+const roleJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(RoleSchema).where(
+  {
+    field: 'name',
+    operator: FilterOperator.EQUALS,
+    value: 'admin',
+  },
+);
+
+// 2. Define the criteria for the intermediate join (Users) and add the nested join to it
+const userWithRolesJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(
+  UserSchema,
+).join('roles', roleJoinCriteria, {
+  pivot_source_name: 'user_roles',
+  parent_field: { pivot_field: 'user_id', reference: 'id' },
+  join_field: { pivot_field: 'role_id', reference: 'id' },
+});
+
+// 3. Build the main criteria (Posts)
+const complexPostCriteria = CriteriaFactory.GetCriteria(PostSchema)
+  .setSelect(['id', 'title', 'createdAt'])
   .where({
     field: 'title',
     operator: FilterOperator.CONTAINS,
     value: 'TypeORM',
   })
-  .orWhere({
-    field: 'body',
-    operator: FilterOperator.CONTAINS,
-    value: 'TypeORM',
+  // 4. Add the pre-configured user join to the main criteria
+  .join('user', userWithRolesJoinCriteria, {
+    parent_field: 'userId',
+    join_field: 'id',
   })
-  .join(
-    CriteriaFactory.GetInnerJoinCriteria(UserSchema, 'publisher')
-      .setSelect(['username']) // Only the author's username
-      .where({
-        field: 'email',
-        operator: FilterOperator.EQUALS,
-        value: 'author@example.com',
-      }),
-    { parent_field: 'user_uuid', join_field: 'uuid' },
-  )
-  .join(
-    CriteriaFactory.GetLeftJoinCriteria(
-      PostCommentSchema,
-      'comments',
-    ).setSelect(['comment_text']), // Only the comment text
-    { parent_field: 'uuid', join_field: 'post_uuid' },
-  )
-  .orderBy('created_at', OrderDirection.DESC) // Main order for cursor pagination
-  .orderBy('uuid', OrderDirection.DESC); // Tie-breaker for cursor pagination
+  .orderBy('createdAt', OrderDirection.DESC)
+  .orderBy('id', OrderDirection.DESC);
 
 if (lastPostCreatedAt && lastPostUuid) {
   complexPostCriteria.setCursor(
     [
-      { field: 'created_at', value: lastPostCreatedAt },
-      { field: 'uuid', value: lastPostUuid },
+      { field: 'createdAt', value: lastPostCreatedAt },
+      { field: 'id', value: lastPostUuid },
     ],
-    FilterOperator.LESS_THAN, // Because we order DESC for "most recent"
+    FilterOperator.LESS_THAN,
     OrderDirection.DESC,
   );
 }
 
 complexPostCriteria.setTake(5);
-
-// 'complexPostCriteria' is now ready to be passed to a translator.
 ```
 
 ## Next Steps
 
-With the criteria built, the next step is to use a `CriteriaTranslator` to convert these
-`Criteria` objects into a native query for your database. Refer to the guide on Developing
-Custom Translators or use an existing translator if available for your stack.
+With the criteria built, the next step is to use a [`CriteriaTranslator`](../developing-translators/en.md) to convert these
+`Criteria` objects into a native query for your database. [Refer to the guide on Developing
+Custom Translators](../developing-translators/en.md) or use an existing translator if available for your stack.
diff --git a/src/docs/guides/building-criteria/es.md b/src/docs/guides/building-criteria/es.md
index 0b53368..8d31362 100644
--- a/src/docs/guides/building-criteria/es.md
+++ b/src/docs/guides/building-criteria/es.md
@@ -12,11 +12,12 @@ Esta gua te mostrar cmo utilizar `CriteriaFactory` y los mtodos fluidos
   - [Agrupacin Lgica (AND/OR)](#agrupacin-lgica-andor)
   - [Filtros Avanzados (JSON, Array, Set)](#filtros-avanzados-json-array-set)
     - [Filtrando Campos JSON (`JSON_CONTAINS`, `JSON_NOT_CONTAINS`)](#filtrando-campos-json-json_contains-json_not_contains)
-    - [Filtrando Campos Array (`ARRAY_CONTAINS_ELEMENT`, etc.)](#filtrando-campos-array-array_contains_element-array_contains_all_elements-array_contains_any_element-array_equals)
+    - [Filtrando Campos Array (`ARRAY_CONTAINS_ELEMENT`, etc.)](#filtrando-campos-array-array_contains_element-etc)
     - [Filtrando Campos SET (`SET_CONTAINS`, `SET_NOT_CONTAINS`, `SET_CONTAINS_ANY`, `SET_CONTAINS_ALL`)](#filtrando-campos-set-set_contains-set_not_contains-set_contains_any-set_contains_all)
     - [Filtrando por Rangos (`BETWEEN`, `NOT_BETWEEN`)](#filtrando-por-rangos-between-not_between)
     - [Filtrando con Expresiones Regulares (`MATCHES_REGEX`)](#filtrando-con-expresiones-regulares-matches_regex)
     - [Coincidencia de Patrones Insensible a Maysculas/Minsculas (`ILIKE`, `NOT_ILIKE`)](#coincidencia-de-patrones-insensible-a-maysculasminsculas-ilike-not_ilike)
+  - [Referencia de Operadores de Filtro](#referencia-de-operadores-de-filtro)
 - 3. [Aadiendo Uniones (Joins)](#3-aadiendo-uniones-joins)
   - [Uniones Simples (one-to-many, many-to-one, one-to-one)](#uniones-simples-one-to-many-many-to-one-one-to-one)
   - [Uniones con Tabla Pivote (many-to-many)](#uniones-con-tabla-pivote-many-to-many)
@@ -36,23 +37,86 @@ Esta gua te mostrar cmo utilizar `CriteriaFactory` y los mtodos fluidos
 
 ---
 
+## Esquemas de Ejemplo
+
+Para hacer los ejemplos de esta gua autocontenidos, utilizaremos los siguientes esquemas simplificados:
+
+```typescript
+import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
+
+export const UserSchema = GetTypedCriteriaSchema({
+  source_name: 'users',
+  alias: 'u',
+  fields: ['id', 'username', 'email', 'age', 'isActive', 'createdAt', 'tags'],
+  identifier_field: 'id',
+  joins: [
+    {
+      alias: 'posts',
+      target_source_name: 'posts',
+      relation_type: 'one_to_many',
+    },
+    {
+      alias: 'roles',
+      target_source_name: 'roles',
+      relation_type: 'many_to_many',
+    },
+  ],
+});
+
+export const PostSchema = GetTypedCriteriaSchema({
+  source_name: 'posts',
+  alias: 'p',
+  fields: [
+    'id',
+    'title',
+    'content',
+    'userId',
+    'createdAt',
+    'categories',
+    'metadata',
+  ],
+  identifier_field: 'id',
+  joins: [
+    {
+      alias: 'user',
+      target_source_name: 'users',
+      relation_type: 'many_to_one',
+    },
+  ],
+});
+
+export const RoleSchema = GetTypedCriteriaSchema({
+  source_name: 'roles',
+  alias: 'r',
+  fields: ['id', 'name'],
+  identifier_field: 'id',
+  joins: [],
+});
+
+export const ProductSchema = GetTypedCriteriaSchema({
+  source_name: 'products',
+  alias: 'prod',
+  fields: ['id', 'name', 'price', 'createdAt'],
+  identifier_field: 'id',
+  joins: [],
+});
+```
+
+---
+
 ## 1. Creando un `RootCriteria`
 
-Toda consulta comienza con un `RootCriteria`, que representa la entidad principal desde la cual se iniciar la consulta. Se crea utilizando `CriteriaFactory.GetCriteria()`:
+Toda consulta comienza con un `RootCriteria`, que representa la entidad principal desde la cual se iniciar la consulta. Se crea utilizando `CriteriaFactory.GetCriteria()`. El alias ahora se toma directamente de la propiedad `alias` del esquema proporcionado.
 
 ```typescript
 import { CriteriaFactory } from '@nulledexp/translatable-criteria';
-import { UserSchema, PostSchema } from './path/to/your/schemas'; // Asegrate de que la ruta sea correcta
-
-// Crear un Criteria para la entidad User, usando el alias 'users'
-const userCriteria = CriteriaFactory.GetCriteria(UserSchema, 'users');
+import { UserSchema, PostSchema } from './path/to/your/schemas';
 
-// Crear un Criteria para la entidad Post, usando el alias 'posts'
-const postCriteria = CriteriaFactory.GetCriteria(PostSchema, 'posts');
+const userCriteria = CriteriaFactory.GetCriteria(UserSchema);
+const postCriteria = CriteriaFactory.GetCriteria(PostSchema);
 ```
 
-- El primer argumento es el esquema de la entidad (`UserSchema`, `PostSchema`).
-- El segundo argumento es uno de los alias definidos en el `alias` array de ese esquema. Usar el alias correcto es crucial para la correcta interpretacin por parte de los traductores.
+---
 
 ## 2. Aplicando Filtros
 
@@ -61,25 +125,26 @@ Los filtros se aaden usando los mtodos `where()`, `andWhere()`, y `orWhere()
 ### Filtros Bsicos
 
 ```typescript
-import { FilterOperator } from '@nulledexp/translatable-criteria';
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { UserSchema, PostSchema } from './path/to/your/schemas';
 
-// Encontrar usuarios con un email especfico
-userCriteria.where({
-  field: 'email', // Campo del UserSchema
+const userEmailCriteria = CriteriaFactory.GetCriteria(UserSchema).where({
+  field: 'email',
   operator: FilterOperator.EQUALS,
   value: 'test@example.com',
 });
 
-// Encontrar posts cuyo ttulo contenga "TypeScript"
-postCriteria.where({
-  field: 'title', // Campo del PostSchema
-  operator: FilterOperator.CONTAINS, // o FilterOperator.LIKE con '%'
-  value: '%TypeScript%',
+const postTitleCriteria = CriteriaFactory.GetCriteria(PostSchema).where({
+  field: 'title',
+  operator: FilterOperator.CONTAINS,
+  value: 'TypeScript',
 });
 
-// Encontrar posts creados despus de una fecha especfica
-postCriteria.where({
-  field: 'created_at',
+const postDateCriteria = CriteriaFactory.GetCriteria(PostSchema).where({
+  field: 'createdAt',
   operator: FilterOperator.GREATER_THAN,
   value: new Date('2023-01-01'),
 });
@@ -91,8 +156,13 @@ postCriteria.where({
 - `orWhere()`: Aade una condicin que, si se cumple, hace que el grupo de filtros sea verdadero, incluso si las condiciones previas (agrupadas por AND) no lo son (OR lgico). La librera normaliza esto para mantener una estructura de `OR ( (cond1 AND cond2), (cond3) )`.
 
 ```typescript
-// Usuarios cuyo username es 'admin' Y su email contiene '@example.com'
-userCriteria
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { UserSchema, PostSchema } from './path/to/your/schemas';
+
+const adminUserCriteria = CriteriaFactory.GetCriteria(UserSchema)
   .where({ field: 'username', operator: FilterOperator.EQUALS, value: 'admin' })
   .andWhere({
     field: 'email',
@@ -100,22 +170,19 @@ userCriteria
     value: '@example.com',
   });
 
-// Posts que contienen "Tutorial" en el ttulo O en el cuerpo del post
-postCriteria
+const tutorialPostCriteria = CriteriaFactory.GetCriteria(PostSchema)
   .where({
     field: 'title',
     operator: FilterOperator.CONTAINS,
     value: 'Tutorial',
   })
   .orWhere({
-    field: 'body',
+    field: 'content',
     operator: FilterOperator.CONTAINS,
     value: 'Tutorial',
   });
 
-// Combinacin ms compleja:
-// (username = 'editor' AND email LIKE '%@editor.com%') OR (username = 'guest')
-userCriteria
+const editorOrGuestCriteria = CriteriaFactory.GetCriteria(UserSchema)
   .where({
     field: 'username',
     operator: FilterOperator.EQUALS,
@@ -123,8 +190,8 @@ userCriteria
   })
   .andWhere({
     field: 'email',
-    operator: FilterOperator.LIKE,
-    value: '%@editor.com%',
+    operator: FilterOperator.CONTAINS,
+    value: '@editor.com',
   })
   .orWhere({
     field: 'username',
@@ -135,38 +202,31 @@ userCriteria
 
 ### Filtros Avanzados (JSON, Array, Set)
 
-La librera soporta operadores para tipos de datos ms complejos como JSON, arrays y campos tipo SET.
+La librera soporta una amplia gama de operadores para tipos de datos complejos. Para una lista completa, consulta la gua de Conceptos Clave. Aqu tienes algunos ejemplos:
 
 #### Filtrando Campos JSON (`JSON_CONTAINS`, `JSON_NOT_CONTAINS`)
 
 El valor para estos operadores es un objeto donde las claves son rutas JSON (el traductor determinar si necesita `$.` al inicio) y los valores son lo que se busca en esa ruta.
 
 ```typescript
-// Suponiendo que PostSchema tiene un campo 'metadata' de tipo JSON
-// con una estructura como: { tags: ["tech", "code"], views: 100 }
-
-// Encontrar posts donde metadata.tags contenga "tech" Y metadata.views sea 100
-postCriteria.where({
-  field: 'metadata', // El campo JSON
-  operator: FilterOperator.JSON_CONTAINS,
-  value: {
-    tags: 'tech', // Busca "tech" dentro del array metadata.tags
-    views: 100, // Busca que metadata.views sea 100
-    // "extra.source": "import" // Tambin puedes anidar rutas
-  },
-});
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema } from './path/to/your/schemas';
 
-// Encontrar posts donde metadata.extra.quality NO sea "low"
-postCriteria.where({
+const jsonCriteria = CriteriaFactory.GetCriteria(PostSchema).where({
   field: 'metadata',
-  operator: FilterOperator.JSON_NOT_CONTAINS,
+  operator: FilterOperator.JSON_CONTAINS,
   value: {
-    'extra.quality': 'low',
+    tags: 'tech',
+    views: 100,
+    'extra.source': 'import',
   },
 });
 ```
 
-#### Filtrando Campos Array (`ARRAY_CONTAINS_ELEMENT`, `ARRAY_CONTAINS_ALL_ELEMENTS`, `ARRAY_CONTAINS_ANY_ELEMENT`, `ARRAY_EQUALS`)
+#### Filtrando Campos Array (`ARRAY_CONTAINS_ELEMENT`, etc.)
 
 Estos operadores pueden usarse para campos que son arrays nativos o arrays dentro de JSON.
 
@@ -174,39 +234,16 @@ Estos operadores pueden usarse para campos que son arrays nativos o arrays dentr
 - **Para arrays dentro de JSON:** El `value` es un objeto con una nica clave (la ruta JSON al array) y el valor es el elemento o array de elementos.
 
 ```typescript
-// 1. Columna de Array Nativo: Encontrar posts que tengan la categora "TypeScript"
-postCriteria.where({
-  field: 'categories',
-  operator: FilterOperator.ARRAY_CONTAINS_ELEMENT,
-  value: 'TypeScript',
-});
-
-// 2. Array dentro de JSON: Encontrar posts donde metadata.tags contenga "typeorm"
-postCriteria.where({
-  field: 'metadata', // Campo JSON principal
-  operator: FilterOperator.ARRAY_CONTAINS_ELEMENT,
-  value: { tags: 'typeorm' }, // { "ruta.al.array": elemento }
-});
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema } from './path/to/your/schemas';
 
-// 3. Columna de Array Nativo: Encontrar posts que tengan TODAS las categoras ["nestjs", "api"]
-postCriteria.where({
+const arrayCriteria = CriteriaFactory.GetCriteria(PostSchema).where({
   field: 'categories',
-  operator: FilterOperator.ARRAY_CONTAINS_ALL_ELEMENTS,
-  value: ['nestjs', 'api'],
-});
-
-// 4. Array dentro de JSON: Encontrar posts donde metadata.ratings contenga AL MENOS UNO de [4, 5]
-postCriteria.where({
-  field: 'metadata',
   operator: FilterOperator.ARRAY_CONTAINS_ANY_ELEMENT,
-  value: { ratings: [4, 5] },
-});
-
-// 5. Columna de Array Nativo: Encontrar posts cuyas categoras sean EXACTAMENTE ["news", "updates"] (orden importa)
-postCriteria.where({
-  field: 'categories',
-  operator: FilterOperator.ARRAY_EQUALS,
-  value: ['news', 'updates'],
+  value: ['nestjs', 'api'],
 });
 ```
 
@@ -215,28 +252,16 @@ postCriteria.where({
 Similar a `CONTAINS` pero conceptualmente para campos que representan un conjunto de valores (como el tipo `SET` de MySQL o un string delimitado).
 
 ```typescript
-// Suponiendo un campo 'flags' en UserSchema que es un SET('active', 'verified', 'beta_tester')
-// o un campo de texto 'tags' como "typescript,javascript,nodejs"
-
-// Busca usuarios que tengan el flag 'verified'
-userCriteria.where({
-  field: 'flags',
-  operator: FilterOperator.SET_CONTAINS,
-  value: 'verified',
-});
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { UserSchema } from './path/to/your/schemas';
 
-// Busca usuarios que tengan AL MENOS UNO de los tags "typescript" o "javascript"
-userCriteria.where({
+const setCriteria = CriteriaFactory.GetCriteria(UserSchema).where({
   field: 'tags',
   operator: FilterOperator.SET_CONTAINS_ANY,
-  value: ['typescript', 'javascript'], // Espera un array de valores
-});
-
-// Busca usuarios que tengan TODOS los flags "active" Y "beta_tester"
-userCriteria.where({
-  field: 'flags',
-  operator: FilterOperator.SET_CONTAINS_ALL,
-  value: ['active', 'beta_tester'], // Espera un array de valores
+  value: ['typescript', 'javascript'],
 });
 ```
 
@@ -245,15 +270,21 @@ userCriteria.where({
 Estos operadores permiten verificar si un valor numrico o de fecha se encuentra dentro o fuera de un rango especfico.
 
 ```typescript
-// Encontrar posts creados entre dos fechas
-postCriteria.where({
-  field: 'created_at',
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema, ProductSchema } from './path/to/your/schemas';
+
+const betweenDatesCriteria = CriteriaFactory.GetCriteria(PostSchema).where({
+  field: 'createdAt',
   operator: FilterOperator.BETWEEN,
-  value: [new Date('2023-01-01'), new Date('2023-03-31')], // [min, max]
+  value: [new Date('2023-01-01'), new Date('2023-03-31')],
 });
 
-// Encontrar productos cuyo precio NO est entre 100 y 200
-productCriteria.where({
+const notBetweenPriceCriteria = CriteriaFactory.GetCriteria(
+  ProductSchema,
+).where({
   field: 'price',
   operator: FilterOperator.NOT_BETWEEN,
   value: [100, 200],
@@ -265,12 +296,16 @@ productCriteria.where({
 Permite realizar bsquedas de patrones ms potentes utilizando expresiones regulares. La sintaxis especfica de la expresin regular puede depender de la base de datos subyacente.
 
 ```typescript
-// Encontrar usuarios cuyo username comience con "admin" seguido de nmeros
-// (ejemplo conceptual, la sintaxis REGEX vara)
-userCriteria.where({
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { UserSchema } from './path/to/your/schemas';
+
+const regexCriteria = CriteriaFactory.GetCriteria(UserSchema).where({
   field: 'username',
   operator: FilterOperator.MATCHES_REGEX,
-  value: '^admin[0-9]+', // La expresin regular como string
+  value: '^admin[0-9]+',
 });
 ```
 
@@ -279,109 +314,162 @@ userCriteria.where({
 Similares a `LIKE` y `NOT_LIKE`, pero garantizan que la comparacin de patrones sea insensible a maysculas y minsculas, independientemente de la configuracin por defecto de la base de datos.
 
 ```typescript
-// Encontrar posts cuyo ttulo contenga "typescript" (sin importar maysculas/minsculas)
-postCriteria.where({
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema } from './path/to/your/schemas';
+
+const ilikeCriteria = CriteriaFactory.GetCriteria(PostSchema).where({
   field: 'title',
   operator: FilterOperator.ILIKE,
   value: '%typescript%',
 });
-
-// Encontrar usuarios cuyo email NO comience con "test" (insensible a maysculas/minsculas)
-userCriteria.where({
-  field: 'email',
-  operator: FilterOperator.NOT_ILIKE,
-  value: 'test%',
-});
 ```
 
+### Referencia de Operadores de Filtro
+
+Aqu tienes una lista detallada de los valores de `FilterOperator` disponibles y el tipo de `value` que esperan.
+
+#### Igualdad y Comparacin
+
+- `EQUALS`: Comprueba la igualdad exacta. Espera un valor primitivo (`string`, `number`, `boolean`, `Date`, `null`).
+- `NOT_EQUALS`: Comprueba la desigualdad. Espera un valor primitivo.
+- `GREATER_THAN`: Comprueba si un valor es mayor que el proporcionado. Espera un `number` o `Date`.
+- `GREATER_THAN_OR_EQUALS`: Comprueba si un valor es mayor o igual que el proporcionado. Espera un `number` o `Date`.
+- `LESS_THAN`: Comprueba si un valor es menor que el proporcionado. Espera un `number` o `Date`.
+- `LESS_THAN_OR_EQUALS`: Comprueba si un valor es menor o igual que el proporcionado. Espera un `number` o `Date`.
+
+#### Coincidencia de Patrones
+
+- `LIKE`: Coincide con un patrn (la sensibilidad a maysculas/minsculas depende de la base de datos). Espera un `string`. El traductor es responsable de manejar los comodines (`%`, `_`).
+- `NOT_LIKE`: Comprueba si un valor no coincide con un patrn. Espera un `string`.
+- `CONTAINS`: Comprueba si una cadena contiene una subcadena. Espera un `string`. El traductor tpicamente envolver el valor con comodines (ej. `'%valor%'`).
+- `NOT_CONTAINS`: Comprueba si una cadena no contiene una subcadena. Espera un `string`.
+- `STARTS_WITH`: Comprueba si una cadena comienza con una subcadena especfica. Espera un `string`. El traductor tpicamente aadir un comodn al final (ej. `'valor%'`).
+- `ENDS_WITH`: Comprueba si una cadena termina con una subcadena especfica. Espera un `string`. El traductor tpicamente aadir un comodn al principio (ej. `'%valor'`).
+- `ILIKE`: Versin de `LIKE` insensible a maysculas/minsculas. Espera un `string`.
+- `NOT_ILIKE`: Versin de `NOT_LIKE` insensible a maysculas/minsculas. Espera un `string`.
+
+#### Pertenencia y Nulidad
+
+- `IN`: Comprueba si un valor est dentro de un array dado. Espera un `Array<string | number | boolean | Date>`.
+- `NOT_IN`: Comprueba si un valor no est dentro de un array dado. Espera un `Array<string | number | boolean | Date>`.
+- `IS_NULL`: Comprueba si un valor es `NULL`. La propiedad `value` debe ser `null` o `undefined`.
+- `IS_NOT_NULL`: Comprueba si un valor no es `NULL`. La propiedad `value` debe ser `null` o `undefined`.
+
+#### Rangos y Regex
+
+- `BETWEEN`: Comprueba si un valor est dentro de un rango especificado (inclusivo). Espera una tupla de dos valores: `[min, max]`.
+- `NOT_BETWEEN`: Comprueba si un valor est fuera de un rango especificado. Espera una tupla de dos valores: `[min, max]`.
+- `MATCHES_REGEX`: Comprueba si un valor de tipo string coincide con una expresin regular. Espera un `string` que representa el patrn de la regex.
+
+#### Tipos Complejos (JSON, Array, SET)
+
+- **Operadores JSON**
+- `JSON_CONTAINS`: Comprueba si un documento JSON contiene una estructura o valor especfico en una ruta dada. Espera un objeto donde las claves son rutas JSON y los valores son los datos a encontrar (ej. `{ "tags": "tech", "views": 100 }`).
+- `JSON_NOT_CONTAINS`: La inversa de `JSON_CONTAINS`.
+- **Operadores de Array**
+- `ARRAY_CONTAINS_ELEMENT`: Comprueba si un array contiene un elemento especfico. Para columnas de array nativo, espera un valor primitivo. Para arrays en JSON, espera un objeto como `{ "ruta.al.array": valorElemento }`.
+- `ARRAY_CONTAINS_ALL_ELEMENTS`: Comprueba si un array contiene todos los elementos de un array dado. Espera un `Array<primitivo>` o `{ "ruta.al.array": [elementos] }`.
+- `ARRAY_CONTAINS_ANY_ELEMENT`: Comprueba si un array contiene al menos un elemento de un array dado. Espera un `Array<primitivo>` o `{ "ruta.al.array": [elementos] }`.
+- `ARRAY_EQUALS`: Comprueba si un array es exactamente igual a un array dado (orden y elementos). Espera un `Array<primitivo>` o `{ "ruta.al.array": [elementos] }`.
+- **Operadores SET** (Conceptualmente para conjuntos, a menudo usados en campos de string o array)
+- `SET_CONTAINS`: Comprueba si un conjunto contiene un valor especfico. Espera un `string`.
+- `SET_NOT_CONTAINS`: La inversa de `SET_CONTAINS`.
+- `SET_CONTAINS_ANY`: Comprueba si un conjunto contiene al menos uno de los valores especificados. Espera un `Array<string>`.
+- `SET_CONTAINS_ALL`: Comprueba si un conjunto contiene todos los valores especificados. Espera un `Array<string>`.
+
+---
+
 ## 3. Aadiendo Uniones (Joins)
 
-Las uniones se aaden con el mtodo `join()`. Este mtodo toma dos argumentos:
+Las uniones se aaden con el mtodo `join()`. La firma de este mtodo se ha actualizado para mayor claridad y seguridad de tipos:
+
+`criteria.join(joinAlias, criteriaToJoin, joinParameters)`
 
-1.  Una instancia de un `Criteria` de join (`InnerJoinCriteria`, `LeftJoinCriteria`, `OuterJoinCriteria`), creada tambin con `CriteriaFactory`.
-2.  Un objeto de parmetros de join que define cmo se relacionan las entidades.
+- **`joinAlias` (string):** Es el **alias de la relacin** tal como se define en el array `joins` dentro del _esquema padre_. Acta como un identificador nico para esa configuracin de relacin especfica. La librera utiliza este `joinAlias` junto con el `source_name` de `criteriaToJoin` (el esquema de la entidad que se est uniendo) para encontrar la definicin exacta de la relacin en el esquema padre.
+- **`criteriaToJoin` (JoinCriteria):** Una instancia de un `Criteria` de join (`InnerJoinCriteria`, `LeftJoinCriteria`, etc.), creada con `CriteriaFactory`.
+- **`joinParameters` (object):** Un objeto que define cmo se relacionan las entidades (`parent_field`, `join_field`, etc.).
 
 ### Uniones Simples (one-to-many, many-to-one, one-to-one)
 
 Para estas relaciones, los parmetros de join son `parent_field` y `join_field`.
 
 ```typescript
-// Obtener posts y su autor (publisher)
-// PostSchema define un join 'publisher' (many-to-one) con UserSchema
-const postsWithAuthorCriteria = CriteriaFactory.GetCriteria(
-  PostSchema,
-  'posts',
-).join(
-  CriteriaFactory.GetInnerJoinCriteria(UserSchema, 'publisher'), // 'publisher' es un alias en UserSchema
+import { CriteriaFactory } from '@nulledexp/translatable-criteria';
+import { UserSchema, PostSchema } from './path/to/your/schemas';
+
+const postsWithAuthorCriteria = CriteriaFactory.GetCriteria(PostSchema).join(
+  'user',
+  CriteriaFactory.GetInnerJoinCriteria(UserSchema),
   {
-    parent_field: 'user_uuid', // Campo FK en PostSchema
-    join_field: 'uuid', // Campo PK en UserSchema (el 'publisher')
+    parent_field: 'userId',
+    join_field: 'id',
   },
 );
 
-// Obtener usuarios y sus posts
-// UserSchema define un join 'posts' (one-to-many) con PostSchema
-const usersWithPostsCriteria = CriteriaFactory.GetCriteria(
-  UserSchema,
-  'users',
-).join(
-  CriteriaFactory.GetLeftJoinCriteria(PostSchema, 'posts'), // 'posts' es un alias en PostSchema
+const usersWithPostsCriteria = CriteriaFactory.GetCriteria(UserSchema).join(
+  'posts',
+  CriteriaFactory.GetLeftJoinCriteria(PostSchema),
   {
-    parent_field: 'uuid', // Campo PK en UserSchema
-    join_field: 'user_uuid', // Campo FK en PostSchema
+    parent_field: 'id',
+    join_field: 'userId',
   },
 );
 ```
 
-**Nota:** El `alias` usado en `GetInnerJoinCriteria` (ej. `'publisher'`) debe ser uno de los `alias` definidos en el esquema de la entidad a la que se une (en este caso, `UserSchema`). La librera valida esto.
-
 ### Uniones con Tabla Pivote (many-to-many)
 
-Para relaciones `many_to_many`, los parmetros de join requieren un objeto ms detallado que incluye `pivot_source_name` y objetos para `parent_field` y `join_field` que especifican tanto el campo en la entidad como el campo en la tabla pivote.
+Para relaciones `many_to_many`, los parmetros de join requieren un objeto ms detallado que incluye `pivot_source_name` y objetos para `parent_field` y `join_field`.
 
 ```typescript
-// Obtener usuarios y sus permisos
-// UserSchema define un join 'permissions' (many-to-many) con PermissionSchema
-const usersWithPermissionsCriteria = CriteriaFactory.GetCriteria(
-  UserSchema,
-  'users',
-).join(CriteriaFactory.GetInnerJoinCriteria(PermissionSchema, 'permissions'), {
-  pivot_source_name: 'user_permission_pivot', // Nombre de tu tabla pivote
-  parent_field: {
-    pivot_field: 'user_id_in_pivot', // FK del User en la tabla pivote
-    reference: 'uuid', // PK del User
-  },
-  join_field: {
-    pivot_field: 'permission_id_in_pivot', // FK del Permission en la tabla pivote
-    reference: 'uuid', // PK del Permission
+import { CriteriaFactory } from '@nulledexp/translatable-criteria';
+import { UserSchema, RoleSchema } from './path/to/your/schemas';
+
+const usersWithRolesCriteria = CriteriaFactory.GetCriteria(UserSchema).join(
+  'roles',
+  CriteriaFactory.GetInnerJoinCriteria(RoleSchema),
+  {
+    pivot_source_name: 'user_roles',
+    parent_field: { pivot_field: 'user_id', reference: 'id' },
+    join_field: { pivot_field: 'role_id', reference: 'id' },
   },
-});
+);
 ```
 
 ### Filtrando en Entidades Unidas
 
-Puedes aplicar filtros directamente al `Criteria` de join:
+Puedes aplicar filtros directamente a la instancia del `JoinCriteria` antes de pasarla al mtodo `.join()`.
 
 ```typescript
-// Obtener posts y solo los comentarios que NO contengan "spam"
-const postsWithFilteredComments = CriteriaFactory.GetCriteria(
-  PostSchema,
-  'posts',
-).join(
-  CriteriaFactory.GetLeftJoinCriteria(PostCommentSchema, 'comments').where({
-    // Filtro aplicado al JoinCriteria (comments)
-    field: 'comment_text',
-    operator: FilterOperator.NOT_CONTAINS,
-    value: 'spam',
-  }),
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema, UserSchema } from './path/to/your/schemas';
+
+const activeUserJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(
+  UserSchema,
+).where({
+  field: 'isActive',
+  operator: FilterOperator.EQUALS,
+  value: true,
+});
+
+const postsFromActiveUsers = CriteriaFactory.GetCriteria(PostSchema).join(
+  'user',
+  activeUserJoinCriteria,
   {
-    parent_field: 'uuid',
-    join_field: 'post_uuid',
+    parent_field: 'userId',
+    join_field: 'id',
   },
 );
 ```
 
-Estos filtros en el `JoinCriteria` tpicamente se traducen a condiciones en la clusula `ON` del JOIN (o `AND` despus del `ON` para algunos traductores/bases de datos).
+Estos filtros en el `JoinCriteria` tpicamente se traducen a condiciones en la clusula `ON` del JOIN.
+
+---
 
 ## 4. Ordenando Resultados
 
@@ -390,12 +478,14 @@ El ordenamiento se aplica con el mtodo `orderBy()`, que toma el nombre del cam
 ### Ordenando por Campos de la Entidad Raz
 
 ```typescript
-// Obtener usuarios ordenados por email ascendente
-userCriteria.orderBy('email', OrderDirection.ASC);
-
-// Obtener posts ordenados por fecha de creacin descendente, luego por ttulo ascendente
-postCriteria
-  .orderBy('created_at', OrderDirection.DESC)
+import {
+  CriteriaFactory,
+  OrderDirection,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema } from './path/to/your/schemas';
+
+const postOrderCriteria = CriteriaFactory.GetCriteria(PostSchema)
+  .orderBy('createdAt', OrderDirection.DESC)
   .orderBy('title', OrderDirection.ASC);
 ```
 
@@ -404,23 +494,27 @@ postCriteria
 Para ordenar por un campo de una entidad unida, llama a `orderBy()` en la instancia del `JoinCriteria` correspondiente.
 
 ```typescript
-// Obtener posts, ordenados por el username del autor (publisher)
-const postsOrderedByAuthorUsername = CriteriaFactory.GetCriteria(
-  PostSchema,
-  'posts',
-).join(
-  CriteriaFactory.GetInnerJoinCriteria(UserSchema, 'publisher').orderBy(
-    'username',
-    OrderDirection.ASC,
-  ), // Ordenamiento en el JoinCriteria
-  { parent_field: 'user_uuid', join_field: 'uuid' },
+import {
+  CriteriaFactory,
+  OrderDirection,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema, UserSchema } from './path/to/your/schemas';
+
+const userJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(
+  UserSchema,
+).orderBy('username', OrderDirection.ASC);
+
+const postsOrderedByAuthor = CriteriaFactory.GetCriteria(PostSchema).join(
+  'user',
+  userJoinCriteria,
+  { parent_field: 'userId', join_field: 'id' },
 );
 
-// Tambin puedes combinar ordenamientos de la raz y de los joins.
-// El traductor se encargar de aplicar el orden global segn el `sequenceId` interno de cada `Order`.
-postsOrderedByAuthorUsername.orderBy('created_at', OrderDirection.DESC);
+postsOrderedByAuthor.orderBy('createdAt', OrderDirection.DESC);
 ```
 
+---
+
 ## 5. Paginacin
 
 La librera soporta paginacin basada en offset y basada en cursor.
@@ -431,165 +525,168 @@ La librera soporta paginacin basada en offset y basada en cursor.
 - `setSkip(count)`: Omite un nmero de resultados (SQL `OFFSET`).
 
 ```typescript
-// Obtener los primeros 10 posts
-postCriteria.setTake(10);
+import { CriteriaFactory } from '@nulledexp/translatable-criteria';
+import { PostSchema } from './path/to/your/schemas';
+
+const firstPageCriteria = CriteriaFactory.GetCriteria(PostSchema).setTake(10);
 
-// Obtener posts de la pgina 3 (asumiendo 10 por pgina)
-postCriteria.setTake(10).setSkip(20); // (3-1) * 10
+const thirdPageCriteria = CriteriaFactory.GetCriteria(PostSchema)
+  .setTake(10)
+  .setSkip(20);
 ```
 
 ### Paginacin Basada en Cursor
 
-Es ms eficiente para conjuntos de datos grandes y que cambian frecuentemente. Se usa `setCursor()`.
+Es ms eficiente para grandes conjuntos de datos. Se usa `setCursor()`.
 
-Requiere:
-
-1.  `cursorFilters`: Un array con uno o dos objetos `FilterPrimitive` (sin el `operator`). Estos definen los valores del ltimo tem de la pgina anterior. El `value` para estos filtros puede ser `null` si el campo en s es nulo, pero no puede ser `undefined`.
-
-- Si es un solo objeto, se usa para paginacin simple sobre un campo nico (generalmente un campo ordenado y nico, o un timestamp).
-- Si son dos objetos, se usa para paginacin compuesta (keyset pagination), tpicamente sobre un campo de ordenamiento primario (ej. `created_at`) y un campo de desempate nico (ej. `uuid`).
-
-2.  `operator`: `FilterOperator.GREATER_THAN` (para pgina siguiente) o `FilterOperator.LESS_THAN` (para pgina anterior, si se invierte el orden).
-3.  `order`: La `OrderDirection` principal en la que se est paginando.
-
-**Importante:** Para que la paginacin por cursor funcione, el `Criteria` (raz y/o joins relevantes) **debe** tener `orderBy()` definidos para los mismos campos que se usan en `cursorFilters` y en el mismo orden. El traductor utilizar esta informacin.
+**Importante:** Para que la paginacin por cursor funcione, el `Criteria` **debe** tener `orderBy()` definidos para los mismos campos que se usan en `setCursor()` y en el mismo orden.
 
 ```typescript
-// Paginacin por cursor simple (ej. sobre 'created_at')
-// Asumimos que el ltimo post visto tena created_at = '2023-05-10T10:00:00.000Z'
-// Y estamos ordenando por created_at ASC
-postCriteria
+import {
+  CriteriaFactory,
+  FilterOperator,
+  OrderDirection,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema } from './path/to/your/schemas';
+
+const simpleCursorCriteria = CriteriaFactory.GetCriteria(PostSchema)
   .setCursor(
-    [{ field: 'created_at', value: '2023-05-10T10:00:00.000Z' }], // Un solo filtro para cursor simple
+    [{ field: 'createdAt', value: '2023-05-10T10:00:00.000Z' }],
     FilterOperator.GREATER_THAN,
     OrderDirection.ASC,
   )
-  .orderBy('created_at', OrderDirection.ASC) // El orderBy debe coincidir
+  .orderBy('createdAt', OrderDirection.ASC)
   .setTake(10);
 
-// Paginacin por cursor compuesta (ej. sobre 'created_at' y 'uuid')
-// Asumimos que el ltimo post visto tena:
-// created_at = '2023-05-10T10:00:00.000Z'
-// uuid = 'some-last-uuid'
-// Y estamos ordenando por created_at ASC, luego uuid ASC
-postCriteria
+const compositeCursorCriteria = CriteriaFactory.GetCriteria(PostSchema)
   .setCursor(
     [
-      // Dos filtros para cursor compuesto
-      { field: 'created_at', value: '2023-05-10T10:00:00.000Z' },
-      { field: 'uuid', value: 'some-last-uuid' },
+      { field: 'createdAt', value: '2023-05-10T10:00:00.000Z' },
+      { field: 'id', value: 'some-last-id' },
     ],
     FilterOperator.GREATER_THAN,
     OrderDirection.ASC,
   )
-  .orderBy('created_at', OrderDirection.ASC) // Ordenamientos deben coincidir
-  .orderBy('uuid', OrderDirection.ASC)
+  .orderBy('createdAt', OrderDirection.ASC)
+  .orderBy('id', OrderDirection.ASC)
   .setTake(10);
 ```
 
+---
+
 ## 6. Seleccin de Campos
 
-Por defecto, un `Criteria` (raz o join) seleccionar todos los campos definidos en su esquema. Puedes modificar esto con `setSelect()` y `resetSelect()`.
+Por defecto, un `Criteria` seleccionar todos los campos definidos en su esquema. Puedes modificar esto con `setSelect()` y `resetSelect()`.
 
 ### Seleccin en la Entidad Raz
 
 ```typescript
-// Seleccionar solo uuid y email del usuario
-userCriteria.setSelect(['uuid', 'email']);
+import { CriteriaFactory } from '@nulledexp/translatable-criteria';
+import { UserSchema } from './path/to/your/schemas';
+
+const userSelectCriteria = CriteriaFactory.GetCriteria(UserSchema).setSelect([
+  'id',
+  'email',
+]);
 ```
 
+**Nota:** Cuando se usa `setSelect`, el `identifier_field` de la entidad siempre se incluye implcitamente.
+
 ### Seleccin en Entidades Unidas
 
 Llama a `setSelect()` en la instancia del `JoinCriteria`.
 
 ```typescript
-// Obtener posts y solo el username de su autor
+import { CriteriaFactory } from '@nulledexp/translatable-criteria';
+import { PostSchema, UserSchema } from './path/to/your/schemas';
+
+const userJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(
+  UserSchema,
+).setSelect(['username']);
+
 const postsWithAuthorUsernameOnly = CriteriaFactory.GetCriteria(
   PostSchema,
-  'posts',
-).join(
-  CriteriaFactory.GetInnerJoinCriteria(UserSchema, 'publisher').setSelect([
-    'username',
-  ]), // Seleccionar solo 'username' del publisher
-  { parent_field: 'user_uuid', join_field: 'uuid' },
-);
+).join('user', userJoinCriteria, { parent_field: 'userId', join_field: 'id' });
 ```
 
 ### Volver a Seleccionar Todos los Campos (`resetSelect`)
 
-Si previamente usaste `setSelect()` y quieres volver al comportamiento por defecto de seleccionar todos los campos del esquema para esa instancia de `Criteria` (raz o join):
+Si previamente usaste `setSelect()` y quieres volver al comportamiento por defecto:
 
 ```typescript
-userCriteria.setSelect(['uuid']); // Selecciona solo uuid
-// ... otras operaciones ...
-userCriteria.resetSelect(); // Ahora seleccionar todos los campos de UserSchema de nuevo
+import { CriteriaFactory } from '@nulledexp/translatable-criteria';
+import { UserSchema } from './path/to/your/schemas';
+
+const userCriteria = CriteriaFactory.GetCriteria(UserSchema);
+userCriteria.setSelect(['id']);
+userCriteria.resetSelect();
 ```
 
-**Nota Importante:** Si usas `orderBy()` o `setCursor()` sobre campos que _no_ estn incluidos en tu `setSelect()`, algunos traductores (como el de TypeORM) podran aadir automticamente esos campos a la seleccin para asegurar el correcto funcionamiento de la base de datos.
+---
 
 ## 7. Combinando Todo
 
-Puedes encadenar todos estos mtodos para construir consultas complejas:
+Puedes encadenar todos estos mtodos para construir consultas complejas. El siguiente ejemplo demuestra cmo combinar mltiples caractersticas, incluyendo uniones anidadas, filtrado en entidades raz y unidas, seleccin de campos y paginacin basada en cursor, para construir una especificacin de consulta sofisticada.
 
 ```typescript
-// Ejemplo complejo:
-// Obtener los 5 posts ms recientes (ordenados por created_at DESC)
-// que contengan "TypeORM" en el ttulo o en el cuerpo,
-// incluyendo el username de su autor (publisher) y solo el texto de sus comentarios (si los tienen),
-// y que el autor (publisher) tenga el email "author@example.com".
-// Adems, paginar usando cursor si 'lastPostCreatedAt' y 'lastPostUuid' estn definidos.
-
-let lastPostCreatedAt: string | undefined = undefined; // '2023-10-26T12:00:00.000Z';
-let lastPostUuid: string | undefined = undefined; // 'a1b2c3d4-e5f6-7890-1234-567890abcdef';
-
-const complexPostCriteria = CriteriaFactory.GetCriteria(PostSchema, 'posts')
-  .setSelect(['uuid', 'title', 'created_at']) // Seleccionar campos especficos del post
+import {
+  CriteriaFactory,
+  FilterOperator,
+  OrderDirection,
+} from '@nulledexp/translatable-criteria';
+import { UserSchema, PostSchema, RoleSchema } from './path/to/your/schemas';
+
+let lastPostCreatedAt: string | undefined = undefined;
+let lastPostUuid: string | undefined = undefined;
+
+// 1. Define el criteria para el join ms interno (Roles)
+const roleJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(RoleSchema).where(
+  {
+    field: 'name',
+    operator: FilterOperator.EQUALS,
+    value: 'admin',
+  },
+);
+
+// 2. Define el criteria para el join intermedio (Users) y adele el join anidado
+const userWithRolesJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(
+  UserSchema,
+).join('roles', roleJoinCriteria, {
+  pivot_source_name: 'user_roles',
+  parent_field: { pivot_field: 'user_id', reference: 'id' },
+  join_field: { pivot_field: 'role_id', reference: 'id' },
+});
+
+// 3. Construye el criteria principal (Posts)
+const complexPostCriteria = CriteriaFactory.GetCriteria(PostSchema)
+  .setSelect(['id', 'title', 'createdAt'])
   .where({
     field: 'title',
     operator: FilterOperator.CONTAINS,
     value: 'TypeORM',
   })
-  .orWhere({
-    field: 'body',
-    operator: FilterOperator.CONTAINS,
-    value: 'TypeORM',
+  // 4. Aade el join de usuario pre-configurado al criteria principal
+  .join('user', userWithRolesJoinCriteria, {
+    parent_field: 'userId',
+    join_field: 'id',
   })
-  .join(
-    CriteriaFactory.GetInnerJoinCriteria(UserSchema, 'publisher')
-      .setSelect(['username']) // Solo el username del autor
-      .where({
-        field: 'email',
-        operator: FilterOperator.EQUALS,
-        value: 'author@example.com',
-      }),
-    { parent_field: 'user_uuid', join_field: 'uuid' },
-  )
-  .join(
-    CriteriaFactory.GetLeftJoinCriteria(
-      PostCommentSchema,
-      'comments',
-    ).setSelect(['comment_text']), // Solo el texto del comentario
-    { parent_field: 'uuid', join_field: 'post_uuid' },
-  )
-  .orderBy('created_at', OrderDirection.DESC) // Orden principal para paginacin por cursor
-  .orderBy('uuid', OrderDirection.DESC); // Campo de desempate para paginacin por cursor
+  .orderBy('createdAt', OrderDirection.DESC)
+  .orderBy('id', OrderDirection.DESC);
 
 if (lastPostCreatedAt && lastPostUuid) {
   complexPostCriteria.setCursor(
     [
-      { field: 'created_at', value: lastPostCreatedAt },
-      { field: 'uuid', value: lastPostUuid },
+      { field: 'createdAt', value: lastPostCreatedAt },
+      { field: 'id', value: lastPostUuid },
     ],
-    FilterOperator.LESS_THAN, // Porque ordenamos DESC para "ms recientes"
+    FilterOperator.LESS_THAN,
     OrderDirection.DESC,
   );
 }
 
 complexPostCriteria.setTake(5);
-
-// Ahora 'complexPostCriteria' est listo para ser pasado a un traductor.
 ```
 
 ## Prximos Pasos
 
-Con los criterios construidos, el siguiente paso es utilizar un `CriteriaTranslator` para convertir estos objetos `Criteria` en una consulta nativa para tu base de datos. Consulta la gua sobre Desarrollo de Traductores Personalizados o utiliza un traductor existente si est disponible para tu stack.
+Con los criterios construidos, el siguiente paso es utilizar un [`CriteriaTranslator`](../developing-translators/es.md) para convertir estos objetos `Criteria` en una consulta nativa para tu base de datos. [Consulta la gua sobre Desarrollo de Traductores Personalizados](../developing-translators/es.md) o utiliza un traductor existente si est disponible para tu stack.
diff --git a/src/docs/guides/developing-translators/en.md b/src/docs/guides/developing-translators/en.md
index fb8334f..410217e 100644
--- a/src/docs/guides/developing-translators/en.md
+++ b/src/docs/guides/developing-translators/en.md
@@ -14,12 +14,10 @@ This guide will show you the key steps and concepts for developing your own `Cri
   - 3.3. [`visitFilter`](#33-visitfilter)
   - 3.4. [`visitAndGroup`, `visitOrGroup`](#34-visitandgroup-visitorgroup)
 - 4.  [Handling Ordering, Pagination, and Selection](#4-handling-ordering-pagination-and-selection)
-  - 4.1. [Ordering (`orderBy`)](#41-ordering-orderby)
-  - 4.2. [Offset Pagination (`setTake`, `setSkip`)](#42-offset-pagination-settake-setskip)
-  - 4.3. [Cursor Pagination (`setCursor`)](#43-cursor-pagination-setcursor)
-  - 4.4. [Field Selection (`setSelect`)](#44-field-selection-setselect)
 - 5.  [State and Parameter Management](#5-state-and-parameter-management)
-- 6.  [Simplified Example: Pseudo-SQL Translator](#6-simplified-example-pseudo-sql-translator)
+- 6.  [Complete Example: Pseudo-SQL Translator](#6-complete-example-pseudo-sql-translator)
+  - 6.1. [Translator Implementation](#61-translator-implementation)
+  - 6.2. [Translator Usage](#62-translator-usage)
 - 7.  [Additional Considerations](#7-additional-considerations)
 - [Next Steps](#next-steps)
 
@@ -27,17 +25,17 @@ This guide will show you the key steps and concepts for developing your own `Cri
 
 ## 1. Understanding `CriteriaTranslator` and `ICriteriaVisitor`
 
-As mentioned in the Key Concepts, the library uses the Visitor design pattern.
+The library uses the Visitor design pattern.
 
 - **`CriteriaTranslator<TranslationContext, TranslationOutput, TFilterVisitorOutput>`**: This is an abstract class that you must extend.
 
-  - `TranslationContext`: The type of the context object passed during the traversal of the `Criteria` (e.g., a query builder like TypeORM's `SelectQueryBuilder`, or an object where you accumulate parts of a MongoDB query).
-  - `TranslationOutput`: The type of the final translation result (e.g., the modified `SelectQueryBuilder`, an SQL string, a MongoDB query object).
-  - `TFilterVisitorOutput`: The specific output type for the `visitFilter`, `visitAndGroup`, and `visitOrGroup` methods. This allows filters to be processed differently if necessary (e.g., generating a condition string, or a filter object).
+  - `TranslationContext`: The type of the mutable context object passed during the traversal of the `Criteria` object graph (e.g., a query builder instance, or an object where you accumulate parts of a query). This object is modified directly by the `visit...` methods.
+  - `TranslationOutput` (optional, defaults to `TranslationContext`): The type of the final result returned by the `translate()` method. This is typically the `TranslationContext` itself, but can be a different type if your translator needs to return a processed version of the context (e.g., a final SQL string from a query builder).
+  - `TFilterVisitorOutput` (optional, defaults to `any`): The specific output type for the `visitFilter` method. This allows filters to return an intermediate representation (e.g., a condition string and its parameters) that can then be integrated into the main `TranslationContext`. The `visitAndGroup` and `visitOrGroup` methods, however, return `void` and directly modify the `TranslationContext`.
 
 - **`ICriteriaVisitor`**: The interface that `CriteriaTranslator` implements. It defines all the `visit...` methods that your translator will need to override to handle each type of node in the `Criteria` tree (filters, filter groups, joins, etc.).
 
-The translation process generally begins by calling the `translate()` method of your translator, which internally calls `criteria.accept(this, initialContext)`.
+The translation process is initiated by calling the `translate()` method, which is an **abstract method that you must implement**. Inside your `translate` implementation, you are responsible for starting the visitor traversal by calling `criteria.accept(this, initialContext)`. The `accept` method of each `Criteria` component will then call the appropriate `visit...` method on your translator, passing the component itself and the `TranslationContext`. For instance, a `RootCriteria`'s `accept` method will call `visitor.visitRoot(...)`, while a `Filter`'s `accept` method will call `visitor.visitFilter(...)`. This "double dispatch" mechanism is the core of the Visitor pattern.
 
 ---
 
@@ -45,1084 +43,508 @@ The translation process generally begins by calling the `translate()` method of
 
 The first step is to create a new class that extends `CriteriaTranslator`. You will need to define the generic types according to what your translator will produce and require.
 
-```typescript
-import {
-  CriteriaTranslator,
-  RootCriteria,
-  InnerJoinCriteria,
-  // ... other necessary imports
-  FilterOperator,
-  type CriteriaSchema,
-  type SelectedAliasOf,
-  type PivotJoin,
-  type SimpleJoin,
-  type JoinRelationType,
-  type Filter,
-  type FilterGroup,
-} from '@nulledexp/translatable-criteria';
+For the conceptual examples in this guide, we will use the following types for `TranslationContext` and `TFilterVisitorOutput`, which align with the [`PseudoSqlTranslator`](../../../criteria/translator/example/pseudo-sql.translator.ts) example:
 
-// Define your types for the context and output
-// For example, if translating to an SQL query builder:
-// type MyQueryBuilder = SomeSQLQueryBuilder;
-// type MyFilterConditionOutput = string; // or a condition object
+Here is the basic structure of your custom translator class, showing only the public method signatures you'll need to implement:
 
-// For this example, we'll use simple types
-type MyQueryBuilder = {
-  selectFields: string[];
-  fromTable?: string;
+```typescript
+type PseudoSqlParts = {
+  select: string[];
+  from: string;
   joins: string[];
-  conditions: string[];
+  where: string[];
   orderBy: string[];
   limit?: number;
   offset?: number;
   params: any[];
 };
 
-type MyFilterConditionOutput = {
+type PseudoSqlFilterOutput = {
   condition: string;
   params: any[];
 };
 
 export class MyCustomTranslator extends CriteriaTranslator<
-  MyQueryBuilder, // TranslationContext: The object modified during translation
-  MyQueryBuilder, // TranslationOutput: The final result of translate()
-  MyFilterConditionOutput // TFilterVisitorOutput: The result of visiting filters/groups
+  PseudoSqlParts,
+  { query: string; params: any[] },
+  PseudoSqlFilterOutput
 > {
-  private paramCounter = 0;
-
-  private generateParamPlaceholder(): string {
-    // Internal logic can vary based on the type of placeholder you need:
-    // If using named placeholders like :p0, :p1 (common in TypeORM, for example)
-    // return `:p${this.paramCounter++}`;
-    // If using positional placeholders like ? (common in native MySQL, SQLite)
-    this.paramCounter++; // Only to count if necessary, placeholder is fixed
-    return `?`;
-    // Or the specific placeholder for your DB/ORM.
+  public override translate<RootCriteriaSchema extends CriteriaSchema>(
+    criteria: RootCriteria<RootCriteriaSchema>,
+    source: PseudoSqlParts,
+  ): { query: string; params: any[] } {
+    return { query: '', params: [] };
   }
 
-  // Implementation of visit... methods
-  // ... (see following sections)
-}
-```
-
-In this example:
-
-- `MyQueryBuilder`: Would be your class or interface for building the native query.
-- `MyFilterConditionOutput`: The output type of the `visitFilter` and `visit...Group` methods, assuming they generate objects containing condition strings and their parameters.
+  public override visitRoot<RootCSchema extends CriteriaSchema>(
+    criteria: RootCriteria<RootCSchema>,
+    context: PseudoSqlParts,
+  ): void {}
 
----
+  public override visitInnerJoin<
+    ParentCSchema extends CriteriaSchema,
+    JoinCSchema extends CriteriaSchema,
+  >(
+    criteria: InnerJoinCriteria<JoinCSchema>,
+    parameters:
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
+    context: PseudoSqlParts,
+  ): void {}
 
-## 3. Implementing `visit...` Methods
+  public override visitLeftJoin<
+    ParentCSchema extends CriteriaSchema,
+    JoinCSchema extends CriteriaSchema,
+  >(
+    criteria: LeftJoinCriteria<JoinCSchema>,
+    parameters:
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
+    context: PseudoSqlParts,
+  ): void {}
 
-Now, you must implement the abstract `visit...` methods from `CriteriaTranslator`.
+  public override visitOuterJoin<
+    ParentCSchema extends CriteriaSchema,
+    JoinCSchema extends CriteriaSchema,
+  >(
+    criteria: OuterJoinCriteria<JoinCSchema>,
+    parameters:
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
+    context: PseudoSqlParts,
+  ): void {}
 
-### 3.1. `visitRoot`
+  public override visitFilter<FieldType extends string>(
+    filter: Filter<FieldType, FilterOperator>,
+    currentAlias: string,
+    context: PseudoSqlParts,
+  ): PseudoSqlFilterOutput {
+    return { condition: '', params: [] };
+  }
 
-This is the main entry point for translating a `RootCriteria`. This is where you will typically initialize your query, process the main filters, joins, ordering, and pagination of the `RootCriteria`.
+  public override visitAndGroup<FieldType extends string>(
+    group: FilterGroup<FieldType>,
+    currentAlias: string,
+    context: PseudoSqlParts,
+  ): void {}
 
-```typescript
-  visitRoot<
-    RootCriteriaSchema extends CriteriaSchema,
-    RootAlias extends SelectedAliasOf<RootCriteriaSchema>,
-  >(
-    criteria: RootCriteria<RootCriteriaSchema, RootAlias>,
-    queryBuilder: MyQueryBuilder, // The initial context
-  ): MyQueryBuilder {
-    this.paramCounter = 0; // Reset parameter counter for each main translation
-
-    // 1. FROM clause
-    queryBuilder.fromTable = `${criteria.sourceName} AS ${criteria.alias}`;
-
-    // 2. SELECT clause
-    queryBuilder.selectFields = criteria.select.map(
-      (field) => `${criteria.alias}.${String(field)}`,
-    );
-    if (criteria.selectAll && queryBuilder.selectFields.length === 0) {
-        queryBuilder.selectFields.push(`${criteria.alias}.*`);
-    }
+  public override visitOrGroup<FieldType extends string>(
+    group: FilterGroup<FieldType>,
+    currentAlias: string,
+    context: PseudoSqlParts,
+  ): void {}
+}
+```
 
-    // 3. JOINs
-    for (const joinDetail of criteria.joins) {
-      // The context (queryBuilder) is passed and modified by the visitJoin methods
-      joinDetail.criteria.accept(this, joinDetail.parameters, queryBuilder);
-    }
+In this example:
 
-    // 4. WHERE clause for RootCriteria
-    if (criteria.rootFilterGroup.items.length > 0) {
-      const rootFilterResult = criteria.rootFilterGroup.accept(
-        this,
-        criteria.alias,
-        queryBuilder, // Context here might be different if filters don't directly modify QB
-      );
-      if (rootFilterResult.condition) {
-        queryBuilder.conditions.push(rootFilterResult.condition);
-        queryBuilder.params.push(...rootFilterResult.params);
-      }
-    }
+- `PseudoSqlParts`: Is our `TranslationContext`, representing the accumulating parts of the SQL query.
+- `{ query: string; params: any[] }`: Is our `TranslationOutput`, the final result returned by the `translate()` method.
+- `PseudoSqlFilterOutput`: Is our `TFilterVisitorOutput`, the result of visiting individual filters.
 
-    // 5. Cursor condition (if it exists, add to WHERE)
-    if (criteria.cursor) {
-        const cursorFilters = criteria.cursor.filters;
-        const op = criteria.cursor.operator === FilterOperator.GREATER_THAN ? '>' : '<';
-        // const orderDir = criteria.cursor.order; // Not used directly in this simple SQL example
-
-        const primaryCursorFilter = cursorFilters[0]!;
-        const primaryParamName = this.generateParamPlaceholder(); // Use a unique parameter name
-        queryBuilder.params.push(primaryCursorFilter.value);
-        let cursorCondition = `(${criteria.alias}.${String(primaryCursorFilter.field)} ${op} :${primaryParamName}`;
-
-        if (cursorFilters.length === 2) {
-            const secondaryCursorFilter = cursorFilters[1]!;
-            const secondaryParamName = this.generateParamPlaceholder(); // Use a unique parameter name
-            queryBuilder.params.push(secondaryCursorFilter.value);
-            cursorCondition += ` OR (${criteria.alias}.${String(primaryCursorFilter.field)} = :${primaryParamName} AND ${criteria.alias}.${String(secondaryCursorFilter.field)} ${op} :${secondaryParamName}))`;
-        } else {
-            cursorCondition += `)`;
-        }
-        queryBuilder.conditions.push(cursorCondition);
-
-        // Ensure cursor's orderBy is applied
-        // In a real translator, this might need more complex logic to ensure correct order
-        // and avoid duplicates if already in criteria.orders.
-        // For simplicity, we add them here.
-        criteria.orders.forEach(order => { // Assuming cursor orders are in criteria.orders
-             queryBuilder.orderBy.push(`${criteria.alias}.${String(order.field)} ${order.direction}`);
-        });
-    }
+---
 
-    // 6. ORDER BY
-    // Ordering logic must be careful, especially with cursors.
-    // The translator is responsible for:
-    //   a. If a cursor exists, its sort fields MUST take precedence.
-    //   b. Then, other `Order`s defined in the `RootCriteria` and `JoinCriteria`s are applied.
-    //   c. All `Order`s (after cursor-defined ones) must be globally sorted by their `sequenceId`
-    //      before being applied, to maintain deterministic sorting.
-    // (See section "4.1. Ordering (orderBy)" and the PseudoSqlTranslator example
-    // for a more detailed implementation of this logic).
-
-    // Conceptual simplified example (actual logic is more complex and shown in section 4.1 and the example):
-    if (criteria.cursor) {
-      // Cursor's orderBy fields are applied first.
-      // Example: criteria.cursor.filters.forEach(cf => queryBuilder.orderBy.push(`${criteria.alias}.${String(cf.field)} ${criteria.cursor.order}`));
-      // Then, other orders, avoiding duplicates and using sequenceId.
-    } else {
-      // If no cursor, apply all collected orders, sorted by sequenceId.
-      // Example:
-      // const allOrders = []; // Collect from criteria.orders and joins
-      // allOrders.sort((a, b) => a.order.sequenceId - b.order.sequenceId);
-      // allOrders.forEach(({alias, order}) => queryBuilder.orderBy.push(`${alias}.${String(order.field)} ${order.direction}`));
-    }
+## Helper: `escapeField`
 
-    // 7. LIMIT / OFFSET
-    if (criteria.take > 0) {
-      queryBuilder.limit = criteria.take;
-    }
-    if (criteria.skip > 0) {
-      queryBuilder.offset = criteria.skip;
-    }
+Many translators will need a utility function to properly escape field names to prevent SQL injection or to conform to the target query language's syntax. This helper is used in the conceptual examples below.
 
-    return queryBuilder;
-  }
+```typescript
+function escapeField(field: string, alias?: string): string {
+  const escape = (str: string) => `\`${str.replace(/`/g, '``')}\``;
+  return alias ? `${escape(alias)}.${escape(field)}` : escape(field);
+}
 ```
 
-**Considerations for `visitRoot`:**
+This function takes a field name and an optional alias, and returns a string with the field properly escaped and prefixed (e.g., `` `alias`.`field` ``).
 
-- **Initialization:** Set up the `FROM` part of your query using `criteria.sourceName` and `criteria.alias`.
-- **Filters:** Call `criteria.rootFilterGroup.accept(this, criteria.alias, context)` to process the `RootCriteria`'s filters. The `context` here could be your `queryBuilder` or an object where conditions are attached.
-- **Joins:** Iterate over `criteria.joins` and call `joinDetail.criteria.accept(this, joinDetail.parameters, context)` for each one.
-- **Ordering and Pagination:** Apply the logic for `orderBy`, `take`, `skip`, and `cursor` at the end.
-- **Field Selection:** Construct the `SELECT` clause based on `criteria.select`.
+---
 
-### 3.2. `visitInnerJoin`, `visitLeftJoin`, `visitOuterJoin`
+## 3. Implementing `visit...` Methods
 
-These methods handle the different types of joins. They receive the `JoinCriteria` instance, the join `parameters` (which include information about the parent and child of the join), and the `context`.
+Now, you must implement the abstract `visit...` methods from `CriteriaTranslator`.
 
-```typescript
-  private applyJoin<
-    ParentCSchema extends CriteriaSchema,
-    JoinCriteriaSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCriteriaSchema>,
-  >(
-    joinType: 'INNER' | 'LEFT' | 'OUTER',
-    criteria: // The current JoinCriteria being visited
-      | InnerJoinCriteria<JoinCriteriaSchema, JoinAlias>
-      | LeftJoinCriteria<JoinCriteriaSchema, JoinAlias>
-      | OuterJoinCriteria<JoinCriteriaSchema, JoinAlias>,
-    parameters:
-      | PivotJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>
-      | SimpleJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>,
-    queryBuilder: MyQueryBuilder, // Context: the main query builder
-  ): MyQueryBuilder {
-    const joinTable = `${criteria.sourceName} AS ${criteria.alias}`;
-    let onCondition = '';
-
-    if ('pivot_source_name' in parameters) {
-      // Many-to-many join
-      const pivotAlias = `${parameters.parent_alias}_${criteria.alias}_pivot`;
-      const pivotTable = `${parameters.pivot_source_name} AS ${pivotAlias}`;
-
-      const firstJoin = `${joinType} JOIN ${pivotTable} ON ${parameters.parent_alias}.${String(parameters.parent_field.reference)} = ${pivotAlias}.${parameters.parent_field.pivot_field}`;
-      queryBuilder.joins.push(firstJoin);
-
-      onCondition = `${pivotAlias}.${parameters.join_field.pivot_field} = ${criteria.alias}.${String(parameters.join_field.reference)}`;
-      queryBuilder.joins.push(`${joinType} JOIN ${joinTable} ON ${onCondition}`);
-    } else {
-      // Simple join
-      onCondition = `${parameters.parent_alias}.${String(parameters.parent_field)} = ${criteria.alias}.${String(parameters.join_field)}`;
-      queryBuilder.joins.push(`${joinType} JOIN ${joinTable} ON ${onCondition}`);
-    }
+### 3.1. `visitRoot`
 
-    // Filters on the JOIN (added to ON clause or as AND after)
-    if (criteria.rootFilterGroup.items.length > 0) {
-      const joinFilterResult = criteria.rootFilterGroup.accept(
-        this,
-        criteria.alias,
-        queryBuilder,
-      );
-      if (joinFilterResult.condition) {
-        const lastJoinIndex = queryBuilder.joins.length -1;
-        if(queryBuilder.joins[lastJoinIndex]) { // Ensure there's a join to append AND to
-            queryBuilder.joins[lastJoinIndex] += ` AND (${joinFilterResult.condition})`;
-            queryBuilder.params.push(...joinFilterResult.params);
-        }
-      }
-    }
+This is the main entry point for translating a `RootCriteria`. This is where you will typically initialize your query, process the main filters, joins, ordering, and pagination of the `RootCriteria`.
 
-    // Field selection from Join
-    criteria.select.forEach((field) => {
-      queryBuilder.selectFields.push(`${criteria.alias}.${String(field)}`);
-    });
-    if (criteria.selectAll && criteria.select.length === 0) {
-        queryBuilder.selectFields.push(`${criteria.alias}.*`);
-    }
+```typescript
+public override visitRoot<RootCSchema extends CriteriaSchema>(
+  criteria: RootCriteria<RootCSchema>,
+  context: PseudoSqlParts,
+): void {}
+```
 
-    // Collect OrderBy from join to apply globally
-    // (This logic might need refinement to ensure correct global order)
-    criteria.orders.forEach(order => {
-        // Example: queryBuilder.orderBy.push(`${criteria.alias}.${String(order.field)} ${order.direction}`);
-        // Or store them in a class property to apply at the end in visitRoot.
-    });
-
-    // ***** START OF MODIFICATION FOR NESTED JOINS *****
-    // If this JoinCriteria (the current 'criteria') has its own joins defined,
-    // process them recursively.
-    for (const subJoinDetail of criteria.joins) {
-      // The 'queryBuilder' (context) is passed along and modified.
-      subJoinDetail.criteria.accept(this, subJoinDetail.parameters, queryBuilder);
-    }
-    // ***** END OF MODIFICATION FOR NESTED JOINS *****
+**Explanation:**
 
-    return queryBuilder;
-  }
+This method is the starting point of the translation process. It receives the `RootCriteria` object and the `TranslationContext` (our `sqlParts` object). Its primary responsibilities are:
 
-  visitInnerJoin<
-    ParentCSchema extends CriteriaSchema,
-    JoinCriteriaSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCriteriaSchema>,
-  >(
-    criteria: InnerJoinCriteria<JoinCriteriaSchema, JoinAlias>,
-    parameters:
-      | PivotJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>
-      | SimpleJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>,
-    context: MyQueryBuilder,
-  ): MyQueryBuilder {
-    return this.applyJoin('INNER', criteria, parameters, context);
-  }
+- **Initializing the `FROM` clause:** It uses `criteria.sourceName` and `criteria.alias` to set up the main table for the query.
+- **Processing field selection:** It maps `criteria.select` to the `SELECT` clause, ensuring fields are properly qualified with the entity's alias.
+- **Handling joins:** It iterates through `criteria.joins` and recursively calls `accept` on each `JoinCriteria` to process nested joins.
+- **Processing root filters:** If `criteria.rootFilterGroup` contains filters, it calls `accept` on this group to translate them into `WHERE` conditions.
+- **Applying pagination:** It checks `criteria.take` and `criteria.skip` for offset-based pagination, and `criteria.cursor` for cursor-based pagination, adding the corresponding `LIMIT`, `OFFSET`, or complex `WHERE` clauses.
+- **Collecting ordering rules:** It gathers `Order` objects from `criteria.orders` to be applied later.
 
-  visitLeftJoin<
-    ParentCSchema extends CriteriaSchema,
-    JoinCriteriaSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCriteriaSchema>,
-  >(
-    criteria: LeftJoinCriteria<JoinCriteriaSchema, JoinAlias>,
-    parameters:
-      | PivotJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>
-      | SimpleJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>,
-    context: MyQueryBuilder,
-  ): MyQueryBuilder {
-    return this.applyJoin('LEFT', criteria, parameters, context);
-  }
+**Available `Criteria` properties:** `criteria.sourceName`, `criteria.alias`, `criteria.select`, `criteria.orders`, `criteria.joins`, `criteria.rootFilterGroup`, `criteria.cursor`, `criteria.take`, `criteria.skip`.
 
-  visitOuterJoin<
-    ParentCSchema extends CriteriaSchema,
-    JoinCriteriaSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCriteriaSchema>,
-  >(
-    criteria: OuterJoinCriteria<JoinCriteriaSchema, JoinAlias>,
-    parameters:
-      | PivotJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>
-      | SimpleJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>,
-    context: MyQueryBuilder,
-  ): MyQueryBuilder {
-    // Note: FULL OUTER JOIN support can vary and might require special syntax.
-    return this.applyJoin('OUTER', criteria, parameters, context);
-  }
-```
+For a complete implementation, refer to the `visitRoot` method in `src/criteria/translator/example/pseudo-sql.translator.ts`.
 
-**Considerations for `visitJoin...` methods:**
-
-- **Join Type:** Use the appropriate join type (`INNER JOIN`, `LEFT JOIN`, etc.) based on the specific `visit...` method being implemented.
-- **Table and Alias:** Use `criteria.sourceName` and `criteria.alias` for the table being joined (the `criteria` object is the `JoinCriteria` instance passed to the method).
-- **`ON` Condition:**
-  - For `SimpleJoin` (relations like 'one_to_one', 'one_to_many', 'many_to_one' as defined by `parameters.relation_type`): Construct the `ON` condition using `parameters.parent_alias`.`parameters.parent_field` = `criteria.alias`.`parameters.join_field`.
-  - For `PivotJoin` (relation 'many_to_many' as defined by `parameters.relation_type`): You will typically need two join operations in your native query. The first joins the parent table (identified by `parameters.parent_alias`) to the pivot table (`parameters.pivot_source_name`) using `parameters.parent_field.reference` (from parent) and `parameters.parent_field.pivot_field` (from pivot). The second joins the pivot table to the target joined table (`criteria.sourceName` aliased as `criteria.alias`) using `parameters.join_field.pivot_field` (from pivot) and `parameters.join_field.reference` (from target).
-- **Accessing Metadata:** The `parameters` object (of type `PivotJoin` or `SimpleJoin`) passed to these join visit methods contains:
-  - `parameters.parent_schema_metadata`: Metadata from the root `CriteriaSchema` of the parent criteria.
-  - `parameters.join_metadata`: Metadata from the specific join configuration in the parent schema's `joins` array.
-    Translators can use this metadata for custom logic, such as applying database-specific hints or handling custom join conditions.
-- **Filters on the Join:** If `criteria.rootFilterGroup` (from the `JoinCriteria` being visited) has filters, these should be applied as additional conditions. This is typically done by appending them to the `ON` clause of the join (e.g., `... ON condition AND (join_filters)`) or as separate `WHERE` conditions if the database/ORM handles it that way for outer joins. Call `criteria.rootFilterGroup.accept(this, criteria.alias, context)` to process these filters.
-- **Field Selection from Join:**
-  - If `criteria.selectAll` (from the `JoinCriteria`) is `true`, all fields from `criteria.schema.fields` should be added to the main query's selection, prefixed with `criteria.alias`.
-  - If `criteria.selectAll` is `false`, only the fields in `criteria.select` should be added, prefixed with `criteria.alias`.
-- **Ordering from Join:** If `criteria.orders` (from the `JoinCriteria`) has ordering rules, these should be collected. All collected orders (from root and all joins) must be sorted globally by their `sequenceId` at the end of the `visitRoot` method before being applied to the final query, to ensure a deterministic sort order.
-- **Nested Joins:** Crucially, if the `criteria` (the `JoinCriteria` being visited) itself has `criteria.joins` defined (i.e., joins chained off a join), you must iterate over them and recursively call `subJoinDetail.criteria.accept(this, subJoinDetail.parameters, context)` to process these nested joins. The `context` (e.g., your query builder) is passed along and modified.
+### 3.2. `visitInnerJoin`, `visitLeftJoin`, `visitOuterJoin`
 
-### 3.3. `visitFilter`
+These methods handle the different types of joins. They receive the `JoinCriteria` instance, the join `parameters` (which include information about the parent and child of the join), and the `context`.
 
-This method translates an individual `Filter` into a condition for your query language.
+To avoid code repetition, a common practice is to create a private helper method (like `applyJoin` below) that handles the shared logic for all join types.
 
 ```typescript
-    visitFilter<
-FieldType extends string,
-        Operator extends FilterOperator,
+private applyJoin<
+  ParentCSchema extends CriteriaSchema,
+  JoinCSchema extends CriteriaSchema,
 >(
-        filter: Filter<FieldType, Operator>,
-        currentAlias: string,
-        // queryBuilder: MyQueryBuilder, // Context might not be needed here if only returning the condition
-): MyFilterConditionOutput {
-  const fieldName = `${currentAlias}.${String(filter.field)}`;
-  // const paramName = this.generateParamPlaceholder(); // Generate unique placeholder
-  let condition = '';
-  const params: any[] = []; // Array to collect parameters
-
-  switch (filter.operator) {
-    case FilterOperator.EQUALS:
-      const eqParam = this.generateParamPlaceholder();
-      condition = `${fieldName} = ${eqParam}`; // Use placeholder
-      params.push(filter.value);
-      break;
-    case FilterOperator.NOT_EQUALS:
-      const neqParam = this.generateParamPlaceholder();
-      condition = `${fieldName} != ${neqParam}`;
-      params.push(filter.value);
-      break;
-    case FilterOperator.LIKE:
-      const likeParam = this.generateParamPlaceholder();
-      condition = `${fieldName} LIKE ${likeParam}`;
-      params.push(filter.value); // Assume value already has '%'
-      break;
-    case FilterOperator.CONTAINS: // Could be same as LIKE or use a specific function
-      const containsParam = this.generateParamPlaceholder();
-      condition = `${fieldName} LIKE ${containsParam}`;
-      params.push(`%${filter.value}%`);
-      break;
-    case FilterOperator.IN:
-      if (Array.isArray(filter.value) && filter.value.length > 0) {
-        const inPlaceholders = filter.value
-                .map(() => this.generateParamPlaceholder())
-                .join(', ');
-        condition = `${fieldName} IN (${inPlaceholders})`;
-        params.push(...filter.value);
-      } else {
-        // If array is empty or not an array, condition is usually false.
-        condition = '1=0'; // Or your DB's way for an always-false condition
-      }
-      break;
-    case FilterOperator.IS_NULL:
-      condition = `${fieldName} IS NULL`;
-      // No parameters for IS NULL
-      break;
-          // ... Implement all necessary FilterOperators
-    case FilterOperator.BETWEEN: // NEW CASE
-      if (Array.isArray(filter.value) && filter.value.length === 2) {
-        const paramMin = this.generateParamPlaceholder();
-        const paramMax = this.generateParamPlaceholder();
-        condition = `${fieldName} BETWEEN ${paramMin} AND ${paramMax}`;
-        params.push(filter.value[0], filter.value[1]);
-      } else {
-        // Handle invalid value for BETWEEN, perhaps throw error or false condition
-        condition = '1=0'; // Condition that is always false
-      }
-      break;
-    case FilterOperator.MATCHES_REGEX: // NEW CASE
-      // Implementation will depend on the database (e.g., REGEXP in MySQL, ~ in PostgreSQL)
-      const regexParam = this.generateParamPlaceholder();
-      condition = `${fieldName} REGEXP ${regexParam}`; // Example MySQL
-      params.push(filter.value);
-      break;
-    case FilterOperator.JSON_CONTAINS:
-      // ... (your existing implementation for JSON_CONTAINS)
-      // Conceptual example for MySQL:
-      if (typeof filter.value === 'object' && filter.value !== null) {
-        const conditions: string[] = [];
-        for (const pathKey in filter.value) {
-          const pathValue = (filter.value as Record<string, any>)[pathKey];
-          // Example: JSON_CONTAINS(metadata, '"tech"', '$.tags')
-          // Or for equality of a value at a path: JSON_EXTRACT(metadata, '$.views') = 100
-          conditions.push(
-                  `JSON_CONTAINS(${fieldName}, CAST(${this.generateParamPlaceholder()} AS JSON), '$.${pathKey}')`,
-          );
-          params.push(pathValue); // Translator might need to cast pathValue to JSON string
-        }
-        condition = conditions.join(' AND ');
-      } else {
-        condition = '1=0';
-      }
-      break;
-    case FilterOperator.ARRAY_CONTAINS_ELEMENT:
-      // ... (your existing implementation for ARRAY_CONTAINS_ELEMENT)
-      const arrayElemParam = this.generateParamPlaceholder();
-      if (
-              typeof filter.value === 'object' &&
-              filter.value !== null &&
-              !Array.isArray(filter.value)
-      ) {
-        const jsonPath = Object.keys(filter.value)[0]!;
-        const elementToFind = (filter.value as Record<string, any>)[
-                jsonPath
-                ];
-        condition = `JSON_CONTAINS(${fieldName}, CAST(${arrayElemParam} AS JSON), '$.${jsonPath}')`;
-        params.push(elementToFind);
-      } else {
-        condition = `${arrayElemParam} = ANY(${fieldName})`; // Example PostgreSQL
-        params.push(filter.value);
-      }
-      break;
-    default:
-      throw new Error(
-              `Translator: Unsupported filter operator '${filter.operator}'`,
-      );
-  }
-  // Ensure undefined parameters are converted to null if necessary
-  return { condition, params: params.map((p) => (p === undefined ? null : p)) };
-}
+  joinType: 'INNER' | 'LEFT' | 'FULL OUTER',
+  criteria:
+    | InnerJoinCriteria<JoinCSchema>
+    | LeftJoinCriteria<JoinCSchema>
+    | OuterJoinCriteria<JoinCSchema>,
+  parameters:
+    | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+    | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
+  sqlParts: PseudoSqlParts,
+): void {}
 ```
 
-**Considerations for `visitFilter`:**
-
-- **Field and Alias:** The `currentAlias` tells you which entity the `filter.field` belongs to.
-- **Operator:** Implement the logic for each `FilterOperator` that your data source supports.
-- **Value:** The `filter.value` must be formatted or parameterized appropriately. For operators like `IN`, `value` will be an array. For JSON/Array operators, `value` can be an object or an array, and you'll need to interpret the JSON path if applicable.
-- **Parameterization:** It is **crucial** to use parameterized queries to prevent SQL injection. Do not directly concatenate `filter.value` into the query string. Instead, use placeholders and pass the values through your query builder's parameter mechanism.
-
-### 3.4. `visitAndGroup`, `visitOrGroup`
-
-These methods handle groups of filters. They receive a `FilterGroup` and must iterate over its `items`, processing them recursively and joining them with the appropriate logical operator (`AND` or `OR`).
-
 ```typescript
-  visitAndGroup<FieldType extends string>(
-    group: FilterGroup<FieldType>,
-    currentAlias: string,
-    _context: MyQueryBuilder, // Context may or may not be used/modified here
-  ): MyFilterConditionOutput {
-    const conditions: string[] = [];
-    const allParams: any[] = [];
-
-    group.items.forEach((item) => {
-      const result = item.accept(this, currentAlias, _context); // _context is passed
-      if (result.condition) {
-        conditions.push(result.condition);
-        allParams.push(...result.params);
-      }
-    });
-
-    if (conditions.length === 0) return { condition: '', params: [] };
-    return {
-      condition: `(${conditions.join(' AND ')})`,
-      params: allParams,
-    };
-  }
+public override visitInnerJoin<
+  ParentCSchema extends CriteriaSchema,
+  JoinCSchema extends CriteriaSchema,
+>(
+  criteria: InnerJoinCriteria<JoinCSchema>,
+  parameters:
+    | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+    | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
+  context: PseudoSqlParts,
+): void {}
+```
 
-  visitOrGroup<FieldType extends string>(
-    group: FilterGroup<FieldType>,
-    currentAlias: string,
-    _context: MyQueryBuilder,
-  ): MyFilterConditionOutput {
-    const conditions: string[] = [];
-    const allParams: any[] = [];
-
-    group.items.forEach((item) => {
-      const result = item.accept(this, currentAlias, _context);
-      if (result.condition) {
-        conditions.push(result.condition);
-        allParams.push(...result.params);
-      }
-    });
-
-    if (conditions.length === 0) return { condition: '', params: [] };
-    return {
-      condition: `(${conditions.join(' OR ')})`,
-      params: allParams,
-    };
-  }
+```typescript
+public override visitLeftJoin<
+  ParentCSchema extends CriteriaSchema,
+  JoinCSchema extends CriteriaSchema,
+>(
+  criteria: LeftJoinCriteria<JoinCSchema>,
+  parameters:
+    | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+    | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
+  context: PseudoSqlParts,
+): void {}
 ```
 
-**Considerations for `visit...Group` methods:**
+```typescript
+public override visitOuterJoin<
+  ParentCSchema extends CriteriaSchema,
+  JoinCSchema extends CriteriaSchema,
+>(
+  criteria: OuterJoinCriteria<JoinCSchema>,
+  parameters:
+    | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+    | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
+  context: PseudoSqlParts,
+): void {}
+```
 
-- **Recursion:** Each `item` in `group.items` can be another `FilterGroup` or a `Filter`. Call `item.accept(this, currentAlias, context)` for each one.
-- **Grouping:** Ensure that the generated conditions are correctly grouped with parentheses if necessary, especially when mixing `AND` and `OR`.
+**Explanation (for `applyJoin` and the `visit...Join` methods):**
 
----
+These methods are responsible for translating join conditions into the target query language. Each `visit...Join` method simply calls the `applyJoin` helper, passing the specific `joinType` (e.g., 'INNER', 'LEFT', 'FULL OUTER').
 
-## 4. Handling Ordering, Pagination, and Selection
+The `applyJoin` helper's responsibilities include:
 
-These logics are generally applied in `visitRoot` after all main joins and filters have been processed.
+- **Constructing the `JOIN` clause:** It uses `criteria.sourceName` (the table being joined) and `parameters.join_alias` (its alias in the query) to build the `JOIN` part of the query.
+- **Defining the `ON` condition:**
+- For `SimpleJoin` (one-to-one, one-to-many, many-to-one relations), it constructs the `ON` condition using `parameters.parent_alias`.`parameters.parent_field` = `parameters.join_alias`.`parameters.join_field`.
+- For `PivotJoin` (many-to-many relations), it typically involves two `JOIN` operations: one from the parent to the pivot table, and another from the pivot table to the target joined table. It constructs the `ON` conditions for both.
+- **Applying filters on the join:** If `criteria.rootFilterGroup` (from the `JoinCriteria` being visited) has filters, it processes them by calling `criteria.rootFilterGroup.accept(this, parameters.join_alias, context)` and appends their conditions to the `ON` clause using `AND`.
+- **Selecting fields from the joined entity:** It maps `criteria.select` (from the `JoinCriteria`) to the main `SELECT` clause, ensuring fields are prefixed with `parameters.join_alias`.
+- **Collecting ordering rules:** It adds `criteria.orders` (from the `JoinCriteria`) to a global collection of orders (e.g., `this.collectedOrders` in [`PseudoSqlTranslator`](../../../criteria/translator/example/pseudo-sql.translator.ts)) to be processed later in `visitRoot`.
+- **Processing nested joins:** Crucially, if the `JoinCriteria` being visited itself has `criteria.joins` defined (i.e., joins chained off a join), it iterates over them and recursively calls `subJoinDetail.criteria.accept(this, subJoinDetail.parameters, context)` to process them.
 
-### 4.1. Ordering (`orderBy`)
+**Available `Criteria` properties:** `criteria.sourceName`, `criteria.alias`, `criteria.select`, `criteria.orders`, `criteria.joins`, `criteria.rootFilterGroup`.
+**Available `parameters` properties:** `parameters.parent_alias`, `parameters.join_alias`, `parameters.parent_field`, `parameters.join_field`, `parameters.pivot_source_name`, `parameters.parent_identifier`, `parameters.parent_schema_metadata`, `parameters.join_metadata`.
 
-Ordering defines how the query results should be sorted.
+For a complete implementation, refer to the `visitInnerJoin`, `visitLeftJoin`, `visitOuterJoin` methods and the `applyPseudoJoin` helper in `src/criteria/translator/example/pseudo-sql.translator.ts`.
 
-- During the visit of each `Criteria` (root or join) via their respective `visit...` methods, your translator should **collect** all `Order` objects defined using `.orderBy()`. Each `Order` object contains the field, direction, and a unique internal `sequenceId`.
-- At the end of processing in `visitRoot` (after all joins have been processed and before applying `LIMIT`/`OFFSET`):
-  1. If `criteria.cursor` exists, the fields defined in `cursor.filters` must be used to generate the **first** `ORDER BY` clauses, using the direction specified in `cursor.order`.
-  2. Then, take all collected `Order`s (from the root and all joins).
-  3. Sort this global collection of `Order`s by their `sequenceId`. This ensures that the order in which `orderBy` was defined throughout the `Criteria` construction is respected sequentially.
-  4. Convert these `Order`s (now sorted by sequence and following any cursor-defined orders) into the `ORDER BY` clauses of your native query. Ensure you avoid duplicating fields if they were already ordered by the cursor logic.
-- The `order.sequenceId` is crucial for maintaining a deterministic and predictable global order when multiple `orderBy` calls are applied in different parts of the `Criteria` (both on the root and in nested joins).
+### 3.3. `visitFilter`
 
-### 4.2. Offset Pagination (`setTake`, `setSkip`)
+This method translates an individual `Filter` into a condition for your query language.
 
-- If `criteria.take > 0`, apply a limit to the number of results.
-- If `criteria.skip > 0`, skip the specified number of results.
+```typescript
+public override visitFilter<FieldType extends string>(
+  filter: Filter<FieldType, FilterOperator>,
+  currentAlias: string,
+  context: PseudoSqlParts,
+): PseudoSqlFilterOutput {
+  return { condition: '', params: [] };
+}
+```
 
-### 4.3. Cursor Pagination (`setCursor`)
+**Explanation:**
 
-This is more complex and requires careful coordination with ordering. If `criteria.cursor` is defined:
+This method is responsible for converting a single `Filter` object into a query condition string and collecting any necessary parameters.
 
-- `cursor.filters`: Provides one or two `Filter`s (without the `operator`) that define the fields and values of the last item from the previous page.
-  - A single `Filter`: For simple pagination over one field (e.g., `created_at`).
-  - Two `Filter`s: For composite pagination (e.g., `created_at` and `uuid`).
-- `cursor.operator`: Will be `FilterOperator.GREATER_THAN` (for next page) or `FilterOperator.LESS_THAN` (for previous page, if the main order is inverted).
-- `cursor.order`: The main `OrderDirection` in which pagination is occurring.
+- **Generating the field name:** It constructs the fully qualified field name using `currentAlias` and `filter.field` (e.g., `` `alias`.`field` ``).
+- **Parameterization:** It is **crucial** to use placeholders (e.g., `?`, `$1`, `:paramName`) for `filter.value` to prevent SQL injection. It adds `filter.value` to the `TranslationContext`'s parameter list.
+- **Implementing operator logic:** It uses a `switch` statement or similar to handle each `FilterOperator`. The logic for each operator will vary based on the target query language and the expected type of `filter.value` (e.g., `BETWEEN` expects a tuple, `IN` expects an array, JSON operators expect objects).
+- **Returning the condition:** It returns an object containing the generated condition string and the collected parameters.
 
-**Translator Responsibilities:**
+**Available `Filter` properties:** `filter.field`, `filter.operator`, `filter.value`.
+**Available context:** `currentAlias`.
 
-1.  **Construct the Cursor `WHERE` Condition:**
+For a complete implementation, refer to the `visitFilter` method in `src/criteria/translator/example/pseudo-sql.translator.ts`.
 
-- For a simple cursor: `WHERE (cursor_field translated_cursor_operator cursor_value)`
-- For a composite cursor: `WHERE ( (primary_sort_field translated_op primary_cursor_value) OR (primary_sort_field = primary_cursor_value AND tie_breaker_field translated_op tie_breaker_cursor_value) )`. Adjust operators based on direction.
-- **Note on NULLs:** If a `cursor_value` is `null`, the translator must generate the appropriate SQL (e.g., `IS NULL` or `IS NOT NULL` conditions) rather than direct comparisons like `field = NULL`.
+### 3.4. `visitAndGroup`, `visitOrGroup`
 
-2.  **Apply Cursor Ordering with Priority:**
+These methods handle groups of filters. They receive a `FilterGroup` and must iterate over its `items`, processing them recursively and joining them with the appropriate logical operator (`AND` or `OR`).
 
-- The fields defined in `cursor.filters` **must** be the first in the final `ORDER BY` clause. The direction for these fields comes from `cursor.order`.
-- For example, if `cursor.filters` are `[{field: 'created_at', ...}, {field: 'uuid', ...}]` and `cursor.order` is `ASC`, the query must start with `ORDER BY created_at ASC, uuid ASC`.
+A common pattern is to use a private helper method (like `_buildConditionFromGroup` below) to handle the recursive logic for both `AND` and `OR` groups.
 
-3.  **Apply Additional Orderings:**
+```typescript
+private _buildConditionFromGroup(
+  group: FilterGroup<any>,
+  alias: string,
+  context: PseudoSqlParts,
+): PseudoSqlFilterOutput | undefined {
+  return undefined;
+}
+```
 
-- After the cursor fields, add any other `orderBy` clauses defined in the `Criteria` (root and joins). These should be globally sorted by their `sequenceId` before being added, and should be omitted if the field was already covered by the cursor's ordering.
-- **Important:** The `Criteria` **must** have `orderBy()` defined for the same fields used in `cursor.filters` and in the same direction as `cursor.order`. Although the translator prioritizes cursor fields for the `ORDER BY`, this consistency in the `Criteria` definition is crucial for pagination logic.
+```typescript
+public override visitAndGroup<FieldType extends string>(
+  group: FilterGroup<FieldType>,
+  currentAlias: string,
+  context: PseudoSqlParts,
+): void {}
+```
 
-### 4.4. Field Selection (`setSelect`)
+```typescript
+public override visitOrGroup<FieldType extends string>(
+  group: FilterGroup<FieldType>,
+  currentAlias: string,
+  context: PseudoSqlParts,
+): void {}
+```
 
-- In `visitRoot`, construct the initial `SELECT` clause using `criteria.select` (from the `RootCriteria`).
-- In each `visitJoin...`, if the `joinCriteria.select` has specific fields, add them to the main selection, usually prefixed with the join's alias (e.g., `SELECT root.field1, joined_alias.fieldA`).
-- If `criteria.selectAll` is `true` (or `criteria.select` is empty, which is the default behavior), select all fields from the corresponding schema.
+**Explanation (for `_buildConditionFromGroup` and the `visit...Group` methods):**
 
----
+These methods are responsible for translating `FilterGroup` objects into a combined query condition. The `visitAndGroup` and `visitOrGroup` methods typically call a helper like `_buildConditionFromGroup` and then add the resulting condition to the `TranslationContext`.
 
-## 5. State and Parameter Management
+The `_buildConditionFromGroup` helper's responsibilities include:
 
-Your translator will likely need to manage some state:
+- **Recursive traversal:** It iterates over `group.items`. For each `item` (which can be a `Filter` or another `FilterGroup`), it recursively calls `item.accept(this, currentAlias, context)`.
+- **Collecting conditions and parameters:** It accumulates the condition strings and parameters returned by the recursive `accept` calls.
+- **Combining conditions:** It joins the collected conditions using the `group.logicalOperator` (`AND` or `OR`).
+- **Ensuring grouping:** It wraps the combined conditions in parentheses (e.g., `(condition1 AND condition2)`) to ensure correct logical precedence, especially when mixing `AND` and `OR` groups.
+- **Returning the combined condition:** It returns an object containing the combined condition string and all collected parameters.
 
-- **Query Parameters:** Maintain a list or object for parameterized values. Each time you process a `filter.value` or a pagination value, add it to this collection and use a placeholder in the query.
-- **Parameter Counter:** If you use numbered placeholders (e.g., `$1, $2` or `?`), you'll need a counter.
-- **Accumulated Clauses:** You might have properties in your translator class to build up the different parts of the query (SELECT, FROM, JOINs, WHERE, ORDER BY, etc.).
+**Available `FilterGroup` properties:** `group.items`, `group.logicalOperator`.
+**Available context:** `currentAlias`.
 
-```typescript
-// (Inside your MyCustomTranslator class)
-
-// Example of simple state management:
-// private collectedSelects: string[] = [];
-// private collectedFrom: string = '';
-// private collectedJoins: string[] = [];
-// private collectedWhere: string[] = [];
-// private collectedOrderBy: string[] = [];
-// private collectedLimit?: number;
-// private collectedOffset?: number;
-// private queryParams: any[] = [];
-// private paramCounter: number = 0;
-
-// constructor() {
-//   super();
-//   this.resetState();
-// }
-
-// private resetState(): void {
-//   this.collectedSelects = [];
-//   this.collectedFrom = '';
-//   // ... reset all others
-//   this.queryParams = [];
-//   this.paramCounter = 0;
-// }
-
-// private addQueryParam(value: any): string {
-//   this.queryParams.push(value);
-//   return `?`; // Or $1, $2, etc., depending on your DB
-// }
-
-// The translate method could then assemble these parts.
-// public translate(criteria: RootCriteria<any, any>, initialContext?: any): string {
-//   this.resetState();
-//   criteria.accept(this, initialContext || {}); // Initial context could be an empty object
-//
-//   let sql = `SELECT ${this.collectedSelects.join(', ') || '*'}`;
-//   sql += ` FROM ${this.collectedFrom}`;
-//   if (this.collectedJoins.length > 0) sql += ` ${this.collectedJoins.join(' ')}`;
-//   if (this.collectedWhere.length > 0) sql += ` WHERE ${this.collectedWhere.join(' AND ')}`; // Simplified
-//   if (this.collectedOrderBy.length > 0) sql += ` ORDER BY ${this.collectedOrderBy.join(', ')}`;
-//   if (this.collectedLimit) sql += ` LIMIT ${this.collectedLimit}`;
-//   if (this.collectedOffset) sql += ` OFFSET ${this.collectedOffset}`;
-//   return sql;
-// }
-// public getParameters(): any[] {
-//    return this.queryParams;
-// }
-```
+For a complete implementation, refer to the `visitAndGroup` and `visitOrGroup` methods and the `_buildConditionFromGroup` helper in `src/criteria/translator/example/pseudo-sql.translator.ts`.
 
 ---
 
-## 6. Simplified Example: Pseudo-SQL Translator
+## 4. Handling Ordering, Pagination, and Selection
 
-This very basic example shows the structure, translating to a pseudo-SQL string.
+These logics are generally applied in `visitRoot` after all main joins and filters have been processed.
 
-```typescript
-import {
-  CriteriaTranslator,
-  RootCriteria,
-  InnerJoinCriteria,
-  LeftJoinCriteria,
-  OuterJoinCriteria,
-  Filter,
-  FilterGroup,
-  FilterOperator,
-  OrderDirection,
-  type Order,
-  type CriteriaSchema,
-  type SelectedAliasOf,
-  type PivotJoin,
-  type SimpleJoin,
-  type JoinRelationType,
-} from '@nulledexp/translatable-criteria';
+- **Ordering (`orderBy`):** Your translator should collect all `Order` objects from the root and all joins. At the end, sort this global collection by `order.sequenceId` to ensure a deterministic sort order, and then apply them to the query.
+- **Offset Pagination (`setTake`, `setSkip`):** If `criteria.take > 0` or `criteria.skip > 0`, apply the corresponding `LIMIT` and `OFFSET` to your query.
+- **Cursor Pagination (`setCursor`):** This is more complex. The translator must construct a `WHERE` condition based on `cursor.filters` and `cursor.operator`. The fields from `cursor.filters` must also be the first fields in the `ORDER BY` clause, using the direction from `cursor.order`.
+- **Field Selection (`setSelect`):** In `visitRoot` and `visit...Join`, construct the `SELECT` clause based on `criteria.select`. If `criteria.selectAll` is `true`, select all fields from the schema.
 
-type PseudoSqlParts = {
-  select: string[];
-  from: string;
-  joins: string[];
-  where: string[];
-  orderBy: string[];
-  limit?: number;
-  offset?: number;
-  params: any[];
-};
+---
 
-type PseudoSqlFilterOutput = {
-  condition: string;
-  params: any[];
-};
+## 5. State and Parameter Management
 
-type PseudoSqlTranslationResult = {
-  query: string;
-  params: any[];
-};
+Since the `translate` method is abstract, you are required to implement it. This implementation is where you manage the entire translation lifecycle, including state and parameter management. The recommended pattern is to encapsulate this logic within the translator class and reset it for each `translate()` call.
 
-function escapeField(field: string, alias?: string): string {
-  const escape = (str: string) => `\`${str.replace(/`/g, '``')}\``;
-  return alias ? `${escape(alias)}.${escape(field)}` : escape(field);
-}
+The following example shows the required implementation pattern for the `translate` method:
 
-class PseudoSqlTranslator extends CriteriaTranslator<
+```typescript
+class MyTranslatorWithState extends CriteriaTranslator<
   PseudoSqlParts,
-  PseudoSqlTranslationResult,
+  { query: string; params: any[] },
   PseudoSqlFilterOutput
 > {
-  private paramCounter = 0;
+  private paramCounter: number = 0;
   private collectedOrders: Array<{ alias: string; order: Order<string> }> = [];
 
-  private generateParamPlaceholder(): string {
-    this.paramCounter++;
-    return `?`;
-  }
-
-  public translate(
-    criteria: RootCriteria<any, any>,
-  ): PseudoSqlTranslationResult {
+  public override translate<RootCriteriaSchema extends CriteriaSchema>(
+    criteria: RootCriteria<RootCriteriaSchema>,
+    source: PseudoSqlParts,
+  ): { query: string; params: any[] } {
     this.paramCounter = 0;
     this.collectedOrders = [];
 
-    const initialSqlParts: PseudoSqlParts = {
-      select: [],
-      from: '',
-      joins: [],
-      where: [],
-      orderBy: [],
-      params: [],
-    };
-
-    const finalSqlParts = criteria.accept(this, initialSqlParts);
-
-    let sqlString = `SELECT ${finalSqlParts.select.join(', ') || '*'}`;
-    sqlString += ` FROM ${finalSqlParts.from}`;
-    if (finalSqlParts.joins.length > 0)
-      sqlString += ` ${finalSqlParts.joins.join(' ')}`;
-    if (finalSqlParts.where.length > 0)
-      sqlString += ` WHERE ${finalSqlParts.where.join(' AND ')}`;
-    if (finalSqlParts.orderBy.length > 0)
-      sqlString += ` ORDER BY ${finalSqlParts.orderBy.join(', ')}`;
-    if (finalSqlParts.limit !== undefined)
-      sqlString += ` LIMIT ${finalSqlParts.limit}`;
-    if (finalSqlParts.offset !== undefined)
-      sqlString += ` OFFSET ${finalSqlParts.offset}`;
+    const queryBuilder = source;
 
-    return {
-      query: sqlString,
-      params: finalSqlParts.params,
-    };
-  }
+    criteria.accept(this, queryBuilder);
 
-  visitRoot<
-    RootCriteriaSchema extends CriteriaSchema,
-    RootAlias extends SelectedAliasOf<RootCriteriaSchema>,
-  >(
-    criteria: RootCriteria<RootCriteriaSchema, RootAlias>,
-    sqlParts: PseudoSqlParts,
-  ): PseudoSqlParts {
-    sqlParts.from = `${escapeField(criteria.sourceName)} AS ${escapeField(
-      criteria.alias,
-    )}`;
-    sqlParts.select = criteria.select.map((f) =>
-      escapeField(String(f), criteria.alias),
-    );
-    if (criteria.selectAll && sqlParts.select.length === 0) {
-      sqlParts.select.push(`${escapeField(criteria.alias)}.*`);
+    let sqlString = `SELECT ${queryBuilder.select.join(', ') || '*'}`;
+    sqlString += ` FROM ${queryBuilder.from}`;
+    if (queryBuilder.joins.length > 0) {
+      sqlString += ` ${queryBuilder.joins.join(' ')}`;
     }
-
-    criteria.orders.forEach((order) =>
-      this.collectedOrders.push({ alias: criteria.alias, order }),
-    );
-
-    for (const joinDetail of criteria.joins) {
-      joinDetail.criteria.accept(this, joinDetail.parameters, sqlParts);
+    if (queryBuilder.where.length > 0) {
+      sqlString += ` WHERE ${queryBuilder.where.join(' AND ')}`;
     }
-
-    if (criteria.rootFilterGroup.items.length > 0) {
-      const filterResult = criteria.rootFilterGroup.accept(
-        this,
-        criteria.alias,
-        sqlParts,
-      );
-      if (filterResult.condition) {
-        sqlParts.where.push(filterResult.condition);
-        sqlParts.params.push(...filterResult.params);
-      }
+    if (queryBuilder.orderBy.length > 0) {
+      sqlString += ` ORDER BY ${queryBuilder.orderBy.join(', ')}`;
     }
-
-    const finalOrderByStrings: string[] = [];
-    const appliedOrderFieldsForCursor = new Set<string>();
-
-    if (criteria.cursor) {
-      const cursorFilters = criteria.cursor.filters;
-      const op =
-        criteria.cursor.operator === FilterOperator.GREATER_THAN ? '>' : '<';
-      let cursorWhereCondition = '';
-
-      if (cursorFilters.length === 1) {
-        const primaryFilter = cursorFilters[0]!;
-        const primaryPlaceholder = this.generateParamPlaceholder();
-        sqlParts.params.push(primaryFilter.value);
-        cursorWhereCondition = `(${escapeField(
-          String(primaryFilter.field),
-          criteria.alias,
-        )} ${op} ${primaryPlaceholder})`;
-      } else if (cursorFilters.length === 2) {
-        const primaryFilter = cursorFilters[0]!;
-        const secondaryFilter = cursorFilters[1]!;
-        const primaryPlaceholder = this.generateParamPlaceholder();
-        const secondaryPlaceholder = this.generateParamPlaceholder();
-        sqlParts.params.push(primaryFilter.value, secondaryFilter.value);
-        cursorWhereCondition = `((${escapeField(
-          String(primaryFilter.field),
-          criteria.alias,
-        )} ${op} ${primaryPlaceholder}) OR (${escapeField(
-          String(primaryFilter.field),
-          criteria.alias,
-        )} = ${primaryPlaceholder} AND ${escapeField(
-          String(secondaryFilter.field),
-          criteria.alias,
-        )} ${op} ${secondaryPlaceholder}))`;
-      }
-
-      if (cursorWhereCondition) {
-        sqlParts.where.push(cursorWhereCondition);
-      }
-
-      const cursorOrderDirection = criteria.cursor.order;
-      cursorFilters.forEach((cf) => {
-        const fieldKey = `${criteria.alias}.${String(cf.field)}`;
-        finalOrderByStrings.push(
-          `${escapeField(
-            String(cf.field),
-            criteria.alias,
-          )} ${cursorOrderDirection}`,
-        );
-        appliedOrderFieldsForCursor.add(fieldKey);
-      });
+    if (queryBuilder.limit !== undefined) {
+      sqlString += ` LIMIT ${queryBuilder.limit}`;
     }
-
-    this.collectedOrders
-      .sort((a, b) => a.order.sequenceId - b.order.sequenceId)
-      .forEach(({ alias, order }) => {
-        const fieldKey = `${alias}.${String(order.field)}`;
-        if (!appliedOrderFieldsForCursor.has(fieldKey)) {
-          finalOrderByStrings.push(
-            `${escapeField(String(order.field), alias)} ${order.direction}`,
-          );
-        }
-      });
-
-    if (finalOrderByStrings.length > 0) {
-      sqlParts.orderBy = finalOrderByStrings;
+    if (queryBuilder.offset !== undefined) {
+      sqlString += ` OFFSET ${queryBuilder.offset}`;
     }
 
-    if (criteria.take > 0) sqlParts.limit = criteria.take;
-    if (criteria.skip > 0) sqlParts.offset = criteria.skip;
+    return {
+      query: sqlString,
+      params: queryBuilder.params,
+    };
+  }
 
-    return sqlParts;
+  public override visitRoot<RootCSchema extends CriteriaSchema>(
+    criteria: RootCriteria<RootCSchema>,
+    context: PseudoSqlParts,
+  ): void {
+    // Implementation would go here...
   }
 
-  private applyPseudoJoin<
+  public override visitInnerJoin<
     ParentCSchema extends CriteriaSchema,
-    JoinCriteriaSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCriteriaSchema>,
+    JoinCSchema extends CriteriaSchema,
   >(
-    joinType: string,
-    criteria:
-      | InnerJoinCriteria<JoinCriteriaSchema, JoinAlias>
-      | LeftJoinCriteria<JoinCriteriaSchema, JoinAlias>
-      | OuterJoinCriteria<JoinCriteriaSchema, JoinAlias>,
+    criteria: InnerJoinCriteria<JoinCSchema>,
     parameters:
-      | PivotJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>
-      | SimpleJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>,
-    sqlParts: PseudoSqlParts,
-  ): PseudoSqlParts {
-    const joinTable = `${escapeField(criteria.sourceName)} AS ${escapeField(
-      criteria.alias,
-    )}`;
-    let onCondition = '';
-
-    if ('pivot_source_name' in parameters) {
-      const pivotAlias = `${parameters.parent_alias}_${criteria.alias}_pivot`;
-      const pivotTable = `${escapeField(
-        parameters.pivot_source_name,
-      )} AS ${escapeField(pivotAlias)}`;
-      sqlParts.joins.push(
-        `${joinType} JOIN ${pivotTable} ON ${escapeField(
-          String(parameters.parent_field.reference),
-          parameters.parent_alias,
-        )} = ${escapeField(parameters.parent_field.pivot_field, pivotAlias)}`,
-      );
-      onCondition = `${escapeField(
-        parameters.join_field.pivot_field,
-        pivotAlias,
-      )} = ${escapeField(
-        String(parameters.join_field.reference),
-        criteria.alias,
-      )}`;
-      sqlParts.joins.push(`${joinType} JOIN ${joinTable} ON ${onCondition}`);
-    } else {
-      onCondition = `${escapeField(
-        String(parameters.parent_field),
-        parameters.parent_alias,
-      )} = ${escapeField(String(parameters.join_field), criteria.alias)}`;
-      sqlParts.joins.push(`${joinType} JOIN ${joinTable} ON ${onCondition}`);
-    }
-
-    if (criteria.rootFilterGroup.items.length > 0) {
-      const filterResult = criteria.rootFilterGroup.accept(
-        this,
-        criteria.alias,
-        sqlParts,
-      );
-      if (filterResult.condition) {
-        const lastJoinIndex = sqlParts.joins.length - 1;
-        if (sqlParts.joins[lastJoinIndex]) {
-          sqlParts.joins[lastJoinIndex] += ` AND (${filterResult.condition})`;
-          sqlParts.params.push(...filterResult.params);
-        }
-      }
-    }
-
-    criteria.select.forEach((f) =>
-      sqlParts.select.push(escapeField(String(f), criteria.alias)),
-    );
-    if (criteria.selectAll && criteria.select.length === 0) {
-      sqlParts.select.push(`${escapeField(criteria.alias)}.*`);
-    }
-
-    criteria.orders.forEach((order) =>
-      this.collectedOrders.push({ alias: criteria.alias, order }),
-    );
-
-    for (const subJoinDetail of criteria.joins) {
-      subJoinDetail.criteria.accept(this, subJoinDetail.parameters, sqlParts);
-    }
-
-    return sqlParts;
-  }
-
-  visitInnerJoin(
-    criteria: InnerJoinCriteria<any, any>,
-    parameters: any,
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
     context: PseudoSqlParts,
-  ): PseudoSqlParts {
-    return this.applyPseudoJoin('INNER', criteria, parameters, context);
+  ): void {
+    // Implementation would go here...
   }
-  visitLeftJoin(
-    criteria: LeftJoinCriteria<any, any>,
-    parameters: any,
+
+  public override visitLeftJoin<
+    ParentCSchema extends CriteriaSchema,
+    JoinCSchema extends CriteriaSchema,
+  >(
+    criteria: LeftJoinCriteria<JoinCSchema>,
+    parameters:
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
     context: PseudoSqlParts,
-  ): PseudoSqlParts {
-    return this.applyPseudoJoin('LEFT', criteria, parameters, context);
+  ): void {
+    // Implementation would go here...
   }
-  visitOuterJoin(
-    criteria: OuterJoinCriteria<any, any>,
-    parameters: any,
+
+  public override visitOuterJoin<
+    ParentCSchema extends CriteriaSchema,
+    JoinCSchema extends CriteriaSchema,
+  >(
+    criteria: OuterJoinCriteria<JoinCSchema>,
+    parameters:
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
     context: PseudoSqlParts,
-  ): PseudoSqlParts {
-    return this.applyPseudoJoin('FULL OUTER', criteria, parameters, context);
+  ): void {
+    // Implementation would go here...
   }
 
-  visitFilter<FieldType extends string, Operator extends FilterOperator>(
-    filter: Filter<FieldType, Operator>,
+  public override visitFilter<FieldType extends string>(
+    filter: Filter<FieldType, FilterOperator>,
     currentAlias: string,
+    context: PseudoSqlParts,
   ): PseudoSqlFilterOutput {
-    const fieldName = escapeField(String(filter.field), currentAlias);
-    const params: any[] = [];
-    let condition = '';
-
-    switch (filter.operator) {
-      case FilterOperator.EQUALS:
-        condition = `${fieldName} = ${this.generateParamPlaceholder()}`;
-        params.push(filter.value);
-        break;
-      case FilterOperator.NOT_EQUALS:
-        condition = `${fieldName} != ${this.generateParamPlaceholder()}`;
-        params.push(filter.value);
-        break;
-      case FilterOperator.LIKE:
-      case FilterOperator.CONTAINS:
-      case FilterOperator.STARTS_WITH:
-      case FilterOperator.ENDS_WITH:
-        let val = String(filter.value);
-        if (filter.operator === FilterOperator.CONTAINS) val = `%${val}%`;
-        else if (filter.operator === FilterOperator.STARTS_WITH)
-          val = `${val}%`;
-        else if (filter.operator === FilterOperator.ENDS_WITH) val = `%${val}`;
-        condition = `${fieldName} LIKE ${this.generateParamPlaceholder()}`;
-        params.push(val);
-        break;
-      case FilterOperator.IN:
-        if (!Array.isArray(filter.value) || filter.value.length === 0) {
-          condition = '1=0';
-        } else {
-          const placeholders = (filter.value as any[])
-            .map(() => this.generateParamPlaceholder())
-            .join(', ');
-          condition = `${fieldName} IN (${placeholders})`;
-          params.push(...(filter.value as any[]));
-        }
-        break;
-      case FilterOperator.IS_NULL:
-        condition = `${fieldName} IS NULL`;
-        break;
-      case FilterOperator.IS_NOT_NULL:
-        condition = `${fieldName} IS NOT NULL`;
-        break;
-      case FilterOperator.JSON_CONTAINS:
-        if (typeof filter.value === 'object' && filter.value !== null) {
-          const jsonConditions: string[] = [];
-          for (const path in filter.value) {
-            const pathValue = (filter.value as Record<string, any>)[path];
-            jsonConditions.push(
-              `JSON_CONTAINS(${fieldName}, '${JSON.stringify(
-                pathValue,
-              )}', '$.${path}')`,
-            );
-          }
-          condition = jsonConditions.join(' AND ');
-        } else {
-          condition = '1=0';
-        }
-        break;
-      default:
-        condition = `${fieldName} ${
-          filter.operator
-        } ${this.generateParamPlaceholder()}`;
-        params.push(filter.value);
-    }
-    return {
-      condition,
-      params: params.map((p) => (p === undefined ? null : p)),
-    };
+    // Implementation would go here...
+    return { condition: '', params: [] };
   }
 
-  visitAndGroup<FieldType extends string>(
+  public override visitAndGroup<FieldType extends string>(
     group: FilterGroup<FieldType>,
     currentAlias: string,
-    sqlParts: PseudoSqlParts,
-  ): PseudoSqlFilterOutput {
-    const conditions: string[] = [];
-    const allParams: any[] = [];
-    group.items.forEach((item) => {
-      const result = item.accept(this, currentAlias, sqlParts);
-      if (result.condition) {
-        conditions.push(result.condition);
-        allParams.push(...result.params);
-      }
-    });
-    if (conditions.length === 0) return { condition: '', params: [] };
-    return { condition: `(${conditions.join(' AND ')})`, params: allParams };
+    context: PseudoSqlParts,
+  ): void {
+    // Implementation would go here...
   }
 
-  visitOrGroup<FieldType extends string>(
+  public override visitOrGroup<FieldType extends string>(
     group: FilterGroup<FieldType>,
     currentAlias: string,
-    sqlParts: PseudoSqlParts,
-  ): PseudoSqlFilterOutput {
-    const conditions: string[] = [];
-    const allParams: any[] = [];
-    group.items.forEach((item) => {
-      const result = item.accept(this, currentAlias, sqlParts);
-      if (result.condition) {
-        conditions.push(result.condition);
-        allParams.push(...result.params);
-      }
-    });
-    if (conditions.length === 0) return { condition: '', params: [] };
-    return { condition: `(${conditions.join(' OR ')})`, params: allParams };
+    context: PseudoSqlParts,
+  ): void {
+    // Implementation would go here...
   }
 }
 ```
 
-```typescript
-// Assuming UserSchema and CriteriaFactory are defined
-// import { UserSchema } from './path/to/your/schemas';
-// import { CriteriaFactory, FilterOperator, OrderDirection } from '@nulledexp/translatable-criteria';
+**Explanation:**
+
+The `translate` method you implement is the public entry point. It is responsible for:
 
-// const userCriteria = CriteriaFactory.GetCriteria(UserSchema, 'users')
-//   .where({ field: 'email', operator: FilterOperator.CONTAINS, value: '@example.com' })
-//   .orderBy('username', OrderDirection.ASC)
-//   .setTake(10);
+1.  **Resetting internal state:** Ensures that each translation starts with a clean slate (e.g., `paramCounter` and `collectedOrders` are reset).
+2.  **Initializing the `TranslationContext`:** Creates the initial object (e.g., `queryBuilder`) that will be modified by the `visit...` methods.
+3.  **Starting the traversal:** This is the crucial step where you call `criteria.accept(this, queryBuilder)` to begin the visitor pattern. All subsequent `visit...` methods will modify the `queryBuilder` object directly.
+4.  **Assembling the final query:** After the traversal is complete, it constructs the final query string by combining the accumulated parts from `queryBuilder`.
+5.  **Returning the result:** Returns the final query and its parameters.
 
-// const pseudoTranslator = new PseudoSqlTranslator();
-// const { query: generatedSql, params: queryParams } = pseudoTranslator.translate(userCriteria);
+---
+
+## 6. Complete Example: Pseudo-SQL Translator
+
+### 6.1. Translator Implementation
+
+For a complete, functional example of a `CriteriaTranslator` implementation, please refer to the `src/criteria/translator/example/pseudo-sql.translator.ts` file in the repository. This file contains the full code for the [`PseudoSqlTranslator`](../../../criteria/translator/example/pseudo-sql.translator.ts) class, which translates `Criteria` objects into a pseudo-SQL string.
+
+### 6.2. Translator Usage
+
+Here is how you would use the [`PseudoSqlTranslator`](../../../criteria/translator/example/pseudo-sql.translator.ts):
+
+```typescript
+import {
+  CriteriaFactory,
+  FilterOperator,
+  OrderDirection,
+} from '@nulledexp/translatable-criteria';
+import { UserSchema } from './path/to/your/schemas';
+import {
+  PseudoSqlTranslator,
+  type PseudoSqlParts,
+} from './path/to/your/pseudo-sql.translator';
+
+const userCriteria = CriteriaFactory.GetCriteria(UserSchema)
+  .where({
+    field: 'email',
+    operator: FilterOperator.CONTAINS,
+    value: '@example.com',
+  })
+  .orderBy('username', OrderDirection.ASC)
+  .setTake(10);
+
+const pseudoTranslator = new PseudoSqlTranslator();
+
+const initialParts: PseudoSqlParts = {
+  select: [],
+  from: '',
+  joins: [],
+  where: [],
+  orderBy: [],
+  params: [],
+};
 
-// console.log('Generated SQL:', generatedSql);
-// console.log('Parameters:', queryParams);
+const { query: generatedSql, params: queryParams } = pseudoTranslator.translate(
+  userCriteria,
+  initialParts,
+);
 
-// Expected output (example):
-// Generated SQL: SELECT `users`.`uuid`, `users`.`email`, `users`.`username`, `users`.`created_at` FROM `user` AS `users` WHERE (`users`.`email` LIKE ?) ORDER BY `users`.`username` ASC LIMIT ? OFFSET ?;
-// Parameters: [ '%@example.com%', 10, 0 ]
+console.log('Generated SQL:', generatedSql);
+console.log('Parameters:', queryParams);
 ```
 
 ---
@@ -1132,10 +554,9 @@ class PseudoSqlTranslator extends CriteriaTranslator<
 - **Errors and Validation:** Decide how to handle operators or configurations not supported by your data source. You can throw errors or ignore them.
 - **Optimization:** Consider optimizations specific to your data source.
 - **Testing:** Write thorough unit and integration tests for your translator. Use `CriteriaFactory` to construct various `Criteria` scenarios and verify that your translator's output is as expected.
-- **Documentation:** If you share your translator, clearly document what features it supports and how to use it.
 
 ---
 
 ## Next Steps
 
-With this guide, you have the foundation to start developing your own translators. Review existing translators (if any) for reference and don't hesitate to experiment.
+With this guide, you have the foundation to start developing your own translators. For a detailed reference of all classes and types, consult the API Reference.
diff --git a/src/docs/guides/developing-translators/es.md b/src/docs/guides/developing-translators/es.md
index 29862e6..6408c57 100644
--- a/src/docs/guides/developing-translators/es.md
+++ b/src/docs/guides/developing-translators/es.md
@@ -14,30 +14,28 @@ Esta gua te mostrar los pasos y conceptos clave para desarrollar tu propio `
   - 3.3. [`visitFilter`](#33-visitfilter)
   - 3.4. [`visitAndGroup`, `visitOrGroup`](#34-visitandgroup-visitorgroup)
 - 4. [Manejando Ordenamiento, Paginacin y Seleccin](#4-manejando-ordenamiento-paginacin-y-seleccin)
-  - 4.1. [Ordenamiento (`orderBy`)](#41-ordenamiento-orderby)
-  - 4.2. [Paginacin Offset (`setTake`, `setSkip`)](#42-paginacin-offset-settake-setskip)
-  - 4.3. [Paginacin por Cursor (`setCursor`)](#43-paginacin-por-cursor-setcursor)
-  - 4.4. [Seleccin de Campos (`setSelect`)](#44-seleccin-de-campos-setselect)
 - 5. [Gestin de Estado y Parmetros](#5-gestin-de-estado-y-parmetros)
-- 6. [Ejemplo Simplificado: Traductor a Pseudo-SQL](#6-ejemplo-simplificado-traductor-a-pseudo-sql)
+- 6. [Ejemplo Completo: Traductor a Pseudo-SQL](#6-ejemplo-completo-traductor-a-pseudo-sql)
+  - 6.1. [Implementacin del Traductor](#61-implementacin-del-traductor)
+  - 6.2. [Uso del Traductor](#62-uso-del-traductor)
 - 7. [Consideraciones Adicionales](#7-consideraciones-adicionales)
-- [Prximos Pasos](#prximos-pasos-traductores)
+- [Prximos Pasos](#prximos-pasos)
 
 ---
 
 ## 1. Entendiendo `CriteriaTranslator` y `ICriteriaVisitor`
 
-Como se mencion en los Conceptos Clave, la librera utiliza el patrn de diseo Visitor.
+La librera utiliza el patrn de diseo Visitor.
 
 - **`CriteriaTranslator<TranslationContext, TranslationOutput, TFilterVisitorOutput>`**: Es una clase abstracta que debes extender.
 
-  - `TranslationContext`: El tipo del objeto de contexto que se pasa durante el recorrido del `Criteria` (ej. un constructor de consultas como el `SelectQueryBuilder` de TypeORM, o un objeto donde acumulas partes de una consulta MongoDB).
-  - `TranslationOutput`: El tipo del resultado final de la traduccin (ej. el `SelectQueryBuilder` modificado, una cadena SQL, un objeto de consulta MongoDB).
-  - `TFilterVisitorOutput`: El tipo de salida especfico para los mtodos `visitFilter`, `visitAndGroup` y `visitOrGroup`. Esto permite que los filtros se procesen de manera diferente si es necesario (ej. generando una cadena de condicin, o un objeto de filtro).
+  - `TranslationContext`: El tipo del objeto de contexto mutable que se pasa durante el recorrido del grafo de objetos `Criteria` (ej. una instancia de un constructor de consultas, o un objeto donde acumulas partes de una consulta). Este objeto es modificado directamente por los mtodos `visit...`.
+  - `TranslationOutput` (opcional, por defecto `TranslationContext`): El tipo del resultado final devuelto por el mtodo `translate()`. Tpicamente es el mismo `TranslationContext`, pero puede ser un tipo diferente si tu traductor necesita devolver una versin procesada del contexto (ej. una cadena SQL final a partir de un constructor de consultas).
+  - `TFilterVisitorOutput` (opcional, por defecto `any`): El tipo de salida especfico para el mtodo `visitFilter`. Esto permite que los filtros devuelvan una representacin intermedia (ej. una cadena de condicin y sus parmetros) que luego puede ser integrada en el `TranslationContext` principal. Los mtodos `visitAndGroup` y `visitOrGroup`, sin embargo, devuelven `void` y modifican directamente el `TranslationContext`.
 
 - **`ICriteriaVisitor`**: La interfaz que `CriteriaTranslator` implementa. Define todos los mtodos `visit...` que tu traductor necesitar sobreescribir para manejar cada tipo de nodo en el rbol de `Criteria` (filtros, grupos de filtros, joins, etc.).
 
-El proceso de traduccin generalmente comienza llamando al mtodo `translate()` de tu traductor, el cual internamente llama a `criteria.accept(this, initialContext)`.
+El proceso de traduccin se inicia llamando al mtodo `translate()`, que es un **mtodo abstracto que debes implementar**. Dentro de tu implementacin de `translate`, eres responsable de iniciar el recorrido del visitor llamando a `criteria.accept(this, initialContext)`. El mtodo `accept` de cada componente de `Criteria` llamar entonces al mtodo `visit...` apropiado en tu traductor, pasndole el componente mismo y el `TranslationContext`. Por ejemplo, el mtodo `accept` de un `RootCriteria` llamar a `visitor.visitRoot(...)`, mientras que el `accept` de un `Filter` llamar a `visitor.visitFilter(...)`. Este mecanismo de "doble despacho" es el ncleo del patrn Visitor.
 
 ---
 
@@ -45,1086 +43,508 @@ El proceso de traduccin generalmente comienza llamando al mtodo `translate()
 
 El primer paso es crear una nueva clase que extienda `CriteriaTranslator`. Debers definir los tipos genricos segn lo que tu traductor vaya a producir y necesitar.
 
-```typescript
-import {
-  CriteriaTranslator,
-  RootCriteria,
-  InnerJoinCriteria,
-  // ... otros imports necesarios
-  FilterOperator,
-  type CriteriaSchema,
-  type SelectedAliasOf,
-  type PivotJoin,
-  type SimpleJoin,
-  type JoinRelationType,
-  type Filter,
-  type FilterGroup,
-} from '@nulledexp/translatable-criteria';
+Para los ejemplos conceptuales en esta gua, utilizaremos los siguientes tipos para `TranslationContext` y `TFilterVisitorOutput`, que se alinean con el [`PseudoSqlTranslator`](../../../criteria/translator/example/pseudo-sql.translator.ts) ejemplo:
 
-// Define tus tipos para el contexto y la salida
-// Por ejemplo, si traduces a un constructor de consultas SQL:
-// type MyQueryBuilder = SomeSQLQueryBuilder;
-// type MyFilterCondition = string; // o un objeto de condicin
+Aqu est la estructura bsica de tu clase traductora personalizada, mostrando solo las firmas de los mtodos pblicos que necesitars implementar:
 
-// Para este ejemplo, usaremos tipos simples
-type MyQueryBuilder = {
-  selectFields: string[];
-  fromTable?: string;
+```typescript
+type PseudoSqlParts = {
+  select: string[];
+  from: string;
   joins: string[];
-  conditions: string[];
+  where: string[];
   orderBy: string[];
   limit?: number;
   offset?: number;
   params: any[];
 };
 
-type MyFilterConditionOutput = {
+type PseudoSqlFilterOutput = {
   condition: string;
   params: any[];
 };
 
 export class MyCustomTranslator extends CriteriaTranslator<
-  MyQueryBuilder, // TranslationContext: El objeto que se modifica durante la traduccin
-  MyQueryBuilder, // TranslationOutput: El resultado final de translate()
-  MyFilterConditionOutput // TFilterVisitorOutput: El resultado de visitar filtros/grupos
+  PseudoSqlParts,
+  { query: string; params: any[] },
+  PseudoSqlFilterOutput
 > {
-  private paramCounter = 0;
-
-  private generateParamPlaceholder(): string {
-    // La lgica interna puede variar segn el tipo de placeholder que necesites:
-    // Si usas placeholders nombrados como :p0, :p1 (comn en TypeORM, por ejemplo)
-    // return `:p${this.paramCounter++}`;
-    // Si usas placeholders posicionales como ? (comn en MySQL nativo, SQLite)
-    this.paramCounter++; // Solo para contar si es necesario, el placeholder es fijo
-    return `?`;
-    // O el placeholder especfico de tu BD/ORM.
+  public override translate<RootCriteriaSchema extends CriteriaSchema>(
+    criteria: RootCriteria<RootCriteriaSchema>,
+    source: PseudoSqlParts,
+  ): { query: string; params: any[] } {
+    return { query: '', params: [] };
   }
 
-  // Implementacin de los mtodos visit...
-  // ... (ver secciones siguientes)
-}
-```
-
-En este ejemplo:
-
-- `MyQueryBuilder`: Sera tu clase o interfaz para construir la consulta nativa.
-- `string`: El tipo de salida de los mtodos `visitFilter` y `visitGroup`, asumiendo que generan fragmentos de condicin SQL.
-
----
-
-## 3. Implementando Mtodos `visit...`
-
-Ahora, debes implementar los mtodos abstractos `visit...` de `CriteriaTranslator`.
+  public override visitRoot<RootCSchema extends CriteriaSchema>(
+    criteria: RootCriteria<RootCSchema>,
+    context: PseudoSqlParts,
+  ): void {}
 
-### 3.1. `visitRoot`
+  public override visitInnerJoin<
+    ParentCSchema extends CriteriaSchema,
+    JoinCSchema extends CriteriaSchema,
+  >(
+    criteria: InnerJoinCriteria<JoinCSchema>,
+    parameters:
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
+    context: PseudoSqlParts,
+  ): void {}
 
-Este es el punto de entrada principal para la traduccin de un `RootCriteria`. Aqu es donde tpicamente iniciars tu consulta, procesars los filtros principales, uniones, ordenamiento y paginacin del `RootCriteria`.
+  public override visitLeftJoin<
+    ParentCSchema extends CriteriaSchema,
+    JoinCSchema extends CriteriaSchema,
+  >(
+    criteria: LeftJoinCriteria<JoinCSchema>,
+    parameters:
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
+    context: PseudoSqlParts,
+  ): void {}
 
-```typescript
-  visitRoot<
-    RootCriteriaSchema extends CriteriaSchema,
-    RootAlias extends SelectedAliasOf<RootCriteriaSchema>,
+  public override visitOuterJoin<
+    ParentCSchema extends CriteriaSchema,
+    JoinCSchema extends CriteriaSchema,
   >(
-    criteria: RootCriteria<RootCriteriaSchema, RootAlias>,
-    queryBuilder: MyQueryBuilder, // El contexto inicial
-  ): MyQueryBuilder {
-    this.paramCounter = 0; // Reiniciar contador de parmetros para cada traduccin principal
-
-    // 1. FROM clause
-    queryBuilder.fromTable = `${criteria.sourceName} AS ${criteria.alias}`;
-
-    // 2. SELECT clause
-    queryBuilder.selectFields = criteria.select.map(
-      (field) => `${criteria.alias}.${String(field)}`,
-    );
-    if (criteria.selectAll && queryBuilder.selectFields.length === 0) {
-        queryBuilder.selectFields.push(`${criteria.alias}.*`);
-    }
+    criteria: OuterJoinCriteria<JoinCSchema>,
+    parameters:
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
+    context: PseudoSqlParts,
+  ): void {}
 
+  public override visitFilter<FieldType extends string>(
+    filter: Filter<FieldType, FilterOperator>,
+    currentAlias: string,
+    context: PseudoSqlParts,
+  ): PseudoSqlFilterOutput {
+    return { condition: '', params: [] };
+  }
 
-    // 3. JOINs
-    for (const joinDetail of criteria.joins) {
-      // El contexto (queryBuilder) se pasa y se modifica por los mtodos visitJoin
-      joinDetail.criteria.accept(this, joinDetail.parameters, queryBuilder);
-    }
+  public override visitAndGroup<FieldType extends string>(
+    group: FilterGroup<FieldType>,
+    currentAlias: string,
+    context: PseudoSqlParts,
+  ): void {}
 
-    // 4. WHERE clause for RootCriteria
-    if (criteria.rootFilterGroup.items.length > 0) {
-      const rootFilterResult = criteria.rootFilterGroup.accept(
-        this,
-        criteria.alias,
-        queryBuilder, // El contexto aqu podra ser diferente si los filtros no modifican directamente el QB
-      );
-      if (rootFilterResult.condition) {
-        queryBuilder.conditions.push(rootFilterResult.condition);
-        queryBuilder.params.push(...rootFilterResult.params);
-      }
-    }
+  public override visitOrGroup<FieldType extends string>(
+    group: FilterGroup<FieldType>,
+    currentAlias: string,
+    context: PseudoSqlParts,
+  ): void {}
+}
+```
 
-    // 5. Cursor condition (si existe, se aade al WHERE)
-    if (criteria.cursor) {
-        const cursorFilters = criteria.cursor.filters;
-        const op = criteria.cursor.operator === FilterOperator.GREATER_THAN ? '>' : '<';
-        // const orderDir = criteria.cursor.order; // No usado directamente en este ejemplo de SQL simple
-
-        const primaryCursorFilter = cursorFilters[0]!;
-        const primaryParamName = this.generateParamPlaceholder(); // Usar un nombre de parmetro nico
-        queryBuilder.params.push(primaryCursorFilter.value);
-        let cursorCondition = `(${criteria.alias}.${String(primaryCursorFilter.field)} ${op} :${primaryParamName}`;
-
-        if (cursorFilters.length === 2) {
-            const secondaryCursorFilter = cursorFilters[1]!;
-            const secondaryParamName = this.generateParamPlaceholder(); // Usar un nombre de parmetro nico
-            queryBuilder.params.push(secondaryCursorFilter.value);
-            cursorCondition += ` OR (${criteria.alias}.${String(primaryCursorFilter.field)} = :${primaryParamName} AND ${criteria.alias}.${String(secondaryCursorFilter.field)} ${op} :${secondaryParamName}))`;
-        } else {
-            cursorCondition += `)`;
-        }
-        queryBuilder.conditions.push(cursorCondition);
-
-        // Asegurar que el orderBy del cursor se aplique
-        // En un traductor real, esto podra necesitar lgica ms compleja para asegurar el orden correcto
-        // y evitar duplicados si ya estn en criteria.orders.
-        // Por simplicidad, aqu los aadimos.
-        criteria.orders.forEach(order => { // Asumimos que los orders del cursor estn en criteria.orders
-             queryBuilder.orderBy.push(`${criteria.alias}.${String(order.field)} ${order.direction}`);
-        });
-    }
+En este ejemplo:
 
+- `PseudoSqlParts`: Es nuestro `TranslationContext`, representando las partes acumuladas de la consulta SQL.
+- `{ query: string; params: any[] }`: Es nuestro `TranslationOutput`, el resultado final devuelto por el mtodo `translate()`.
+- `PseudoSqlFilterOutput`: Es nuestro `TFilterVisitorOutput`, el resultado de visitar filtros individuales.
 
-  // 6. ORDER BY
-  // La lgica de ordenamiento debe ser cuidadosa, especialmente con cursores.
-  // El traductor es responsable de:
-  //   a. Si hay un cursor, sus campos de ordenamiento DEBEN tener prioridad.
-  //   b. Luego, se aplican los dems `Order`s definidos en el `RootCriteria` y en los `JoinCriteria`s.
-  //   c. Todos los `Order`s (despus de los del cursor) deben ser ordenados globalmente por su `sequenceId`
-  //      antes de ser aplicados, para mantener un ordenamiento determinista.
-  // (Ver la seccin "4.1. Ordenamiento (orderBy)" y el ejemplo del PseudoSqlTranslator
-  // para una implementacin ms detallada de esta lgica).
-
-  // Ejemplo conceptual simplificado (la lgica real es ms compleja y se muestra en la seccin 4.1 y el ejemplo):
-  if (criteria.cursor) {
-    // Los orderBy del cursor se aplican primero.
-    // Ejemplo: criteria.cursor.filters.forEach(cf => queryBuilder.orderBy.push(`${criteria.alias}.${String(cf.field)} ${criteria.cursor.order}`));
-    // Luego, los dems orders, evitando duplicados y usando sequenceId.
-  } else {
-    // Si no hay cursor, aplicar todos los orders recolectados, ordenados por sequenceId.
-    // Ejemplo:
-    // const allOrders = []; // Recolectar de criteria.orders y de los joins
-    // allOrders.sort((a, b) => a.order.sequenceId - b.order.sequenceId);
-    // allOrders.forEach(({alias, order}) => queryBuilder.orderBy.push(`${alias}.${String(order.field)} ${order.direction}`));
-  }
+---
 
+## Helper: `escapeField`
 
-    // 7. LIMIT / OFFSET
-    if (criteria.take > 0) {
-      queryBuilder.limit = criteria.take;
-    }
-    if (criteria.skip > 0) {
-      queryBuilder.offset = criteria.skip;
-    }
+Muchos traductores necesitarn una funcin de utilidad para escapar correctamente los nombres de campo y prevenir la inyeccin SQL o para ajustarse a la sintaxis del lenguaje de consulta objetivo. Este helper se utiliza en los ejemplos conceptuales a continuacin.
 
-    return queryBuilder;
-  }
+```typescript
+function escapeField(field: string, alias?: string): string {
+  const escape = (str: string) => `\`${str.replace(/`/g, '``')}\``;
+  return alias ? `${escape(alias)}.${escape(field)}` : escape(field);
+}
 ```
 
-**Consideraciones para `visitRoot`:**
+Esta funcin toma un nombre de campo y un alias opcional, y devuelve una cadena con el campo correctamente escapado y prefijado (ej. `` `alias`.`campo` ``).
 
-- **Inicializacin:** Configura la parte `FROM` de tu consulta usando `criteria.sourceName` y `criteria.alias`.
-- **Filtros:** Llama a `criteria.rootFilterGroup.accept(this, criteria.alias, context)` para procesar los filtros del `RootCriteria`. El `context` aqu podra ser tu `queryBuilder` o un objeto donde adjuntar las condiciones.
-- **Joins:** Itera sobre `criteria.joins` y llama a `joinDetail.criteria.accept(this, joinDetail.parameters, context)` para cada uno.
-- **Ordenamiento y Paginacin:** Aplica la lgica de `orderBy`, `take`, `skip` y `cursor` al final.
-- **Seleccin de Campos:** Construye la clusula `SELECT` basada en `criteria.select`.
+---
 
-### 3.2. `visitInnerJoin`, `visitLeftJoin`, `visitOuterJoin`
+## 3. Implementando Mtodos `visit...`
 
-Estos mtodos manejan los diferentes tipos de uniones. Reciben la instancia del `JoinCriteria`, los `parameters` del join (que incluyen informacin del padre y del hijo del join), y el `context`.
+Ahora, debes implementar los mtodos abstractos `visit...` de `CriteriaTranslator`.
 
-```typescript
-  private applyJoin<
-    ParentCSchema extends CriteriaSchema,
-    JoinCriteriaSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCriteriaSchema>,
-  >(
-    joinType: 'INNER' | 'LEFT' | 'OUTER',
-    criteria: // El JoinCriteria actual que se est visitando
-      | InnerJoinCriteria<JoinCriteriaSchema, JoinAlias>
-      | LeftJoinCriteria<JoinCriteriaSchema, JoinAlias>
-      | OuterJoinCriteria<JoinCriteriaSchema, JoinAlias>,
-    parameters:
-      | PivotJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>
-      | SimpleJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>,
-    queryBuilder: MyQueryBuilder, // Contexto: el query builder principal
-  ): MyQueryBuilder {
-    const joinTable = `${criteria.sourceName} AS ${criteria.alias}`;
-    let onCondition = '';
-
-    if ('pivot_source_name' in parameters) {
-      // Many-to-many join
-      const pivotAlias = `${parameters.parent_alias}_${criteria.alias}_pivot`;
-      const pivotTable = `${parameters.pivot_source_name} AS ${pivotAlias}`;
-
-      const firstJoin = `${joinType} JOIN ${pivotTable} ON ${parameters.parent_alias}.${String(parameters.parent_field.reference)} = ${pivotAlias}.${parameters.parent_field.pivot_field}`;
-      queryBuilder.joins.push(firstJoin);
-
-      onCondition = `${pivotAlias}.${parameters.join_field.pivot_field} = ${criteria.alias}.${String(parameters.join_field.reference)}`;
-      queryBuilder.joins.push(`${joinType} JOIN ${joinTable} ON ${onCondition}`);
-    } else {
-      // Simple join
-      onCondition = `${parameters.parent_alias}.${String(parameters.parent_field)} = ${criteria.alias}.${String(parameters.join_field)}`;
-      queryBuilder.joins.push(`${joinType} JOIN ${joinTable} ON ${onCondition}`);
-    }
+### 3.1. `visitRoot`
 
-    // Filtros en el JOIN (se aaden a la clusula ON o como AND despus)
-    if (criteria.rootFilterGroup.items.length > 0) {
-      const joinFilterResult = criteria.rootFilterGroup.accept(
-        this,
-        criteria.alias,
-        queryBuilder,
-      );
-      if (joinFilterResult.condition) {
-        const lastJoinIndex = queryBuilder.joins.length -1;
-        if(queryBuilder.joins[lastJoinIndex]) {
-            queryBuilder.joins[lastJoinIndex] += ` AND (${joinFilterResult.condition})`;
-            queryBuilder.params.push(...joinFilterResult.params);
-        }
-      }
-    }
+Este es el punto de entrada principal para la traduccin de un `RootCriteria`. Aqu es donde tpicamente iniciars tu consulta, procesars los filtros principales, uniones, ordenamiento y paginacin del `RootCriteria`.
 
-    // Seleccin de campos del Join
-    criteria.select.forEach((field) => {
-      queryBuilder.selectFields.push(`${criteria.alias}.${String(field)}`);
-    });
-    if (criteria.selectAll && criteria.select.length === 0) {
-        queryBuilder.selectFields.push(`${criteria.alias}.*`);
-    }
+```typescript
+public override visitRoot<RootCSchema extends CriteriaSchema>(
+  criteria: RootCriteria<RootCSchema>,
+  context: PseudoSqlParts,
+): void {}
+```
 
-    // Recolectar OrderBy del join para aplicarlos globalmente
-    // (Esta lgica podra necesitar refinamiento para asegurar el orden global correcto)
-    criteria.orders.forEach(order => {
-        // Ejemplo: queryBuilder.orderBy.push(`${criteria.alias}.${String(order.field)} ${order.direction}`);
-        // O almacenarlos en una propiedad de la clase para aplicarlos al final en visitRoot.
-    });
-
-    // ***** INICIO DE LA MODIFICACIN PARA JOINS ANIDADOS *****
-    // Si este JoinCriteria (el 'criteria' actual) tiene sus propios joins definidos,
-    // los procesamos recursivamente.
-    for (const subJoinDetail of criteria.joins) {
-      // El 'queryBuilder' (contexto) se sigue pasando y modificando.
-      subJoinDetail.criteria.accept(this, subJoinDetail.parameters, queryBuilder);
-    }
-    // ***** FIN DE LA MODIFICACIN PARA JOINS ANIDADOS *****
+**Explicacin:**
 
-    return queryBuilder;
-  }
+Este mtodo es el punto de partida del proceso de traduccin. Recibe el objeto `RootCriteria` y el `TranslationContext` (nuestro objeto `sqlParts`). Sus responsabilidades principales son:
 
-  visitInnerJoin<
-    ParentCSchema extends CriteriaSchema,
-    JoinCriteriaSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCriteriaSchema>,
-  >(
-    criteria: InnerJoinCriteria<JoinCriteriaSchema, JoinAlias>,
-    parameters:
-      | PivotJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>
-      | SimpleJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>,
-    context: MyQueryBuilder,
-  ): MyQueryBuilder {
-    return this.applyJoin('INNER', criteria, parameters, context);
-  }
+- **Inicializar la clusula `FROM`:** Utiliza `criteria.sourceName` y `criteria.alias` para configurar la tabla principal de la consulta.
+- **Procesar la seleccin de campos:** Mapea `criteria.select` a la clusula `SELECT`, asegurndose de que los campos estn correctamente cualificados con el alias de la entidad.
+- **Manejar uniones:** Itera a travs de `criteria.joins` y llama recursivamente a `accept` en cada `JoinCriteria` para procesar las uniones anidadas.
+- **Procesar filtros raz:** Si `criteria.rootFilterGroup` contiene filtros, llama a `accept` en este grupo para traducirlos en condiciones `WHERE`.
+- **Aplicar paginacin:** Comprueba `criteria.take` y `criteria.skip` para la paginacin basada en offset, y `criteria.cursor` para la paginacin basada en cursor, aadiendo las clusulas `LIMIT`, `OFFSET` o `WHERE` complejas correspondientes.
+- **Recolectar reglas de ordenamiento:** Rene los objetos `Order` de `criteria.orders` para ser aplicados ms tarde.
 
-  visitLeftJoin<
-    ParentCSchema extends CriteriaSchema,
-    JoinCriteriaSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCriteriaSchema>,
-  >(
-    criteria: LeftJoinCriteria<JoinCriteriaSchema, JoinAlias>,
-    parameters:
-      | PivotJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>
-      | SimpleJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>,
-    context: MyQueryBuilder,
-  ): MyQueryBuilder {
-    return this.applyJoin('LEFT', criteria, parameters, context);
-  }
+**Propiedades `Criteria` disponibles:** `criteria.sourceName`, `criteria.alias`, `criteria.select`, `criteria.orders`, `criteria.joins`, `criteria.rootFilterGroup`, `criteria.cursor`, `criteria.take`, `criteria.skip`.
 
-  visitOuterJoin<
-    ParentCSchema extends CriteriaSchema,
-    JoinCriteriaSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCriteriaSchema>,
-  >(
-    criteria: OuterJoinCriteria<JoinCriteriaSchema, JoinAlias>,
-    parameters:
-      | PivotJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>
-      | SimpleJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>,
-    context: MyQueryBuilder,
-  ): MyQueryBuilder {
-    return this.applyJoin('OUTER', criteria, parameters, context);
-  }
-```
+Para una implementacin completa, consulta el mtodo `visitRoot` en `src/criteria/translator/example/pseudo-sql.translator.ts`.
 
-**Consideraciones para los `visitJoin...`:**
-
-- **Tipo de Join:** Usa el tipo de join (`INNER JOIN`, `LEFT JOIN`, etc.) apropiado segn el mtodo `visit...` especfico que se est implementando.
-- **Tabla y Alias:** Usa `criteria.sourceName` y `criteria.alias` para la tabla a la que se est uniendo (el objeto `criteria` es la instancia de `JoinCriteria` pasada al mtodo).
-- **Condicin `ON`:**
-  - Para `SimpleJoin` (relaciones como 'one_to_one', 'one_to_many', 'many_to_one' segn lo definido por `parameters.relation_type`): Construye la condicin `ON` usando `parameters.parent_alias`.`parameters.parent_field` = `criteria.alias`.`parameters.join_field`.
-  - Para `PivotJoin` (relacin 'many_to_many' segn lo definido por `parameters.relation_type`): Tpicamente necesitars dos operaciones de join en tu consulta nativa. La primera une la tabla padre (identificada por `parameters.parent_alias`) con la tabla pivote (`parameters.pivot_source_name`) usando `parameters.parent_field.reference` (del padre) y `parameters.parent_field.pivot_field` (del pivote). La segunda une la tabla pivote con la tabla destino unida (`criteria.sourceName` con alias `criteria.alias`) usando `parameters.join_field.pivot_field` (del pivote) y `parameters.join_field.reference` (del destino).
-- **Accediendo a Metadatos:** El objeto `parameters` (de tipo `PivotJoin` o `SimpleJoin`) pasado a estos mtodos de visita de join contiene:
-  - `parameters.parent_schema_metadata`: Metadatos del `CriteriaSchema` raz del criteria padre.
-  - `parameters.join_metadata`: Metadatos de la configuracin especfica del join en el array `joins` del esquema padre.
-    Los traductores pueden usar estos metadatos para lgica personalizada, como aplicar pistas especficas de la base de datos o manejar condiciones de join personalizadas.
-- **Filtros en el Join:** Si `criteria.rootFilterGroup` (del `JoinCriteria` que se est visitando) tiene filtros, estos deben aplicarse como condiciones adicionales. Esto se hace tpicamente aadindolos a la clusula `ON` del join (ej. `... ON condicion AND (filtros_del_join)`) o como condiciones `WHERE` separadas si la base de datos/ORM lo maneja as para uniones externas. Llama a `criteria.rootFilterGroup.accept(this, criteria.alias, context)` para procesar estos filtros.
-- **Seleccin de Campos del Join:**
-  - Si `criteria.selectAll` (del `JoinCriteria`) es `true`, todos los campos de `criteria.schema.fields` deben aadirse a la seleccin de la consulta principal, prefijados con `criteria.alias`.
-  - Si `criteria.selectAll` es `false`, solo los campos en `criteria.select` deben aadirse, prefijados con `criteria.alias`.
-- **Ordenamiento del Join:** Si `criteria.orders` (del `JoinCriteria`) tiene reglas de ordenamiento, estas deben ser recolectadas. Todos los rdenes recolectados (de la raz y de todos los joins) deben ser ordenados globalmente por su `sequenceId` al final del mtodo `visitRoot` antes de ser aplicados a la consulta final, para asegurar un orden de clasificacin determinista.
-- **Joins Anidados:** De manera crucial, si el `criteria` (el `JoinCriteria` que se est visitando) tiene a su vez `criteria.joins` definidos (es decir, joins encadenados a partir de un join), debes iterar sobre ellos y llamar recursivamente a `subJoinDetail.criteria.accept(this, subJoinDetail.parameters, context)` para procesar estos joins anidados. El `context` (ej. tu constructor de consultas) se pasa y se modifica.
+### 3.2. `visitInnerJoin`, `visitLeftJoin`, `visitOuterJoin`
 
-### 3.3. `visitFilter`
+Estos mtodos manejan los diferentes tipos de uniones. Reciben la instancia del `JoinCriteria`, los `parameters` del join (que incluyen informacin del padre y del hijo del join), y el `context`.
 
-Este mtodo traduce un `Filter` individual a una condicin de tu lenguaje de consulta.
+Para evitar la repeticin de cdigo, una prctica comn es crear un mtodo auxiliar privado (como `applyJoin` a continuacin) que maneje la lgica compartida para todos los tipos de unin.
 
 ```typescript
-    visitFilter<
-FieldType extends string,
-        Operator extends FilterOperator,
+private applyJoin<
+  ParentCSchema extends CriteriaSchema,
+  JoinCSchema extends CriteriaSchema,
 >(
-        filter: Filter<FieldType, Operator>,
-        currentAlias: string,
-        // queryBuilder: MyQueryBuilder, // El contexto puede no ser necesario aqu si solo devolvemos la condicin
-): MyFilterConditionOutput {
-  const fieldName = `${currentAlias}.${String(filter.field)}`;
-  // const paramName = this.generateParamPlaceholder(); // Generar placeholder nico
-  let condition = '';
-  const params: any[] = []; // Array para recolectar parmetros
-
-  switch (filter.operator) {
-    case FilterOperator.EQUALS:
-      const eqParam = this.generateParamPlaceholder();
-      condition = `${fieldName} = ${eqParam}`; // Usar placeholder
-      params.push(filter.value);
-      break;
-    case FilterOperator.NOT_EQUALS:
-      const neqParam = this.generateParamPlaceholder();
-      condition = `${fieldName} != ${neqParam}`;
-      params.push(filter.value);
-      break;
-    case FilterOperator.LIKE:
-      const likeParam = this.generateParamPlaceholder();
-      condition = `${fieldName} LIKE ${likeParam}`;
-      params.push(filter.value); // Asume que el valor ya tiene '%'
-      break;
-    case FilterOperator.CONTAINS: // Podra ser igual que LIKE o usar una funcin especfica
-      const containsParam = this.generateParamPlaceholder();
-      condition = `${fieldName} LIKE ${containsParam}`;
-      params.push(`%${filter.value}%`);
-      break;
-    case FilterOperator.IN:
-      if (Array.isArray(filter.value) && filter.value.length > 0) {
-        const inPlaceholders = filter.value
-                .map(() => this.generateParamPlaceholder())
-                .join(', ');
-        condition = `${fieldName} IN (${inPlaceholders})`;
-        params.push(...filter.value);
-      } else {
-        // Si el array est vaco o no es un array, la condicin es usualmente falsa.
-        condition = '1=0'; // O la forma de tu BD para una condicin siempre falsa
-      }
-      break;
-    case FilterOperator.IS_NULL:
-      condition = `${fieldName} IS NULL`;
-      // No hay parmetros para IS NULL
-      break;
-          // ... Implementar todos los FilterOperator necesarios
-    case FilterOperator.BETWEEN: // NUEVO CASO
-      if (Array.isArray(filter.value) && filter.value.length === 2) {
-        const paramMin = this.generateParamPlaceholder();
-        const paramMax = this.generateParamPlaceholder();
-        condition = `${fieldName} BETWEEN ${paramMin} AND ${paramMax}`;
-        params.push(filter.value[0], filter.value[1]);
-      } else {
-        // Manejar valor invlido para BETWEEN, quizs lanzar error o condicin falsa
-        condition = '1=0'; // Condicin que siempre es falsa
-      }
-      break;
-    case FilterOperator.MATCHES_REGEX: // NUEVO CASO
-      // La implementacin depender de la base de datos (ej. REGEXP en MySQL, ~ en PostgreSQL)
-      const regexParam = this.generateParamPlaceholder();
-      condition = `${fieldName} REGEXP ${regexParam}`; // Ejemplo MySQL
-      params.push(filter.value);
-      break;
-    case FilterOperator.JSON_CONTAINS:
-      // ... (tu implementacin existente para JSON_CONTAINS)
-      // Ejemplo conceptual para MySQL:
-      if (typeof filter.value === 'object' && filter.value !== null) {
-        const conditions: string[] = [];
-        for (const pathKey in filter.value) {
-          const pathValue = (filter.value as Record<string, any>)[pathKey];
-          const currentParamName = this.generateParamPlaceholder();
-          // Ejemplo: JSON_CONTAINS(metadata, '"tech"', '$.tags')
-          // O para igualdad de un valor en una ruta: JSON_EXTRACT(metadata, '$.views') = 100
-          conditions.push(
-                  `JSON_CONTAINS(${fieldName}, CAST(${this.generateParamPlaceholder()} AS JSON), '$.${pathKey}')`,
-          );
-          params.push(pathValue); // El traductor podra necesitar convertir pathValue a string JSON
-        }
-        condition = conditions.join(' AND ');
-      } else {
-        condition = '1=0';
-      }
-      break;
-    case FilterOperator.ARRAY_CONTAINS_ELEMENT:
-      // ... (tu implementacin existente para ARRAY_CONTAINS_ELEMENT)
-      const arrayElemParam = this.generateParamPlaceholder();
-      if (
-              typeof filter.value === 'object' &&
-              filter.value !== null &&
-              !Array.isArray(filter.value)
-      ) {
-        const jsonPath = Object.keys(filter.value)[0]!;
-        const elementToFind = (filter.value as Record<string, any>)[
-                jsonPath
-                ];
-        condition = `JSON_CONTAINS(${fieldName}, CAST(${arrayElemParam} AS JSON), '$.${jsonPath}')`;
-        params.push(elementToFind);
-      } else {
-        condition = `${arrayElemParam} = ANY(${fieldName})`; // Ejemplo PostgreSQL
-        params.push(filter.value);
-      }
-      break;
-    default:
-      throw new Error(
-              `Traductor: Operador de filtro no soportado '${filter.operator}'`,
-      );
-  }
-  // Asegurarse de que los parmetros undefined se conviertan a null si es necesario
-  return { condition, params: params.map((p) => (p === undefined ? null : p)) };
-}
+  joinType: 'INNER' | 'LEFT' | 'FULL OUTER',
+  criteria:
+    | InnerJoinCriteria<JoinCSchema>
+    | LeftJoinCriteria<JoinCSchema>
+    | OuterJoinCriteria<JoinCSchema>,
+  parameters:
+    | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+    | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
+  sqlParts: PseudoSqlParts,
+): void {}
 ```
 
-**Consideraciones para `visitFilter`:**
-
-- **Campo y Alias:** El `currentAlias` te indica a qu entidad pertenece el `filter.field`.
-- **Operador:** Implementa la lgica para cada `FilterOperator` que tu fuente de datos soporte.
-- **Valor:** El `filter.value` debe ser formateado o parametrizado adecuadamente. Para operadores como `IN`, `value` ser un array. Para operadores JSON/Array, `value` puede ser un objeto o un array, y necesitars interpretar la ruta JSON si aplica.
-- **Parametrizacin:** Es **crucial** usar consultas parametrizadas para prevenir inyeccin SQL. No concatenes directamente `filter.value` en la cadena de consulta. En su lugar, usa placeholders y pasa los valores a travs del mecanismo de parmetros de tu constructor de consultas.
-
-### 3.4. `visitAndGroup`, `visitOrGroup`
-
-Estos mtodos manejan grupos de filtros. Reciben un `FilterGroup` y deben iterar sobre sus `items`, procesndolos recursivamente y unindolos con el operador lgico apropiado (`AND` u `OR`).
-
 ```typescript
-  visitAndGroup<FieldType extends string>(
-    group: FilterGroup<FieldType>,
-    currentAlias: string,
-    _context: MyQueryBuilder, // El contexto puede o no ser usado/modificado aqu
-  ): MyFilterConditionOutput {
-    const conditions: string[] = [];
-    const allParams: any[] = [];
-
-    group.items.forEach((item) => {
-      const result = item.accept(this, currentAlias, _context); // _context se pasa
-      if (result.condition) {
-        conditions.push(result.condition);
-        allParams.push(...result.params);
-      }
-    });
-
-    if (conditions.length === 0) return { condition: '', params: [] };
-    return {
-      condition: `(${conditions.join(' AND ')})`,
-      params: allParams,
-    };
-  }
+public override visitInnerJoin<
+  ParentCSchema extends CriteriaSchema,
+  JoinCSchema extends CriteriaSchema,
+>(
+  criteria: InnerJoinCriteria<JoinCSchema>,
+  parameters:
+    | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+    | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
+  context: PseudoSqlParts,
+): void {}
+```
 
-  visitOrGroup<FieldType extends string>(
-    group: FilterGroup<FieldType>,
-    currentAlias: string,
-    _context: MyQueryBuilder,
-  ): MyFilterConditionOutput {
-    const conditions: string[] = [];
-    const allParams: any[] = [];
-
-    group.items.forEach((item) => {
-      const result = item.accept(this, currentAlias, _context);
-      if (result.condition) {
-        conditions.push(result.condition);
-        allParams.push(...result.params);
-      }
-    });
-
-    if (conditions.length === 0) return { condition: '', params: [] };
-    return {
-      condition: `(${conditions.join(' OR ')})`,
-      params: allParams,
-    };
-  }
+```typescript
+public override visitLeftJoin<
+  ParentCSchema extends CriteriaSchema,
+  JoinCSchema extends CriteriaSchema,
+>(
+  criteria: LeftJoinCriteria<JoinCSchema>,
+  parameters:
+    | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+    | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
+  context: PseudoSqlParts,
+): void {}
 ```
 
-**Consideraciones para los `visit...Group`:**
+```typescript
+public override visitOuterJoin<
+  ParentCSchema extends CriteriaSchema,
+  JoinCSchema extends CriteriaSchema,
+>(
+  criteria: OuterJoinCriteria<JoinCSchema>,
+  parameters:
+    | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+    | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
+  context: PseudoSqlParts,
+): void {}
+```
 
-- **Recursin:** Cada `item` en `group.items` puede ser otro `FilterGroup` o un `Filter`. Llama a `item.accept(this, currentAlias, context)` para cada uno.
-- **Agrupacin:** Asegrate de que las condiciones generadas estn correctamente agrupadas con parntesis si es necesario, especialmente al mezclar `AND` y `OR`.
+**Explicacin (para `applyJoin` y los mtodos `visit...Join`):**
 
----
+Estos mtodos son responsables de traducir las condiciones de unin al lenguaje de consulta objetivo. Cada mtodo `visit...Join` simplemente llama al auxiliar `applyJoin`, pasando el `joinType` especfico (ej. 'INNER', 'LEFT', 'FULL OUTER').
 
-## 4. Manejando Ordenamiento, Paginacin y Seleccin
+Las responsabilidades del auxiliar `applyJoin` incluyen:
 
-Estas lgicas generalmente se aplican en `visitRoot` despus de que todas las uniones y filtros principales se hayan procesado.
+- **Construir la clusula `JOIN`:** Utiliza `criteria.sourceName` (la tabla que se est uniendo) y `parameters.join_alias` (su alias en la consulta) para construir la parte `JOIN` de la consulta.
+- **Definir la condicin `ON`:**
+- Para `SimpleJoin` (relaciones uno a uno, uno a muchos, muchos a uno), construye la condicin `ON` utilizando `parameters.parent_alias`.`parameters.parent_field` = `parameters.join_alias`.`parameters.join_field`.
+- Para `PivotJoin` (relaciones muchos a muchos), tpicamente implica dos operaciones `JOIN`: una desde el padre a la tabla pivote, y otra desde la tabla pivote a la tabla destino unida. Construye las condiciones `ON` para ambas.
+- **Aplicar filtros en la unin:** Si `criteria.rootFilterGroup` (del `JoinCriteria` que se est visitando) tiene filtros, los procesa llamando a `criteria.rootFilterGroup.accept(this, parameters.join_alias, context)` y aade sus condiciones a la clusula `ON` utilizando `AND`.
+- **Seleccionar campos de la entidad unida:** Mapea `criteria.select` (del `JoinCriteria`) a la clusula `SELECT` principal, asegurndose de que los campos estn prefijados con `parameters.join_alias`.
+- **Recolectar reglas de ordenamiento:** Aade `criteria.orders` (del `JoinCriteria`) a una coleccin global de rdenes (ej. `this.collectedOrders` en [`PseudoSqlTranslator`](../../../criteria/translator/example/pseudo-sql.translator.ts)) para ser procesadas ms tarde en `visitRoot`.
+- **Procesar uniones anidadas:** Crucialmente, si el `JoinCriteria` que se est visitando tiene `criteria.joins` definidos (es decir, uniones encadenadas a partir de una unin), itera sobre ellos y llama recursivamente a `subJoinDetail.criteria.accept(this, subJoinDetail.parameters, context)` para procesarlos.
 
-### 4.1. Ordenamiento (`orderBy`)
+**Propiedades `Criteria` disponibles:** `criteria.sourceName`, `criteria.alias`, `criteria.select`, `criteria.orders`, `criteria.joins`, `criteria.rootFilterGroup`.
+**Propiedades `parameters` disponibles:** `parameters.parent_alias`, `parameters.join_alias`, `parameters.parent_field`, `parameters.join_field`, `parameters.pivot_source_name`, `parameters.parent_identifier`, `parameters.parent_schema_metadata`, `parameters.join_metadata`.
 
-El ordenamiento define cmo se deben clasificar los resultados de la consulta.
+Para una implementacin completa, consulta los mtodos `visitInnerJoin`, `visitLeftJoin`, `visitOuterJoin` y el auxiliar `applyPseudoJoin` en `src/criteria/translator/example/pseudo-sql.translator.ts`.
 
-- Durante la visita de cada `Criteria` (raz o join) mediante sus respectivos mtodos `visit...`, tu traductor debe **recolectar** todos los objetos `Order` que se hayan definido usando `.orderBy()`. Cada objeto `Order` contiene el campo, la direccin y un `sequenceId` interno nico.
-- Al final del procesamiento en `visitRoot` (despus de haber procesado todos los joins y antes de aplicar `LIMIT`/`OFFSET`):
-  1. Si existe un `criteria.cursor`, los campos definidos en `cursor.filters` deben usarse para generar las **primeras** clusulas de `ORDER BY`, utilizando la direccin especificada en `cursor.order`.
-  2. Luego, toma todos los `Order` recolectados (de la raz y de todos los joins).
-  3. Ordena esta coleccin global de `Order`s por su `sequenceId`. Esto asegura que el orden en que se definieron los `orderBy` a lo largo de la construccin del `Criteria` se respete secuencialmente.
-  4. Convierte estos `Order`s (ya ordenados por secuencia y despus de los del cursor) en las clusulas `ORDER BY` de tu consulta nativa. Asegrate de evitar duplicar campos si ya fueron ordenados por la lgica del cursor.
-- El `order.sequenceId` es crucial para mantener un ordenamiento global determinista y predecible cuando se aplican mltiples `orderBy` en diferentes partes del `Criteria` (tanto en la raz como en los joins anidados).
--
+### 3.3. `visitFilter`
 
-### 4.2. Paginacin Offset (`setTake`, `setSkip`)
+Este mtodo traduce un `Filter` individual a una condicin para tu lenguaje de consulta.
 
-- Si `criteria.take > 0`, aplica un lmite al nmero de resultados.
-- Si `criteria.skip > 0`, omite el nmero especificado de resultados.
+```typescript
+public override visitFilter<FieldType extends string>(
+  filter: Filter<FieldType, FilterOperator>,
+  currentAlias: string,
+  context: PseudoSqlParts,
+): PseudoSqlFilterOutput {
+  return { condition: '', params: [] };
+}
+```
 
-### 4.3. Paginacin por Cursor (`setCursor`)
+**Explicacin:**
 
-Esta es ms compleja y requiere una coordinacin cuidadosa con el ordenamiento. Si `criteria.cursor` est definido:
+Este mtodo es responsable de convertir un objeto `Filter` individual en una cadena de condicin de consulta y de recolectar los parmetros necesarios.
 
-- `cursor.filters`: Proporciona uno o dos `Filter`s (sin el `operator`) que definen los campos y valores del ltimo tem de la pgina anterior.
-  - Un solo `Filter`: Para paginacin simple sobre un campo (ej. `created_at`).
-  - Dos `Filter`s: Para paginacin compuesta (ej. `created_at` y `uuid`).
-- `cursor.operator`: Ser `FilterOperator.GREATER_THAN` (para pgina siguiente) o `FilterOperator.LESS_THAN` (para pgina anterior, si se invierte el orden principal).
-- `cursor.order`: La `OrderDirection` principal en la que se est paginando.
+- **Generar el nombre de campo:** Construye el nombre de campo completamente cualificado utilizando `currentAlias` y `filter.field` (ej. `` `alias`.`campo` ``).
+- **Parametrizacin:** Es **crucial** utilizar placeholders (ej. `?`, `$1`, `:nombreParam`) para `filter.value` para prevenir la inyeccin SQL. Aade `filter.value` a la lista de parmetros de tu `TranslationContext`.
+- **Implementar la lgica del operador:** Utiliza una sentencia `switch` o similar para manejar cada `FilterOperator`. La lgica para cada operador variar segn el lenguaje de consulta objetivo y el tipo esperado de `filter.value` (ej. `BETWEEN` espera una tupla, `IN` espera un array, los operadores JSON esperan objetos).
+- **Devolver la condicin:** Devuelve un objeto que contiene la cadena de condicin generada y los parmetros recolectados.
 
-**Responsabilidades del Traductor:**
+**Propiedades `Filter` disponibles:** `filter.field`, `filter.operator`, `filter.value`.
+**Contexto disponible:** `currentAlias`.
 
-1.  **Construir la Condicin `WHERE` del Cursor:**
+Para una implementacin completa, consulta el mtodo `visitFilter` en `src/criteria/translator/example/pseudo-sql.translator.ts`.
 
-- Para un cursor simple: `WHERE (campo_cursor operador_cursor_traducido valor_cursor)`
-- Para un cursor compuesto: `WHERE ( (campo_orden_primario op_traducido valor_primario_cursor) OR (campo_orden_primario = valor_primario_cursor AND campo_desempate op_traducido valor_desempate_cursor) )`. Ajusta los operadores segn la direccin.
-- **Nota sobre NULLs:** Si un `valor_cursor` es `null`, el traductor debe generar el SQL apropiado (ej. condiciones `IS NULL` o `IS NOT NULL`) en lugar de comparaciones directas como `campo = NULL`.
+### 3.4. `visitAndGroup`, `visitOrGroup`
 
-2.  **Aplicar Ordenamiento del Cursor con Prioridad:**
+Estos mtodos manejan grupos de filtros. Reciben un `FilterGroup` y deben iterar sobre sus `items`, procesndolos recursivamente y unindolos con el operador lgico apropiado (`AND` u `OR`).
 
-- Los campos definidos en `cursor.filters` **deben** ser los primeros en la clusula `ORDER BY` final. La direccin para estos campos viene de `cursor.order`.
-- Por ejemplo, si `cursor.filters` son `[{field: 'created_at', ...}, {field: 'uuid', ...}]` y `cursor.order` es `ASC`, la consulta debe empezar con `ORDER BY created_at ASC, uuid ASC`.
+Un patrn comn es utilizar un mtodo auxiliar privado (como `_buildConditionFromGroup` a continuacin) para manejar la lgica recursiva tanto para grupos `AND` como `OR`.
 
-3.  **Aplicar Ordenamientos Adicionales:**
+```typescript
+private _buildConditionFromGroup(
+  group: FilterGroup<any>,
+  alias: string,
+  context: PseudoSqlParts,
+): PseudoSqlFilterOutput | undefined {
+  return undefined;
+}
+```
 
-- Despus de los campos del cursor, aade los dems `orderBy` que se hayan definido en el `Criteria` (raz y joins). Estos deben ser ordenados globalmente por su `sequenceId` antes de ser aadidos, y se deben omitir si el campo ya fue cubierto por el ordenamiento del cursor.
-- **Importante:** El `Criteria` **debe** tener `orderBy()` definidos para los mismos campos que se usan en `cursor.filters` y en la misma direccin que `cursor.order`. Aunque el traductor prioriza los campos del cursor para el `ORDER BY`, esta consistencia en la definicin del `Criteria` es crucial para la lgica de paginacin.
+```typescript
+public override visitAndGroup<FieldType extends string>(
+  group: FilterGroup<FieldType>,
+  currentAlias: string,
+  context: PseudoSqlParts,
+): void {}
+```
 
-### 4.4. Seleccin de Campos (`setSelect`)
+```typescript
+public override visitOrGroup<FieldType extends string>(
+  group: FilterGroup<FieldType>,
+  currentAlias: string,
+  context: PseudoSqlParts,
+): void {}
+```
 
-- En `visitRoot`, construye la clusula `SELECT` inicial usando `criteria.select` (del `RootCriteria`).
-- En cada `visitJoin...`, si el `joinCriteria.select` tiene campos especficos, adelos a la seleccin principal, usualmente prefijados con el alias del join (ej. `SELECT root.field1, joined_alias.fieldA`).
-- Si `criteria.selectAll` es `true` (o `criteria.select` est vaco y es el comportamiento por defecto), selecciona todos los campos del esquema correspondiente.
+**Explicacin (para `_buildConditionFromGroup` y los mtodos `visit...Group`):**
 
----
+Estos mtodos son responsables de traducir los objetos `FilterGroup` en una condicin de consulta combinada. Los mtodos `visitAndGroup` y `visitOrGroup` tpicamente llaman a un auxiliar como `_buildConditionFromGroup` y luego aaden la condicin resultante al `TranslationContext`.
 
-## 5. Gestin de Estado y Parmetros
+Las responsabilidades del auxiliar `_buildConditionFromGroup` incluyen:
 
-Tu traductor probablemente necesitar gestionar algn estado:
+- **Recorrido recursivo:** Itera sobre `group.items`. Para cada `item` (que puede ser un `Filter` o otro `FilterGroup`), llama recursivamente a `item.accept(this, currentAlias, context)`.
+- **Recolectar condiciones y parmetros:** Acumula las cadenas de condicin y los parmetros devueltos por las llamadas recursivas a `accept`.
+- **Combinar condiciones:** Une las condiciones recolectadas utilizando el `group.logicalOperator` (`AND` u `OR`).
+- **Asegurar el agrupamiento:** Envuelve las condiciones combinadas entre parntesis (ej. `(condicion1 AND condicion2)`) para asegurar la precedencia lgica correcta, especialmente al mezclar grupos `AND` y `OR`.
+- **Aadir al contexto:** Aade la condicin final combinada y sus parmetros a la clusula `where` del `TranslationContext`.
 
-- **Parmetros de Consulta:** Mantn una lista o un objeto para los valores parametrizados. Cada vez que proceses un `filter.value` o un valor de paginacin, adelo a esta coleccin y usa un placeholder en la consulta.
-- **Contador de Parmetros:** Si usas placeholders numerados (ej. `$1, $2` o `?`), necesitars un contador.
-- **Clusulas Acumuladas:** Puedes tener propiedades en tu clase traductora para ir construyendo las diferentes partes de la consulta (SELECT, FROM, JOINs, WHERE, ORDER BY, etc.).
+**Propiedades `FilterGroup` disponibles:** `group.items`, `group.logicalOperator`.
+**Contexto disponible:** `currentAlias`.
 
-```typescript
-// (Dentro de tu clase MyCustomTranslator)
-
-// Ejemplo de gestin de estado simple:
-// private collectedSelects: string[] = [];
-// private collectedFrom: string = '';
-// private collectedJoins: string[] = [];
-// private collectedWhere: string[] = [];
-// private collectedOrderBy: string[] = [];
-// private collectedLimit?: number;
-// private collectedOffset?: number;
-// private queryParams: any[] = [];
-// private paramCounter: number = 0;
-
-// constructor() {
-//   super();
-//   this.resetState();
-// }
-
-// private resetState(): void {
-//   this.collectedSelects = [];
-//   this.collectedFrom = '';
-//   // ... resetear todos los dems
-//   this.queryParams = [];
-//   this.paramCounter = 0;
-// }
-
-// private addQueryParam(value: any): string {
-//   this.queryParams.push(value);
-//   return `?`; // O $1, $2, etc., segn tu DB
-// }
-
-// El mtodo translate podra entonces ensamblar estas partes.
-// public translate(criteria: RootCriteria<any, any>, initialContext?: any): string {
-//   this.resetState();
-//   criteria.accept(this, initialContext || {}); // El contexto inicial podra ser un objeto vaco
-//
-//   let sql = `SELECT ${this.collectedSelects.join(', ') || '*'}`;
-//   sql += ` FROM ${this.collectedFrom}`;
-//   if (this.collectedJoins.length > 0) sql += ` ${this.collectedJoins.join(' ')}`;
-//   if (this.collectedWhere.length > 0) sql += ` WHERE ${this.collectedWhere.join(' AND ')}`; // Simplificado
-//   if (this.collectedOrderBy.length > 0) sql += ` ORDER BY ${this.collectedOrderBy.join(', ')}`;
-//   if (this.collectedLimit) sql += ` LIMIT ${this.collectedLimit}`;
-//   if (this.collectedOffset) sql += ` OFFSET ${this.collectedOffset}`;
-//   return sql;
-// }
-// public getParameters(): any[] {
-//    return this.queryParams;
-// }
-```
+Para una implementacin completa, consulta los mtodos `visitAndGroup` y `visitOrGroup` y el auxiliar `_buildConditionFromGroup` en `src/criteria/translator/example/pseudo-sql.translator.ts`.
 
 ---
 
-## 6. Ejemplo Simplificado: Traductor a Pseudo-SQL
+## 4. Manejando Ordenamiento, Paginacin y Seleccin
 
-Este ejemplo muy bsico muestra la estructura, traduciendo a una cadena de pseudo-SQL.
+Estas lgicas generalmente se aplican en `visitRoot` despus de que todas las uniones y filtros principales se hayan procesado.
 
-```typescript
-import {
-  CriteriaTranslator,
-  RootCriteria,
-  InnerJoinCriteria,
-  LeftJoinCriteria,
-  OuterJoinCriteria,
-  Filter,
-  FilterGroup,
-  FilterOperator,
-  OrderDirection,
-  type Order,
-  type CriteriaSchema,
-  type SelectedAliasOf,
-  type PivotJoin,
-  type SimpleJoin,
-  type JoinRelationType,
-} from '@nulledexp/translatable-criteria';
+- **Ordenamiento (`orderBy`):** Tu traductor debe recolectar todos los objetos `Order` de la raz y de todos los joins. Al final, ordena esta coleccin global por `order.sequenceId` para asegurar un orden de clasificacin determinista, y luego aplcalos a la consulta.
+- **Paginacin Offset (`setTake`, `setSkip`):** Si `criteria.take > 0` o `criteria.skip > 0`, aplica los correspondientes `LIMIT` y `OFFSET` a tu consulta.
+- **Paginacin por Cursor (`setCursor`):** Esta es ms compleja. El traductor debe construir una condicin `WHERE` basada en `cursor.filters` y `cursor.operator`. Los campos de `cursor.filters` tambin deben ser los primeros campos en la clusula `ORDER BY`, usando la direccin de `cursor.order`.
+- **Seleccin de Campos (`setSelect`):** En `visitRoot` y `visit...Join`, construye la clusula `SELECT` basada en `criteria.select`. Si `criteria.selectAll` es `true`, selecciona todos los campos del esquema.
 
-type PseudoSqlParts = {
-  select: string[];
-  from: string;
-  joins: string[];
-  where: string[];
-  orderBy: string[];
-  limit?: number;
-  offset?: number;
-  params: any[];
-};
+---
 
-type PseudoSqlFilterOutput = {
-  condition: string;
-  params: any[];
-};
+## 5. Gestin de Estado y Parmetros
 
-type PseudoSqlTranslationResult = {
-  query: string;
-  params: any[];
-};
+Dado que el mtodo `translate` es abstracto, ests obligado a implementarlo. Esta implementacin es donde gestionas todo el ciclo de vida de la traduccin, incluyendo el estado y los parmetros. El patrn recomendado es encapsular esta lgica dentro de la clase del traductor y reiniciarla para cada llamada a `translate()`.
 
-function escapeField(field: string, alias?: string): string {
-  const escape = (str: string) => `\`${str.replace(/`/g, '``')}\``;
-  return alias ? `${escape(alias)}.${escape(field)}` : escape(field);
-}
+El siguiente ejemplo muestra el patrn de implementacin requerido para el mtodo `translate`:
 
-class PseudoSqlTranslator extends CriteriaTranslator<
+```typescript
+class MyTranslatorWithState extends CriteriaTranslator<
   PseudoSqlParts,
-  PseudoSqlTranslationResult,
+  { query: string; params: any[] },
   PseudoSqlFilterOutput
 > {
-  private paramCounter = 0;
+  private paramCounter: number = 0;
   private collectedOrders: Array<{ alias: string; order: Order<string> }> = [];
 
-  private generateParamPlaceholder(): string {
-    this.paramCounter++;
-    return `?`;
-  }
-
-  public translate(
-    criteria: RootCriteria<any, any>,
-  ): PseudoSqlTranslationResult {
+  public override translate<RootCriteriaSchema extends CriteriaSchema>(
+    criteria: RootCriteria<RootCriteriaSchema>,
+    source: PseudoSqlParts,
+  ): { query: string; params: any[] } {
     this.paramCounter = 0;
     this.collectedOrders = [];
 
-    const initialSqlParts: PseudoSqlParts = {
-      select: [],
-      from: '',
-      joins: [],
-      where: [],
-      orderBy: [],
-      params: [],
-    };
-
-    const finalSqlParts = criteria.accept(this, initialSqlParts);
-
-    let sqlString = `SELECT ${finalSqlParts.select.join(', ') || '*'}`;
-    sqlString += ` FROM ${finalSqlParts.from}`;
-    if (finalSqlParts.joins.length > 0)
-      sqlString += ` ${finalSqlParts.joins.join(' ')}`;
-    if (finalSqlParts.where.length > 0)
-      sqlString += ` WHERE ${finalSqlParts.where.join(' AND ')}`;
-    if (finalSqlParts.orderBy.length > 0)
-      sqlString += ` ORDER BY ${finalSqlParts.orderBy.join(', ')}`;
-    if (finalSqlParts.limit !== undefined)
-      sqlString += ` LIMIT ${finalSqlParts.limit}`;
-    if (finalSqlParts.offset !== undefined)
-      sqlString += ` OFFSET ${finalSqlParts.offset}`;
+    const queryBuilder = source;
 
-    return {
-      query: sqlString,
-      params: finalSqlParts.params,
-    };
-  }
+    criteria.accept(this, queryBuilder);
 
-  visitRoot<
-    RootCriteriaSchema extends CriteriaSchema,
-    RootAlias extends SelectedAliasOf<RootCriteriaSchema>,
-  >(
-    criteria: RootCriteria<RootCriteriaSchema, RootAlias>,
-    sqlParts: PseudoSqlParts,
-  ): PseudoSqlParts {
-    sqlParts.from = `${escapeField(criteria.sourceName)} AS ${escapeField(
-      criteria.alias,
-    )}`;
-    sqlParts.select = criteria.select.map((f) =>
-      escapeField(String(f), criteria.alias),
-    );
-    if (criteria.selectAll && sqlParts.select.length === 0) {
-      sqlParts.select.push(`${escapeField(criteria.alias)}.*`);
+    let sqlString = `SELECT ${queryBuilder.select.join(', ') || '*'}`;
+    sqlString += ` FROM ${queryBuilder.from}`;
+    if (queryBuilder.joins.length > 0) {
+      sqlString += ` ${queryBuilder.joins.join(' ')}`;
     }
-
-    criteria.orders.forEach((order) =>
-      this.collectedOrders.push({ alias: criteria.alias, order }),
-    );
-
-    for (const joinDetail of criteria.joins) {
-      joinDetail.criteria.accept(this, joinDetail.parameters, sqlParts);
+    if (queryBuilder.where.length > 0) {
+      sqlString += ` WHERE ${queryBuilder.where.join(' AND ')}`;
     }
-
-    if (criteria.rootFilterGroup.items.length > 0) {
-      const filterResult = criteria.rootFilterGroup.accept(
-        this,
-        criteria.alias,
-        sqlParts,
-      );
-      if (filterResult.condition) {
-        sqlParts.where.push(filterResult.condition);
-        sqlParts.params.push(...filterResult.params);
-      }
+    if (queryBuilder.orderBy.length > 0) {
+      sqlString += ` ORDER BY ${queryBuilder.orderBy.join(', ')}`;
     }
-
-    const finalOrderByStrings: string[] = [];
-    const appliedOrderFieldsForCursor = new Set<string>();
-
-    if (criteria.cursor) {
-      const cursorFilters = criteria.cursor.filters;
-      const op =
-        criteria.cursor.operator === FilterOperator.GREATER_THAN ? '>' : '<';
-      let cursorWhereCondition = '';
-
-      if (cursorFilters.length === 1) {
-        const primaryFilter = cursorFilters[0]!;
-        const primaryPlaceholder = this.generateParamPlaceholder();
-        sqlParts.params.push(primaryFilter.value);
-        cursorWhereCondition = `(${escapeField(
-          String(primaryFilter.field),
-          criteria.alias,
-        )} ${op} ${primaryPlaceholder})`;
-      } else if (cursorFilters.length === 2) {
-        const primaryFilter = cursorFilters[0]!;
-        const secondaryFilter = cursorFilters[1]!;
-        const primaryPlaceholder = this.generateParamPlaceholder();
-        const secondaryPlaceholder = this.generateParamPlaceholder();
-        sqlParts.params.push(primaryFilter.value, secondaryFilter.value);
-        cursorWhereCondition = `((${escapeField(
-          String(primaryFilter.field),
-          criteria.alias,
-        )} ${op} ${primaryPlaceholder}) OR (${escapeField(
-          String(primaryFilter.field),
-          criteria.alias,
-        )} = ${primaryPlaceholder} AND ${escapeField(
-          String(secondaryFilter.field),
-          criteria.alias,
-        )} ${op} ${secondaryPlaceholder}))`;
-      }
-
-      if (cursorWhereCondition) {
-        sqlParts.where.push(cursorWhereCondition);
-      }
-
-      const cursorOrderDirection = criteria.cursor.order;
-      cursorFilters.forEach((cf) => {
-        const fieldKey = `${criteria.alias}.${String(cf.field)}`;
-        finalOrderByStrings.push(
-          `${escapeField(
-            String(cf.field),
-            criteria.alias,
-          )} ${cursorOrderDirection}`,
-        );
-        appliedOrderFieldsForCursor.add(fieldKey);
-      });
+    if (queryBuilder.limit !== undefined) {
+      sqlString += ` LIMIT ${queryBuilder.limit}`;
     }
-
-    this.collectedOrders
-      .sort((a, b) => a.order.sequenceId - b.order.sequenceId)
-      .forEach(({ alias, order }) => {
-        const fieldKey = `${alias}.${String(order.field)}`;
-        if (!appliedOrderFieldsForCursor.has(fieldKey)) {
-          finalOrderByStrings.push(
-            `${escapeField(String(order.field), alias)} ${order.direction}`,
-          );
-        }
-      });
-
-    if (finalOrderByStrings.length > 0) {
-      sqlParts.orderBy = finalOrderByStrings;
+    if (queryBuilder.offset !== undefined) {
+      sqlString += ` OFFSET ${queryBuilder.offset}`;
     }
 
-    if (criteria.take > 0) sqlParts.limit = criteria.take;
-    if (criteria.skip > 0) sqlParts.offset = criteria.skip;
+    return {
+      query: sqlString,
+      params: queryBuilder.params,
+    };
+  }
 
-    return sqlParts;
+  public override visitRoot<RootCSchema extends CriteriaSchema>(
+    criteria: RootCriteria<RootCSchema>,
+    context: PseudoSqlParts,
+  ): void {
+    // Implementation would go here...
   }
 
-  private applyPseudoJoin<
+  public override visitInnerJoin<
     ParentCSchema extends CriteriaSchema,
-    JoinCriteriaSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCriteriaSchema>,
+    JoinCSchema extends CriteriaSchema,
   >(
-    joinType: string,
-    criteria:
-      | InnerJoinCriteria<JoinCriteriaSchema, JoinAlias>
-      | LeftJoinCriteria<JoinCriteriaSchema, JoinAlias>
-      | OuterJoinCriteria<JoinCriteriaSchema, JoinAlias>,
+    criteria: InnerJoinCriteria<JoinCSchema>,
     parameters:
-      | PivotJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>
-      | SimpleJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>,
-    sqlParts: PseudoSqlParts,
-  ): PseudoSqlParts {
-    const joinTable = `${escapeField(criteria.sourceName)} AS ${escapeField(
-      criteria.alias,
-    )}`;
-    let onCondition = '';
-
-    if ('pivot_source_name' in parameters) {
-      const pivotAlias = `${parameters.parent_alias}_${criteria.alias}_pivot`;
-      const pivotTable = `${escapeField(
-        parameters.pivot_source_name,
-      )} AS ${escapeField(pivotAlias)}`;
-      sqlParts.joins.push(
-        `${joinType} JOIN ${pivotTable} ON ${escapeField(
-          String(parameters.parent_field.reference),
-          parameters.parent_alias,
-        )} = ${escapeField(parameters.parent_field.pivot_field, pivotAlias)}`,
-      );
-      onCondition = `${escapeField(
-        parameters.join_field.pivot_field,
-        pivotAlias,
-      )} = ${escapeField(
-        String(parameters.join_field.reference),
-        criteria.alias,
-      )}`;
-      sqlParts.joins.push(`${joinType} JOIN ${joinTable} ON ${onCondition}`);
-    } else {
-      onCondition = `${escapeField(
-        String(parameters.parent_field),
-        parameters.parent_alias,
-      )} = ${escapeField(String(parameters.join_field), criteria.alias)}`;
-      sqlParts.joins.push(`${joinType} JOIN ${joinTable} ON ${onCondition}`);
-    }
-
-    if (criteria.rootFilterGroup.items.length > 0) {
-      const filterResult = criteria.rootFilterGroup.accept(
-        this,
-        criteria.alias,
-        sqlParts,
-      );
-      if (filterResult.condition) {
-        const lastJoinIndex = sqlParts.joins.length - 1;
-        if (sqlParts.joins[lastJoinIndex]) {
-          sqlParts.joins[lastJoinIndex] += ` AND (${filterResult.condition})`;
-          sqlParts.params.push(...filterResult.params);
-        }
-      }
-    }
-
-    criteria.select.forEach((f) =>
-      sqlParts.select.push(escapeField(String(f), criteria.alias)),
-    );
-    if (criteria.selectAll && criteria.select.length === 0) {
-      sqlParts.select.push(`${escapeField(criteria.alias)}.*`);
-    }
-
-    criteria.orders.forEach((order) =>
-      this.collectedOrders.push({ alias: criteria.alias, order }),
-    );
-
-    for (const subJoinDetail of criteria.joins) {
-      subJoinDetail.criteria.accept(this, subJoinDetail.parameters, sqlParts);
-    }
-
-    return sqlParts;
-  }
-
-  visitInnerJoin(
-    criteria: InnerJoinCriteria<any, any>,
-    parameters: any,
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
     context: PseudoSqlParts,
-  ): PseudoSqlParts {
-    return this.applyPseudoJoin('INNER', criteria, parameters, context);
+  ): void {
+    // Implementation would go here...
   }
-  visitLeftJoin(
-    criteria: LeftJoinCriteria<any, any>,
-    parameters: any,
+
+  public override visitLeftJoin<
+    ParentCSchema extends CriteriaSchema,
+    JoinCSchema extends CriteriaSchema,
+  >(
+    criteria: LeftJoinCriteria<JoinCSchema>,
+    parameters:
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
     context: PseudoSqlParts,
-  ): PseudoSqlParts {
-    return this.applyPseudoJoin('LEFT', criteria, parameters, context);
+  ): void {
+    // Implementation would go here...
   }
-  visitOuterJoin(
-    criteria: OuterJoinCriteria<any, any>,
-    parameters: any,
+
+  public override visitOuterJoin<
+    ParentCSchema extends CriteriaSchema,
+    JoinCSchema extends CriteriaSchema,
+  >(
+    criteria: OuterJoinCriteria<JoinCSchema>,
+    parameters:
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
     context: PseudoSqlParts,
-  ): PseudoSqlParts {
-    return this.applyPseudoJoin('FULL OUTER', criteria, parameters, context);
+  ): void {
+    // Implementation would go here...
   }
 
-  visitFilter<FieldType extends string, Operator extends FilterOperator>(
-    filter: Filter<FieldType, Operator>,
+  public override visitFilter<FieldType extends string>(
+    filter: Filter<FieldType, FilterOperator>,
     currentAlias: string,
+    context: PseudoSqlParts,
   ): PseudoSqlFilterOutput {
-    const fieldName = escapeField(String(filter.field), currentAlias);
-    const params: any[] = [];
-    let condition = '';
-
-    switch (filter.operator) {
-      case FilterOperator.EQUALS:
-        condition = `${fieldName} = ${this.generateParamPlaceholder()}`;
-        params.push(filter.value);
-        break;
-      case FilterOperator.NOT_EQUALS:
-        condition = `${fieldName} != ${this.generateParamPlaceholder()}`;
-        params.push(filter.value);
-        break;
-      case FilterOperator.LIKE:
-      case FilterOperator.CONTAINS:
-      case FilterOperator.STARTS_WITH:
-      case FilterOperator.ENDS_WITH:
-        let val = String(filter.value);
-        if (filter.operator === FilterOperator.CONTAINS) val = `%${val}%`;
-        else if (filter.operator === FilterOperator.STARTS_WITH)
-          val = `${val}%`;
-        else if (filter.operator === FilterOperator.ENDS_WITH) val = `%${val}`;
-        condition = `${fieldName} LIKE ${this.generateParamPlaceholder()}`;
-        params.push(val);
-        break;
-      case FilterOperator.IN:
-        if (!Array.isArray(filter.value) || filter.value.length === 0) {
-          condition = '1=0';
-        } else {
-          const placeholders = (filter.value as any[])
-            .map(() => this.generateParamPlaceholder())
-            .join(', ');
-          condition = `${fieldName} IN (${placeholders})`;
-          params.push(...(filter.value as any[]));
-        }
-        break;
-      case FilterOperator.IS_NULL:
-        condition = `${fieldName} IS NULL`;
-        break;
-      case FilterOperator.IS_NOT_NULL:
-        condition = `${fieldName} IS NOT NULL`;
-        break;
-      case FilterOperator.JSON_CONTAINS:
-        if (typeof filter.value === 'object' && filter.value !== null) {
-          const jsonConditions: string[] = [];
-          for (const path in filter.value) {
-            const pathValue = (filter.value as Record<string, any>)[path];
-            jsonConditions.push(
-              `JSON_CONTAINS(${fieldName}, '${JSON.stringify(
-                pathValue,
-              )}', '$.${path}')`,
-            );
-          }
-          condition = jsonConditions.join(' AND ');
-        } else {
-          condition = '1=0';
-        }
-        break;
-      default:
-        condition = `${fieldName} ${
-          filter.operator
-        } ${this.generateParamPlaceholder()}`;
-        params.push(filter.value);
-    }
-    return {
-      condition,
-      params: params.map((p) => (p === undefined ? null : p)),
-    };
+    // Implementation would go here...
+    return { condition: '', params: [] };
   }
 
-  visitAndGroup<FieldType extends string>(
+  public override visitAndGroup<FieldType extends string>(
     group: FilterGroup<FieldType>,
     currentAlias: string,
-    sqlParts: PseudoSqlParts,
-  ): PseudoSqlFilterOutput {
-    const conditions: string[] = [];
-    const allParams: any[] = [];
-    group.items.forEach((item) => {
-      const result = item.accept(this, currentAlias, sqlParts);
-      if (result.condition) {
-        conditions.push(result.condition);
-        allParams.push(...result.params);
-      }
-    });
-    if (conditions.length === 0) return { condition: '', params: [] };
-    return { condition: `(${conditions.join(' AND ')})`, params: allParams };
+    context: PseudoSqlParts,
+  ): void {
+    // Implementation would go here...
   }
 
-  visitOrGroup<FieldType extends string>(
+  public override visitOrGroup<FieldType extends string>(
     group: FilterGroup<FieldType>,
     currentAlias: string,
-    sqlParts: PseudoSqlParts,
-  ): PseudoSqlFilterOutput {
-    const conditions: string[] = [];
-    const allParams: any[] = [];
-    group.items.forEach((item) => {
-      const result = item.accept(this, currentAlias, sqlParts);
-      if (result.condition) {
-        conditions.push(result.condition);
-        allParams.push(...result.params);
-      }
-    });
-    if (conditions.length === 0) return { condition: '', params: [] };
-    return { condition: `(${conditions.join(' OR ')})`, params: allParams };
+    context: PseudoSqlParts,
+  ): void {
+    // Implementation would go here...
   }
 }
 ```
 
-```typescript
-// ... (definicin de UserSchema, CriteriaFactory, etc.)
+**Explicacin:**
+
+El mtodo `translate` que implementas es el punto de entrada pblico. Es responsable de:
 
-// const userCriteria = CriteriaFactory.GetCriteria(UserSchema, 'users')
-//   .where({ field: 'email', operator: FilterOperator.CONTAINS, value: '@example.com' })
-//   .orderBy('username', OrderDirection.ASC)
-//   .setTake(10);
+1.  **Reiniciar el estado interno:** Asegura que cada traduccin comience con un estado limpio (ej. `paramCounter` y `collectedOrders` se reinician).
+2.  **Inicializar el `TranslationContext`:** Crea el objeto inicial (ej. `queryBuilder`) que ser modificado por los mtodos `visit...`.
+3.  **Iniciar el recorrido:** Este es el paso crucial donde llamas a `criteria.accept(this, queryBuilder)` para comenzar el patrn Visitor. Todos los mtodos `visit...` posteriores modificarn el objeto `queryBuilder` directamente.
+4.  **Ensamblar la consulta final:** Despus de que el recorrido se complete, construye la cadena de consulta final (ej. SQL) combinando las partes acumuladas de `queryBuilder`.
+5.  **Devolver el resultado:** Devuelve la consulta final y sus parmetros.
 
-// const pseudoTranslator = new PseudoSqlTranslator();
-// const { query: generatedSql, params: queryParams } = pseudoTranslator.translate(userCriteria);
+---
+
+## 6. Ejemplo Completo: Traductor a Pseudo-SQL
+
+### 6.1. Implementacin del Traductor
+
+Para un ejemplo completo y funcional de una implementacin de `CriteriaTranslator`, por favor consulta el archivo [`PseudoSqlTranslator`](../../../criteria/translator/example/pseudo-sql.translator.ts) en el repositorio. Este archivo contiene el cdigo completo de la clase [`PseudoSqlTranslator`](../../../criteria/translator/example/pseudo-sql.translator.ts), que traduce objetos `Criteria` a una cadena de pseudo-SQL.
+
+### 6.2. Uso del Traductor
+
+As es como usaras el [`PseudoSqlTranslator`](../../../criteria/translator/example/pseudo-sql.translator.ts):
+
+```typescript
+import {
+  CriteriaFactory,
+  FilterOperator,
+  OrderDirection,
+} from '@nulledexp/translatable-criteria';
+import { UserSchema } from './path/to/your/schemas';
+import {
+  PseudoSqlTranslator,
+  type PseudoSqlParts,
+} from './path/to/your/pseudo-sql.translator';
+
+const userCriteria = CriteriaFactory.GetCriteria(UserSchema)
+  .where({
+    field: 'email',
+    operator: FilterOperator.CONTAINS,
+    value: '@example.com',
+  })
+  .orderBy('username', OrderDirection.ASC)
+  .setTake(10);
+
+const pseudoTranslator = new PseudoSqlTranslator();
+
+const initialParts: PseudoSqlParts = {
+  select: [],
+  from: '',
+  joins: [],
+  where: [],
+  orderBy: [],
+  params: [],
+};
 
-// console.log('Generated SQL:', generatedSql);
-// console.log('Parameters:', queryParams);
+const { query: generatedSql, params: queryParams } = pseudoTranslator.translate(
+  userCriteria,
+  initialParts,
+);
 
-// Salida esperada (ejemplo):
-// Generated SQL: SELECT `users`.`uuid`, `users`.`email`, `users`.`username`, `users`.`created_at` FROM `user` AS `users` WHERE (`users`.`email` LIKE ?) ORDER BY `users`.`username` ASC LIMIT ? OFFSET ?;
-// Parameters: [ '%@example.com%', 10, 0 ]
+console.log('Generated SQL:', generatedSql);
+console.log('Parameters:', queryParams);
 ```
 
 ---
@@ -1134,10 +554,9 @@ class PseudoSqlTranslator extends CriteriaTranslator<
 - **Errores y Validacin:** Decide cmo manejar operadores o configuraciones no soportadas por tu fuente de datos. Puedes lanzar errores o ignorarlos.
 - **Optimizacin:** Considera las optimizaciones especficas de tu fuente de datos.
 - **Pruebas:** Escribe pruebas unitarias y de integracin exhaustivas para tu traductor. Usa `CriteriaFactory` para construir diversos escenarios de `Criteria` y verifica que la salida de tu traductor sea la esperada.
-- **Documentacin:** Si compartes tu traductor, documenta claramente qu caractersticas soporta y cmo usarlo.
 
 ---
 
-## Prximos Pasos Traductores
+## Prximos Pasos
 
-Con esta gua, tienes las bases para empezar a desarrollar tus propios traductores. Revisa los traductores existentes (si los hay) como referencia y no dudes en experimentar.
+Con esta gua, tienes las bases para empezar a desarrollar tus propios traductores. Para una referencia detallada de todas las clases y tipos, consulta la Referencia de API.
diff --git a/src/docs/guides/schema-definitions/en.md b/src/docs/guides/schema-definitions/en.md
index cb76903..f464b43 100644
--- a/src/docs/guides/schema-definitions/en.md
+++ b/src/docs/guides/schema-definitions/en.md
@@ -8,106 +8,114 @@ This guide will show you how to define schemas for your entities using the `GetT
 
 The `GetTypedCriteriaSchema` function is crucial because:
 
-1.  **Preserves Literal Types:** It maintains the exact types of your `fields` and `alias` (e.g., `'uuid' | 'email'` instead of `string`). This is fundamental for autocompletion and strict compile-time validation when you build your `Criteria`.
-2.  **Structural Validation:** Although `GetTypedCriteriaSchema` is an identity function at runtime (it simply returns the object you pass to it), its typing helps ensure that the structure of your schema (presence of `source_name`, `alias`, `fields`, `joins`) is correct.
+1.  **Preserves Literal Types:** It maintains the exact types of your `fields` and `alias` (e.g., `'id' | 'email'` instead of `string`). This is fundamental for autocompletion and strict compile-time validation when you build your `Criteria`.
+
+2.  **Structural Validation:** Although `GetTypedCriteriaSchema` is an identity function at runtime (it simply returns the object you pass to it), its typing helps ensure that the structure of your schema (presence of `source_name`, `alias`, `fields`, `identifier_field`, `joins`) is correct.
 3.  **Avoids `as const`:** It eliminates the need to use `as const` assertions in your schema definitions to achieve literal type preservation, making the code cleaner.
 
 ## Structure of a Schema
 
 A `CriteriaSchema` is defined with the following main fields:
 
+```typescript
+{
+    source_name: string;
+    alias: string;
+    fields: readonly string[];
+    identifier_field: string;
+    joins: readonly {
+        alias: string;
+        target_source_name: string;
+        relation_type: 'one_to_one' | 'one_to_many' | 'many_to_one' | 'many_to_many';
+        metadata?: { [key: string]: any };
+    }[];
+    metadata?: { [key: string]: any };
+}
+```
+
 - `source_name`: (string) The actual name of the table or collection in your database.
-- `alias`: (array of strings) A list of aliases you can use to refer to this entity when building `Criteria`. The first alias is usually the primary or most descriptive one.
-- `fields`: (array of strings) A list of all queryable fields for this entity.
-- `joins`: (array of objects) Defines the relationships this entity has with others. Each join object specifies:
-  - `alias`: (string) The alias you will use to refer to the joined entity (must match one of the `alias` defined in the joined entity's schema).
-  - `join_relation_type`: (string) The type of relationship, such as `'one_to_many'`, `'many_to_one'`, `'one_to_one'`, or `'many_to_many'`.
-  - `metadata`: (optional object) An optional field to store arbitrary, translator-specific information or hints directly within the schema definition for this specific join.
-- `metadata`: (optional object) An optional field at the root of the schema to store arbitrary, translator-specific information or configuration relevant to the entire entity this schema represents.
+- `alias`: (string) A **single, canonical alias** you will use to refer to this entity when it's the root of a query.
+- `fields`: (readonly string[]) A list of all queryable fields for this entity.
+- `identifier_field`: (string) **(Mandatory)** The name of the field that uniquely identifies an entity of this schema (e.g., its primary key). This field **must** be one of the names listed in the `fields` array.
+- `joins`: (readonly object[]) Defines the relationships this entity has with others. Each join object specifies:
+- `alias`: (string) The alias you will use to refer to this specific **join relation** (e.g., `'posts'`, `'author'`). This is the alias you will pass to the `.join()` method.
+- `target_source_name`: (string) The `source_name` of the entity schema you are joining to. This is used for robust validation.
+- `relation_type`: (string) The type of relationship, such as `'one_to_many'`, `'many_to_one'`, or `'many_to_many'`.
+- `metadata`: (optional object) An optional field to store arbitrary, translator-specific information for this specific join.
+- `metadata`: (optional object) An optional field at the root of the schema to store arbitrary, translator-specific information for the entire entity.
 
-## Example: Defining the `UserSchema`
+## Schema Examples
 
-Based on a `User` entity that might have fields like `uuid`, `email`, `username`, `created_at` and relationships with `Address`, `Permission`, and `Post`, here's how we would define its schema:
+To ensure consistency across the documentation, we will use a unified set of schemas. These examples define `User`, `Post`, and `Role` entities and their relationships.
 
 ```typescript
 import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
 
 export const UserSchema = GetTypedCriteriaSchema({
-  source_name: 'user', // Table name in the database
-  alias: ['users', 'user', 'publisher'], // Possible aliases for this entity
-  fields: ['uuid', 'email', 'username', 'created_at'],
+  source_name: 'users',
+  alias: 'u',
+  fields: ['id', 'username', 'email', 'age', 'isActive', 'createdAt', 'tags'],
+  identifier_field: 'id',
   joins: [
     {
-      alias: 'permissions', // Alias for the Permission entity
-      join_relation_type: 'many_to_many',
-    },
-    {
-      alias: 'addresses', // Alias for the Address entity
-      join_relation_type: 'one_to_many',
+      alias: 'posts',
+      target_source_name: 'posts',
+      relation_type: 'one_to_many',
     },
     {
-      alias: 'posts', // Alias for the Post entity
-      join_relation_type: 'one_to_many',
+      alias: 'roles',
+      target_source_name: 'roles',
+      relation_type: 'many_to_many',
     },
   ],
 });
 
-// Export the type for use in your application
-export type UserSchema = typeof UserSchema;
-```
-
-**Breakdown of the `UserSchema` Example:**
-
-- `source_name: 'user'`: Indicates that user data is located in a table/collection named `user`.
-- `alias: ['users', 'user', 'publisher']`: We can refer to the `User` entity as `users`, `user`, or `publisher` when creating `Criteria`.
-- `fields: [...]`: Lists the directly queryable fields of the `User` entity.
-- `joins: [...]`:
-  - Defines a `many_to_many` relationship with an entity whose alias is `permissions`.
-  - Defines a `one_to_many` relationship with an entity whose alias is `addresses`.
-  - Defines a `one_to_many` relationship with an entity whose alias is `posts`.
-
-## Example: Defining the `PostSchema`
-
-Similarly, for a `Post` entity:
-
-```typescript
-import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
-
 export const PostSchema = GetTypedCriteriaSchema({
-  source_name: 'post',
-  alias: ['posts', 'post'],
+  source_name: 'posts',
+  alias: 'p',
   fields: [
-    'uuid',
-    'categories',
+    'id',
     'title',
-    'body',
-    'user_uuid', // Foreign key to the User (publisher)
-    'created_at',
-    'metadata', // Example of a JSON field
+    'content',
+    'userId',
+    'createdAt',
+    'categories',
+    'metadata',
   ],
+  identifier_field: 'id',
   joins: [
     {
-      alias: 'comments', // Alias for the Comment entity
-      join_relation_type: 'one_to_many',
-    },
-    {
-      alias: 'publisher', // Alias for the User entity (the post author)
-      join_relation_type: 'many_to_one',
+      alias: 'user',
+      target_source_name: 'users',
+      relation_type: 'many_to_one',
     },
   ],
 });
 
-export type PostSchema = typeof PostSchema;
+export const RoleSchema = GetTypedCriteriaSchema({
+  source_name: 'roles',
+  alias: 'r',
+  fields: ['id', 'name'],
+  identifier_field: 'id',
+  joins: [],
+});
 ```
 
-**Key Points of the `PostSchema`:**
+### Breakdown of the `UserSchema` Example
+
+- **`source_name: 'users'`**: Indicates that user data is located in a source (e.g., table) named `users`.
+- **`alias: 'u'`**: The canonical alias for the `User` entity is `'u'`. When creating a `RootCriteria` for users, it will be aliased as `u` in the query.
+- **`fields: [...]`**: Lists the directly queryable fields of the `User` entity, including fields like `tags` that can be used with advanced operators.
+- **`identifier_field: 'id'`**: Specifies `id` as the unique identifier for `User` entities.
+- **`joins: [...]`**:
+    - The first join defines a relationship named `'posts'`. This is the alias you will use in the `.join('posts', ...)` method. It targets the `posts` source and is a `one_to_many` relation.
+    - The second join defines a relationship named `'roles'`, targeting the `roles` source with a `many_to_many` relation.
+
+### Breakdown of the `PostSchema` Example
 
-- `fields`: Includes fields like `categories` and `metadata`. These fields might be of complex types (arrays, JSON) in your database, and the library allows filtering them using specific operators (see the guide on building criteria).
-- `user_uuid`: This field likely represents the foreign key to the `User` entity. Although the relationship is defined in `joins`, listing the FK field in `fields` allows direct filtering by it if needed.
-- `joins`:
-  - `comments`: A post can have many comments (`one_to_many`).
-  - `publisher`: A post belongs to one user (`many_to_one`). Note how the `alias` `publisher` here matches one of the `alias` defined in `UserSchema`.
+- **`joins: [...]`**:
+    - Defines a relationship named `'user'`. This allows you to join from a `Post` back to its author (`User`) using `.join('user', ...)`.
 
-## Exporting the Schema Type
+## Next Steps
 
-It is a recommended practice to also export the inferred type of your schema:
+Now that you know how to define schemas, the next step is to learn how to [Build Criteria using these schemas.](../building-criteria/en.md)
\ No newline at end of file
diff --git a/src/docs/guides/schema-definitions/es.md b/src/docs/guides/schema-definitions/es.md
index 9e76e5d..51a0221 100644
--- a/src/docs/guides/schema-definitions/es.md
+++ b/src/docs/guides/schema-definitions/es.md
@@ -8,112 +8,115 @@ Esta gua te mostrar cmo definir esquemas para tus entidades utilizando la
 
 La funcin `GetTypedCriteriaSchema` es crucial porque:
 
-1.  **Preserva los Tipos Literales:** Mantiene los tipos exactos de tus `fields` y `alias` (por ejemplo, `'uuid' | 'email'` en lugar de `string`). Esto es fundamental para el autocompletado y la validacin estricta en tiempo de compilacin cuando construyes tus `Criteria`.
-2.  **Validacin Estructural:** Aunque `GetTypedCriteriaSchema` es una funcin de identidad en tiempo de ejecucin (simplemente devuelve el objeto que le pasas), su tipado ayuda a asegurar que la estructura de tu esquema (presencia de `source_name`, `alias`, `fields`, `joins`) sea correcta.
+1.  **Preserva los Tipos Literales:** Mantiene los tipos exactos de tus `fields` y `alias` (por ejemplo, `'id' | 'email'` en lugar de `string`). Esto es fundamental para el autocompletado y la validacin estricta en tiempo de compilacin cuando construyes tus `Criteria`.
+
+2.  **Validacin Estructural:** Aunque `GetTypedCriteriaSchema` es una funcin de identidad en tiempo de ejecucin (simplemente devuelve el objeto que le pasas), su tipado ayuda a asegurar que la estructura de tu esquema (presencia de `source_name`, `alias`, `fields`, `identifier_field`, `joins`) sea correcta.
 3.  **Evita `as const`:** Elimina la necesidad de usar aserciones `as const` en tus definiciones de esquema para lograr la preservacin de tipos literales, haciendo el cdigo ms limpio.
 
 ## Estructura de un Esquema
 
 Un `CriteriaSchema` se define con los siguientes campos principales:
 
+```typescript
+{
+    source_name: string;
+    alias: string;
+    fields: readonly string[];
+    identifier_field: string;
+    joins: readonly {
+        alias: string;
+        target_source_name: string;
+        relation_type: 'one_to_one' | 'one_to_many' | 'many_to_one' | 'many_to_many';
+        metadata?: { [key: string]: any };
+    }[];
+    metadata?: { [key: string]: any };
+}
+```
+
 - `source_name`: (string) El nombre real de la tabla o coleccin en tu base de datos.
-- `alias`: (array de strings) Una lista de alias que puedes usar para referirte a esta entidad al construir `Criteria`. El primer alias suele ser el principal o el ms descriptivo.
-- `fields`: (array de strings) Una lista de todos los campos consultables para esta entidad.
-- `joins`: (array de objetos) Define las relaciones que esta entidad tiene con otras. Cada objeto de join especifica:
-  - `alias`: (string) El alias que usars para referirte a la entidad unida (debe coincidir con uno de los `alias` definidos en el esquema de la entidad unida).
-  - `join_relation_type`: (string) El tipo de relacin, como `'one_to_many'`, `'many_to_one'`, `'one_to_one'`, o `'many_to_many'`.
-  - `metadata`: (objeto opcional) Un campo opcional para almacenar informacin arbitraria especfica del traductor o pistas directamente dentro de la definicin del esquema para esta unin especfica.
-- `metadata`: (objeto opcional) Un campo opcional en la raz del esquema para almacenar informacin arbitraria especfica del traductor o configuracin relevante para toda la entidad que este esquema representa.
+- `alias`: (string) Un **nico alias cannico** que usars para referirte a esta entidad cuando sea la raz de una consulta.
+- `fields`: (readonly string[]) Una lista de todos los campos consultables para esta entidad.
+- `identifier_field`: (string) **(Obligatorio)** El nombre del campo que identifica unvocamente una entidad de este esquema (ej. su clave primaria). Este campo **debe** ser uno de los nombres listados en el array `fields`.
+- `joins`: (readonly object[]) Define las relaciones que esta entidad tiene con otras. Cada objeto de join especifica:
+- `alias`: (string) El alias que usars para referirte a esta **relacin de unin especfica** (ej. `'posts'`, `'autor'`). Este es el alias que pasars al mtodo `.join()`.
+- `target_source_name`: (string) El `source_name` del esquema de la entidad a la que te ests uniendo. Esto se usa para una validacin robusta.
+- `relation_type`: (string) El tipo de relacin, como `'one_to_many'`, `'many_to_one'`, o `'many_to_many'`.
+- `metadata`: (objeto opcional) Un campo opcional para almacenar informacin arbitraria, especfica del traductor para esta unin especfica.
+- `metadata`: (objeto opcional) Un campo opcional en la raz del esquema para almacenar informacin arbitraria, especfica del traductor para toda la entidad.
 
-## Ejemplo: Definiendo el Esquema `UserSchema`
+## Ejemplos de Esquemas
 
-Basndonos en una entidad `User` que podra tener campos como `uuid`, `email`, `username`, `created_at` y relaciones con `Address`, `Permission` y `Post`, as es como definiramos su esquema:
+Para asegurar la consistencia a lo largo de la documentacin, usaremos un conjunto unificado de esquemas. Estos ejemplos definen las entidades `User`, `Post` y `Role` y sus relaciones.
 
 ```typescript
 import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
 
 export const UserSchema = GetTypedCriteriaSchema({
-  source_name: 'user', // Nombre de la tabla en la base de datos
-  alias: ['users', 'user', 'publisher'], // Posibles alias para esta entidad
-  fields: ['uuid', 'email', 'username', 'created_at'],
+  source_name: 'users',
+  alias: 'u',
+  fields: ['id', 'username', 'email', 'age', 'isActive', 'createdAt', 'tags'],
+  identifier_field: 'id',
   joins: [
     {
-      alias: 'permissions', // Alias para la entidad Permission
-      join_relation_type: 'many_to_many',
-    },
-    {
-      alias: 'addresses', // Alias para la entidad Address
-      join_relation_type: 'one_to_many',
+      alias: 'posts',
+      target_source_name: 'posts',
+      relation_type: 'one_to_many',
     },
     {
-      alias: 'posts', // Alias para la entidad Post
-      join_relation_type: 'one_to_many',
+      alias: 'roles',
+      target_source_name: 'roles',
+      relation_type: 'many_to_many',
     },
   ],
 });
 
-// Exportar el tipo para usarlo en tu aplicacin
-export type UserSchema = typeof UserSchema;
-```
-
-**Desglose del Ejemplo `UserSchema`:**
-
-- `source_name: 'user'`: Indica que los datos de los usuarios se encuentran en una tabla/coleccin llamada `user`.
-- `alias: ['users', 'user', 'publisher']`: Podemos referirnos a la entidad `User` como `users`, `user`, o `publisher` al crear `Criteria`.
-- `fields: [...]`: Lista los campos directamente consultables de la entidad `User`.
-- `joins: [...]`:
-  - Define una relacin `many_to_many` con una entidad cuyo alias es `permissions`.
-  - Define una relacin `one_to_many` con una entidad cuyo alias es `addresses`.
-  - Define una relacin `one_to_many` con una entidad cuyo alias es `posts`.
-
-## Ejemplo: Definiendo el Esquema `PostSchema`
-
-De manera similar, para una entidad `Post`:
-
-```typescript
-import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
-
 export const PostSchema = GetTypedCriteriaSchema({
-  source_name: 'post',
-  alias: ['posts', 'post'],
+  source_name: 'posts',
+  alias: 'p',
   fields: [
-    'uuid',
-    'categories',
+    'id',
     'title',
-    'body',
-    'user_uuid', // Clave fornea al User (publisher)
-    'created_at',
-    'metadata', // Ejemplo de un campo JSON
+    'content',
+    'userId',
+    'createdAt',
+    'categories',
+    'metadata',
   ],
+  identifier_field: 'id',
   joins: [
     {
-      alias: 'comments', // Alias para la entidad Comment
-      join_relation_type: 'one_to_many',
-    },
-    {
-      alias: 'publisher', // Alias para la entidad User (el autor del post)
-      join_relation_type: 'many_to_one',
+      alias: 'user',
+      target_source_name: 'users',
+      relation_type: 'many_to_one',
     },
   ],
 });
 
-export type PostSchema = typeof PostSchema;
-```
+export const RoleSchema = GetTypedCriteriaSchema({
+  source_name: 'roles',
+  alias: 'r',
+  fields: ['id', 'name'],
+  identifier_field: 'id',
+  joins: [],
+});
 
-**Puntos Clave del `PostSchema`:**
+```
 
-- `fields`: Incluye campos como `categories` y `metadata`. Estos campos podran ser de tipos complejos (arrays, JSON) en tu base de datos, y la librera permite filtrarlos usando operadores especficos (ver la gua de construccin de criterios).
-- `user_uuid`: Es un campo que probablemente representa la clave fornea hacia la entidad `User`. Aunque la relacin se define en `joins`, tener el campo de la FK listado en `fields` permite filtrar directamente por l si es necesario.
-- `joins`:
-  - `comments`: Un post puede tener muchos comentarios (`one_to_many`).
-  - `publisher`: Un post pertenece a un usuario (`many_to_one`). Nota cmo el `alias` `publisher` aqu coincide con uno de los `alias` definidos en `UserSchema`.
+### Desglose del Ejemplo `UserSchema`
 
-## Exportando el Tipo del Esquema
+- **`source_name: 'users'`**: Indica que los datos de los usuarios se encuentran en una fuente (ej. tabla) llamada `users`.
+- **`alias: 'u'`**: El alias cannico para la entidad `User` es `'u'`. Al crear un `RootCriteria` para usuarios, se le asignar el alias `u` en la consulta.
+- **`fields: [...]`**: Lista los campos directamente consultables de la entidad `User`, incluyendo campos como `tags` que pueden ser usados con operadores avanzados.
+- **`identifier_field: 'id'`**: Especifica `id` como el identificador nico para las entidades `User`.
+- **`joins: [...]`**:
+  - La primera unin define una relacin llamada `'posts'`. Este es el alias que usars en el mtodo `.join('posts', ...)`. Apunta a la fuente `posts` y es una relacin `one_to_many`.
+  - La segunda unin define una relacin llamada `'roles'`, que apunta a la fuente `roles` con una relacin `many_to_many`.
 
-Es una prctica recomendada exportar tambin el tipo inferido de tu esquema:
+### Desglose del Ejemplo `PostSchema`
 
-Esto te permite usar `UserSchema` (el tipo) en otras partes de tu aplicacin para asegurar la coherencia y aprovechar la seguridad de tipos de TypeScript al interactuar con objetos que deben conformarse a la estructura del esquema.
+- **`joins: [...]`**:
+  - Define una relacin llamada `'user'`. Esto te permite unirte desde un `Post` de vuelta a su autor (`User`) usando `.join('user', ...)`.
 
 ## Prximos Pasos
 
-Ahora que sabes cmo definir esquemas, el siguiente paso es aprender a Construir Criterios utilizando estos esquemas.
+Ahora que sabes cmo definir esquemas, el siguiente paso es aprender a [Construir Criterios utilizando estos esquemas.](../building-criteria/es.md)
diff --git a/src/docs/introduction/en.md b/src/docs/introduction/en.md
index f4aa016..477e10b 100644
--- a/src/docs/introduction/en.md
+++ b/src/docs/introduction/en.md
@@ -10,7 +10,10 @@ in your TypeScript applications.
 (filtering, ordering, joins, pagination, etc.) in an abstract, data-source-agnostic manner.
 
 With `@nulledexp/translatable-criteria`, you define these criteria as structured, type-safe
-objects. This contrasts with writing SQL directly, using a specific ORM's syntax directly
+objects. The library has evolved to offer even more robust schema validation and provide
+richer contextual information to translators, further simplifying the development of
+sophisticated data source integrations.
+This contrasts with writing SQL directly, using a specific ORM's syntax directly
 in your use cases, or developing multiple methods with convoluted and tightly coupled logic
 in your repositories.
 
@@ -23,23 +26,23 @@ for your particular database or data source (e.g., SQL for TypeORM, queries for
 
 ## What Problem Does It Solve?
 
-In many applications, the logic for querying data is mixed with business code or tightly
-coupled to a specific ORM or database. This can lead to:
+Many applications face the challenge of creating flexible and reusable data access logic. A common symptom is the **proliferation of specialized query methods** like `getUserByUuid`, `getUserByEmail`, or `getPostByUuidAndTitleAndCategories`. This approach quickly becomes a maintenance bottleneck.
 
-- **Difficulty changing databases or ORMs:** If you decide to migrate, much of your query
-  code needs to be rewritten.
-- **Complexity in business logic:** Complex queries can become difficult to read, maintain,
-  and test.
-- **Code repetition:** Similar filtering or pagination logic might be duplicated in
-  different parts of the application.
-- **Reduced testability:** Testing query logic in isolation becomes complicated.
+This problem is compounded because the "context" of a query can change. For example, fetching a post for a regular user is not the same as fetching it for its author, a moderator, or an analytics service. Each context may require different fields, joins, or filters. This leads to:
 
-`@nulledexp/translatable-criteria` addresses these problems by:
+- **Method Explosion:** A constant need to write new methods for every minor variation in filtering, coupling the data access layer to specific use cases.
+- **Maintenance Burden:** New business requirements often force developers to create more and more methods, increasing complexity and the risk of bugs.
+- **Tight Coupling:** The application logic becomes tightly coupled to a specific data source or ORM, making future migrations or changes difficult.
+- **Contextual Complexity:** The logic to handle different access contexts (e.g., user vs. admin) gets scattered and duplicated.
 
-- **Decoupling query definition from execution:** Define _what_ data you need, not _how_ to get it from a specific source.
-- **Promoting reusability:** Criteria can be built, combined, and reused.
-- **Improving type safety:** Thanks to schemas, you can build criteria with compile-time and runtime validation.
-- **Facilitating testing:** You can test criteria construction logic independently.
+`@nulledexp/translatable-criteria` provides a more abstract and ideal solution. By allowing you to build query specifications dynamically, it addresses these issues by:
+
+- **Decoupling query definition from execution:** Define _what_ data you need, not _how_ to get it.
+- **Promoting reusability:** A single query method can handle countless variations by accepting a `Criteria` object.
+- **Improving type safety:** Build criteria with strong compile-time validation.
+- **Facilitating testing:** Test query construction logic independently of the database.
+
+While adopting any library introduces a degree of coupling, `@nulledexp/translatable-criteria` offers a strategic trade-off. You couple your application to a predictable and maintainable query-building flow in exchange for **decoupling your business logic from the underlying data source and its specific implementation**. This results in a more manageable, predictable, and adaptable architecture in the long run.
 
 ## Who Is This Library For?
 
@@ -53,11 +56,11 @@ This library is ideal for developers and teams who:
 
 ## Key Benefits
 
-- **Enhanced Type Safety:** Build queries with a fluent, strongly-typed interface.
-- **Powerful Filtering:** Define intricate filtering logic with multiple operators and grouping.
-- **Flexible Join System:** Support for various join types and pivot table configurations.
-- **Advanced Pagination:** Support for offset-based and cursor-based pagination.
-- **Extensible Architecture:** Create your own translators for any data source.
+- **[Enhanced Type Safety](../guides/schema-definitions/en.md):** Build queries with a fluent, strongly-typed interface, including robust schema validation and type-checked filter values.
+- **[Powerful Filtering](../guides/building-criteria/en.md#2-applying-filters):** Define intricate filtering logic with a wide array of operators (including for JSON, arrays, sets, ranges, and regex) and logical grouping.
+- **[Flexible Join System](../guides/building-criteria/en.md#3-adding-joins):** Support for various join types and pivot table configurations, with improved context for translators.
+- **[Advanced Pagination](../guides/building-criteria/en.md#5-pagination):** Support for offset-based and cursor-based pagination.
+- **[Extensible Architecture](../guides/developing-translators/en.md):** Create your own translators for any data source, aided by more comprehensive join information.
 
 ## How Is This Documentation Structured?
 
diff --git a/src/docs/introduction/es.md b/src/docs/introduction/es.md
index a3fdaa2..1a6f75a 100644
--- a/src/docs/introduction/es.md
+++ b/src/docs/introduction/es.md
@@ -10,38 +10,40 @@ datos complejas en tus aplicaciones TypeScript.
 (filtrado, ordenamiento, uniones, paginacin, etc.) de una manera abstracta y agnstica a la
 fuente de datos.
 
-Con `@nulledexp/translatable-criteria` , defines estos criterios como objetos estructurados y con
-seguridad de tipos. Esto contrasta con la escritura directa de SQL, el uso de la sintaxis de un
+Con `@nulledexp/translatable-criteria`, defines estos criterios como objetos estructurados y con
+seguridad de tipos. La librera ha evolucionado para ofrecer una validacin de esquemas an ms
+robusta y proporcionar informacin contextual ms rica a los traductores, simplificando an ms
+el desarrollo de integraciones sofisticadas con fuentes de datos.
+Esto contrasta con la escritura directa de SQL, el uso de la sintaxis de un
 ORM especfico directamente en los casos de uso, o el desarrollo de mltiples mtodos con
 lgica compleja y fuertemente acoplada en los repositorios.
 
 La idea central es que estos "criterios traducibles" puedan ser luego procesados por un
 **Traductor** especfico (que t o la comunidad pueden implementar) para generar la consulta
-nativa para tu base de datos o fuente de datos particular (por ejemplo, SQL para TypeORM,  
-consultas para MongoDB, etc.).
+nativa para tu base de datos o fuente de datos particular (por ejemplo, SQL para TypeORM, consultas para MongoDB, etc.).
 
 - **[Traductor TypeOrm(MySql)](https://www.npmjs.com/package/@nulledexp/typeorm-mysql-criteria-translator)**
-  - Author: [Nelson Cabrera](https://github.com/Techscq)
+  - Autor: [Nelson Cabrera](https://github.com/Techscq)
 
 ## Qu Problema Resuelve?
 
-En muchas aplicaciones, la lgica para consultar datos se encuentra mezclada con el cdigo de  
-negocio o fuertemente acoplada a un ORM o base de datos especfica. Esto puede llevar a:
+Muchas aplicaciones se enfrentan al desafo de crear una lgica de acceso a datos flexible y reutilizable. Un sntoma comn es la **proliferacin de mtodos de consulta especializados** como `getUserByUuid`, `getUserByEmail` o `getPostByUuidAndTitleAndCategories`. Este enfoque se convierte rpidamente en un cuello de botella para el mantenimiento.
 
-- **Dificultad para cambiar de base de datos o ORM:** Si decides migrar, gran parte de tu cdigo
-  de consulta necesita ser reescrito.
-- **Complejidad en la lgica de negocio:** Las consultas complejas pueden volverse difciles de
-  leer, mantener y probar.
-- **Repeticin de cdigo:** Lgicas de filtrado o paginacin similares pueden estar duplicadas
-  en diferentes partes de la aplicacin.
-- **Menor testeabilidad:** Probar la lgica de consulta de forma aislada se vuelve complicado.
+Este problema se agrava porque el "contexto" de una consulta puede cambiar. Por ejemplo, obtener un post para un usuario regular no es lo mismo que obtenerlo para su autor, un moderador o un servicio de analtica. Cada contexto puede requerir diferentes campos, uniones o filtros. Esto conduce a:
 
-`@nulledexp/translatable-criteria` aborda estos problemas al:
+- **Explosin de Mtodos:** Una necesidad constante de escribir nuevos mtodos para cada pequea variacin en el filtrado, acoplando la capa de acceso a datos a casos de uso especficos.
+- **Carga de Mantenimiento:** Los nuevos requisitos de negocio a menudo obligan a los desarrolladores a crear ms y ms mtodos, aumentando la complejidad y el riesgo de errores.
+- **Acoplamiento Fuerte:** La lgica de la aplicacin se acopla fuertemente a una fuente de datos u ORM especfico, dificultando futuras migraciones o cambios.
+- **Complejidad Contextual:** La lgica para manejar diferentes contextos de acceso (ej. usuario vs. administrador) se dispersa y duplica.
 
-- **Desacoplar la definicin de la consulta de su ejecucin:** Define _qu_ datos necesitas, no _cmo_ obtenerlos de una fuente especfica.
-- **Promover la reutilizacin:** Los criterios pueden ser construidos, combinados y reutilizados.
-- **Mejorar la seguridad de tipos:** Gracias a los esquemas, puedes construir criterios con validacin en tiempo de compilacin y ejecucin.
-- **Facilitar las pruebas:** Puedes probar la lgica de construccin de criterios de forma independiente.
+`@nulledexp/translatable-criteria` proporciona una solucin ms abstracta e ideal. Al permitirte construir especificaciones de consulta de forma dinmica, aborda estos problemas al:
+
+- **Desacoplar la definicin de la consulta de su ejecucin:** Define _qu_ datos necesitas, no _cmo_ obtenerlos.
+- **Promover la reutilizacin:** Un nico mtodo de consulta puede manejar innumerables variaciones al aceptar un objeto `Criteria`.
+- **Mejorar la seguridad de tipos:** Construye criterios con una fuerte validacin en tiempo de compilacin.
+- **Facilitar las pruebas:** Prueba la lgica de construccin de consultas independientemente de la base de datos.
+
+Si bien adoptar cualquier librera introduce un grado de acoplamiento, `@nulledexp/translatable-criteria` ofrece una compensacin estratgica. Acoplas tu aplicacin a un flujo de construccin de consultas predecible y mantenible a cambio de **desacoplar tu lgica de negocio de la fuente de datos subyacente y su implementacin especfica**. Esto resulta en una arquitectura ms manejable, predecible y adaptable a largo plazo.
 
 ## Para Quin es Esta Librera?
 
@@ -55,11 +57,11 @@ Esta librera es ideal para desarrolladores y equipos que:
 
 ## Principales Beneficios
 
-- **Seguridad de Tipos Mejorada:** Construye consultas con una interfaz fluida y fuertemente tipada.
-- **Filtrado Potente:** Define lgica de filtrado intrincada con mltiples operadores y agrupacin.
-- **Sistema de Uniones (Joins) Flexible:** Soporte para varios tipos de join y configuraciones de tablas pivote.
-- **Paginacin Avanzada:** Soporte para paginacin basada en offset y en cursor.
-- **Arquitectura Extensible:** Crea tus propios traductores para cualquier fuente de datos.
+- **[Seguridad de Tipos Mejorada](../guides/schema-definitions/es.md):** Construye consultas con una interfaz fluida y fuertemente tipada, incluyendo validacin de esquemas robusta y valores de filtro tipados.
+- **[Filtrado Potente](../guides/building-criteria/es.md#2-aplicando-filtros):** Define lgica de filtrado intrincada con una amplia gama de operadores (incluyendo para JSON, arrays, sets, rangos y regex) y agrupacin lgica.
+- **[Sistema de Uniones (Joins) Flexible](../guides/building-criteria/es.md#3-aadiendo-uniones-joins):** Soporte para varios tipos de join y configuraciones de tablas pivote, con contexto mejorado para los traductores.
+- **[Paginacin Avanzada](../guides/building-criteria/es.md#5-paginacin):** Soporte para paginacin basada en offset y en cursor.
+- **[Arquitectura Extensible](../guides/developing-translators/es.md):** Crea tus propios traductores para cualquier fuente de datos, ayudado por informacin de join ms completa.
 
 ## Cmo se Estructura esta Documentacin?
 
@@ -70,7 +72,7 @@ Para ayudarte a sacar el mximo provecho de `@nulledexp/translatable-criteria`,
   fundamentales como
   `Criteria`,
   `CriteriaFactory`, `Schemas`, y la interfaz `CriteriaTranslator`.
-- [**Guas Prcticas:**](../guides/)
+- **Guas Prcticas:**
   - [Definicin de Esquemas.](../guides/schema-definitions/es.md)
   - [Construccin de Criterios (filtros, joins, ordenamiento, paginacin).](../guides/building-criteria/es.md)
   - [Desarrollo de Traductores Personalizados.](../guides/developing-translators/es.md)
diff --git a/src/docs/use-cases/en.md b/src/docs/use-cases/en.md
index 570df19..bd0d234 100644
--- a/src/docs/use-cases/en.md
+++ b/src/docs/use-cases/en.md
@@ -1,465 +1,242 @@
-# Practical Guide: Usage Examples
+# Practical Guide: Dynamic Criteria Building
 
-The previous guides have shown you how to [Define Schemas](../guides/schema-definitions/en.md) and [Build Criteria](../guides/building-criteria/en.md). Now, let's see how these pieces fit together in a more realistic application scenario.
+The previous guides have shown you how to [Define Schemas](../guides/schema-definitions/en.md) and [Build Criteria](../guides/building-criteria/en.md). Now, let's see how these pieces fit together in a more realistic, dynamic application scenario.
 
-This guide presents a complete example demonstrating the construction of a complex `Criteria` and how it could be used by a repository to query data.
+This guide presents a complete example demonstrating the construction of a complex `Criteria` object based on optional input parameters, such as those from an API request. The goal is to illustrate how the library can be used to solve problems in a subtle, orderly, and decoupled manner, regardless of whether the context is simple or highly complex.
 
 ## Index
 
 - 1. [The Example Scenario](#1-the-example-scenario)
-- 2. [Schema Definition (Reminder)](#2-schema-definition-reminder)
-- 3. [Building the Complex Criteria](#3-building-the-complex-criteria)
-- 4. [Using Criteria in a Repository](#4-using-criteria-in-a-repository)
-  - 4.1. [Repository Interface](#41-repository-interface)
-  - 4.1.1. [Optimizing Read Models with `setSelect`](#411-optimizing-read-models-with-setselect)
-  - 4.2. [Repository Implementation (Conceptual)](#42-repository-implementation-conceptual)
-  - 4.3. [Repository Usage](#43-repository-usage)
-- 5. [Translation (Brief Mention)](#5-translation-brief-mention)
-- 6. [Conclusion](#6-conclusion)
+- 2. [Schema Definitions (Reminder)](#2-schema-definitions-reminder)
+- 3. [Building the Dynamic Criteria](#3-building-the-dynamic-criteria)
+- 4. [The Helper Function: A Good Practice](#4-the-helper-function-a-good-practice)
+- 5. [Conclusion: A Philosophy of Flexibility](#5-conclusion-a-philosophy-of-flexibility)
 
 ---
 
 ## 1. The Example Scenario
 
-Imagine you need to implement a paginated user search functionality. The specific requirement is:
+Imagine you are building an API endpoint to search for blog posts. The endpoint must support filtering by various optional parameters like title, body content, tags, and author details. It also needs to handle different pagination strategies (offset and cursor-based).
 
-> Obtain a paginated list of users whose email contains "@example.com" AND whose username starts with "user\_", who have also published posts containing the word "TypeScript" in their title and were created in the last 6 months. The results should be ordered first by username (ascending) and then by post creation date (descending).
+A typical request object might look like this, where any field can be omitted:
 
-This scenario requires:
+```typescript
+type getPostByCriteriaRequest = {
+  offset?: { page: number; order: 'ASC' | 'DESC' };
+  cursor?: {
+    uuid: string;
+    created_at: string;
+    order: 'ASC' | 'DESC';
+  };
+  title?: string;
+  body?: string;
+  metadata?: {
+    tags?: string[];
+    views?: number;
+    ratings?: number[];
+    extra?: Record<string, any>;
+  };
+  publisher_uuid?: string;
+  categories?: string[];
+};
+```
 
-- Filtering on the root entity (`User`).
-- A join (`JOIN`) to the `Post` entity.
-- Filtering on the joined entity (`Post`).
-- Ordering by fields from both entities (root and joined).
-- Offset-based pagination (`LIMIT`/`OFFSET`).
+Our goal is to build a single function that takes this request object and dynamically constructs a [`Criteria`](../api-reference/en.md#criteria-abstract-base-class) object, applying filters, joins, and pagination logic only if the corresponding parameters are provided.
 
-## 2. Schema Definition (Reminder)
+## 2. Schema Definitions (Reminder)
 
-For this example, we will use the `UserSchema` and `PostSchema` schemas that we defined in the Schema Definition guide. We assume these schemas are available in your project.
+For this example, we will use the `PostSchema` and `UserSchema`. For a detailed guide on how to create them, please refer to [the Schema Definition guide.](../guides/schema-definitions/en.md)
 
 ```typescript
-// The location of your schemas will depend on your project's architecture.
-// For example, in a hexagonal architecture:
-// - src/user/application/criteria/user-criteria.schema.ts
-// - src/post/application/criteria/post-criteria.schema.ts
-// Below, they are shown as if in a common directory for simplicity of the example.
-
-import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
+export interface EntityBase {
+  uuid: string;
+  created_at: string;
+}
+export interface User extends EntityBase {
+  email: string;
+  username: string;
+  posts: Post[];
+}
 
 export const UserSchema = GetTypedCriteriaSchema({
   source_name: 'user',
-  alias: ['users', 'user', 'publisher'],
+  alias: 'users',
   fields: ['uuid', 'email', 'username', 'created_at'],
+  identifier_field: 'uuid',
   joins: [
     {
-      alias: 'posts', // Alias for the Post entity
-      join_relation_type: 'one_to_many',
+      alias: 'posts',
+      relation_type: 'one_to_many',
+      target_source_name: 'post',
     },
-    // ... other joins if they exist (e.g., with PermissionSchema, AddressSchema)
   ],
 });
 export type UserSchema = typeof UserSchema;
 
+export interface Post extends EntityBase {
+  title: string;
+  body: string;
+  publisher: User;
+  categories: string[] | null;
+  metadata?: {
+    tags?: string[];
+    views?: number;
+    ratings?: number[];
+    extra?: Record<string, any>;
+  };
+}
 export const PostSchema = GetTypedCriteriaSchema({
   source_name: 'post',
-  alias: ['posts', 'post'],
+  alias: 'posts',
+  identifier_field: 'uuid',
   fields: [
     'uuid',
+    'categories',
     'title',
     'body',
-    'user_uuid', // Foreign key to the User (publisher)
+    'user_uuid',
     'created_at',
-    'categories', // Could be an array of strings
-    'metadata', // Could be a JSON field
+    'metadata',
   ],
   joins: [
     {
-      alias: 'publisher', // Alias for the User entity (the post's author)
-      join_relation_type: 'many_to_one',
+      alias: 'publisher',
+      relation_type: 'many_to_one',
+      target_source_name: 'user',
     },
-    // ... other joins if they exist (e.g., with PostCommentSchema)
   ],
 });
 export type PostSchema = typeof PostSchema;
-
-// You might have other schemas here if needed for the example,
-// such as PostCommentSchema, PermissionSchema, etc.
-// For simplicity, we will focus on User and Post for this main example.
-```
-
-## 3. Building the Complex Criteria
-
-Now, let's build the `Criteria` object that represents the query described in the scenario. We will use `CriteriaFactory` and fluent methods.
-
-```typescript
-import {
-  CriteriaFactory,
-  FilterOperator,
-  OrderDirection,
-} from '@nulledexp/translatable-criteria';
-// Assuming UserSchema and PostSchema are defined as in #CODIGOAQUI_EJEMPLO_SCHEMAS_EN
-import { UserSchema, PostSchema } from './domain/criteria/schemas'; // Adjust path to your project
-
-// Calculate the date 6 months ago
-const sixMonthsAgo = new Date();
-sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
-
-const userSearchCriteria = CriteriaFactory.GetCriteria(UserSchema, 'users')
-  // Filters on the root entity (User)
-  .where({
-    field: 'email',
-    operator: FilterOperator.CONTAINS,
-    value: '@example.com',
-  })
-  .andWhere({
-    field: 'username',
-    operator: FilterOperator.STARTS_WITH,
-    value: 'user_',
-  })
-  // Join with Post and apply orderBy directly to the JoinCriteria
-  .join(
-    CriteriaFactory.GetInnerJoinCriteria(PostSchema, 'posts')
-      // Filters on the joined entity (Post)
-      .where({
-        field: 'title',
-        operator: FilterOperator.CONTAINS,
-        value: 'TypeScript',
-      })
-      .andWhere({
-        field: 'created_at',
-        operator: FilterOperator.GREATER_THAN_OR_EQUALS,
-        value: sixMonthsAgo,
-      })
-      // Specific ordering for posts, applied right here
-      .orderBy('created_at', OrderDirection.DESC), // <--- orderBy on the JoinCriteria
-    // Join parameters (User.uuid = Post.user_uuid)
-    { parent_field: 'uuid', join_field: 'user_uuid' },
-  )
-  // Ordering for the root entity (User)
-  .orderBy('username', OrderDirection.ASC)
-  // Pagination
-  .setTake(10)
-  .setSkip(10);
-
-// 'userSearchCriteria' is now a complete Criteria object ready to be translated.
 ```
 
-**Criteria Breakdown:**
-
-- `CriteriaFactory.GetCriteria(UserSchema, 'users')`: We start the query from the `User` entity, using the `users` alias.
-- `.where(...)`, `.andWhere(...)`: We apply initial filters on the `email` and `username` fields of the root entity (`User`).
-- `.join(...)`: We add a join to the `Post` entity.
-  - `CriteriaFactory.GetInnerJoinCriteria(PostSchema, 'posts')`: We create the `Criteria` for the join, specifying the `PostSchema` and the `posts` alias. We use `InnerJoin` because we only want users who _have_ posts that meet the conditions.
-  - `.where(...)`, `.andWhere(...)`: We apply filters on the `title` and `created_at` fields _of the joined entity (`Post`)_.
-  - `{ parent_field: 'uuid', join_field: 'user_uuid' }`: We define how `User` (parent) and `Post` (child) are related.
-- `.orderBy(...)`: We define the ordering. First by `username` (root entity field) ascending, then by `created_at` (joined entity field) descending.
-- `.setTake(...)`, `.setSkip(...)`: We apply pagination.
-
-This `userSearchCriteria` object now encapsulates all the query logic in a database-agnostic way.
-
-## 4. Using Criteria in a Repository
-
-A repository is a design pattern that mediates between the domain and data mapping layers, using a collection-like interface to access domain objects. A repository could have methods that accept a `Criteria` to decouple query logic from the specific ORM/database.
-
-### 4.1. Repository Interface
-
-You could define an implementation-agnostic repository interface:
-
-```typescript
-import { RootCriteria } from '@nulledexp/translatable-criteria';
-import { UserSchema } from './domain/criteria/schemas'; // Adjust path to your project
-import { UserReadModel } from './domain/user.read-model'; // Adjust path to your Read Model
-
-// Define the read repository interface for Users
-export interface IUserRepository {
-  /**
-   * Finds multiple users matching the provided Criteria.
-   * @param criteria The RootCriteria defining the query.
-   * @returns A promise that resolves to an array of UserReadModel.
-   */
-  matchingMany(
-    criteria: RootCriteria<UserSchema, any>,
-  ): Promise<UserReadModel[]>;
-
-  /**
-   * Finds a single user matching the provided Criteria.
-   * The Criteria is expected to be configured to return a single result or none.
-   * @param criteria The RootCriteria defining the query.
-   * @returns A promise that resolves to a UserReadModel or null if not found.
-   */
-  matchingOne(
-    criteria: RootCriteria<UserSchema, any>,
-  ): Promise<UserReadModel | null>;
-
-  // You could add other common repository methods if needed,
-  // for example, for counting results:
-  // count(criteria: RootCriteria<UserSchema, any>): Promise<number>;
-}
-```
-
-- `UserReadModel`: This would be the interface or type representing the data structure your application layer expects to receive.
-- `RootCriteria<UserSchema, any>`: Indicates that the methods expect a `Criteria` whose root entity is `UserSchema`.
-
-### 4.1.1. Optimizing Read Models with `setSelect`
-
-While the `IUserRepository` interface defines methods returning `UserReadModel`, you can further optimize data retrieval by specifying exactly which fields are needed using the `setSelect()` method on your `Criteria` object.
+## 3. Building the Dynamic Criteria
 
-When you use `setSelect()`, you instruct the `CriteriaTranslator` (and subsequently the ORM or database driver) to fetch only those specified fields. This can significantly improve performance by reducing the amount of data transferred from the database and processed by your application.
-
-For example, if you only need a user's `uuid` and `email` for a particular list view, you could construct your `Criteria` like this:
+We will create a function, `buildPostPaginatedCriteria`, that accepts the request object and conditionally builds the `Criteria`. This approach keeps the query construction logic clean and centralized.
 
 ```typescript
-import {
-  CriteriaFactory,
-  FilterOperator,
-} from '@nulledexp/translatable-criteria';
-import { UserSchema } from './domain/criteria/schemas'; // Adjust path
-
-const lightweightUserCriteria = CriteriaFactory.GetCriteria(UserSchema, 'users')
-  .setSelect(['uuid', 'email']) // Select only uuid and email
-  .where({
-    field: 'username',
-    operator: FilterOperator.STARTS_WITH,
-    value: 'user_',
-  })
-  .setTake(10);
-```
-
-In this scenario, your `UserReadModel` might still define more fields, but the data actually populated for instances returned by `matchingMany(lightweightUserCriteria)` would ideally only contain `uuid` and `email` (plus any fields essential for ORM hydration, if applicable).
-
-Alternatively, you could define more specific read models, like a `UserEmailListReadModel`:
+const maxPostPerPage = 5;
 
-```typescript
-// Conceptual: A more specific read model
-interface UserEmailListReadModel {
-  uuid: string;
-  email: string;
-}
-```
+function buildPostPaginatedCriteria(request: getPostByCriteriaRequest) {
+  const postCriteria = CriteriaFactory.GetCriteria(PostSchema);
 
-The repository implementation, when processing `lightweightUserCriteria`, would then aim to return an array of objects matching `UserEmailListReadModel` (or `UserReadModel` instances sparsely populated). This minimizes data overhead and aligns the fetched data precisely with the use case's requirements.
+  if (request.title) {
+    dynamicFilterApplierHelper(postCriteria, {
+      field: 'title',
+      operator: FilterOperator.CONTAINS,
+      value: request.title,
+    });
+  }
 
-This approach is particularly beneficial when dealing with entities with many fields or when fetching large lists of data.
+  if (request.body) {
+    dynamicFilterApplierHelper(postCriteria, {
+      field: 'body',
+      operator: FilterOperator.CONTAINS,
+      value: request.body,
+    });
+  }
 
-### 4.2. Repository Implementation (Conceptual)
+  if (request.categories) {
+    dynamicFilterApplierHelper(postCriteria, {
+      field: 'categories',
+      operator: FilterOperator.SET_CONTAINS_ANY,
+      value: request.categories,
+    });
+  }
 
-The concrete implementation of this repository (e.g., using TypeORM, Sequelize, or a NoSQL database) would be responsible for using a `CriteriaTranslator` to convert the `Criteria` into a native query. The repository would receive necessary dependencies, such as an ORM's query builder and a translator instance, in its constructor.
+  if (request.metadata) {
+    dynamicFilterApplierHelper(postCriteria, {
+      field: 'metadata',
+      operator: FilterOperator.JSON_CONTAINS,
+      value: request.metadata,
+    });
+  }
 
-```typescript
-import { RootCriteria } from '@nulledexp/translatable-criteria';
-import { UserSchema } from './domain/criteria/schemas'; // Adjust path
-import { UserReadModel } from './domain/user.read-model'; // Adjust path
-import { IUserRepository } from './user.repository.interface'; // The interface defined above
-
-// --- Implementation-Specific Dependencies (Example with TypeORM) ---
-// import { DataSource, SelectQueryBuilder } from 'typeorm';
-// import { UserEntity } from './infrastructure/typeorm/entities/user.entity'; // Your TypeORM entity
-// import { TypeOrmMysqlTranslator } from '@nulledexp/typeorm-mysql-translator'; // Your translator
-
-export class TypeOrmUserRepository implements IUserRepository {
-  // private readonly translator: TypeOrmMysqlTranslator<UserReadModel>; // Or the entity type TypeORM returns
-
-  // constructor(
-  //   private readonly dataSource: DataSource,
-  //   // You could instantiate the translator here or inject it
-  // ) {
-  //   this.translator = new TypeOrmMysqlTranslator<UserReadModel>();
-  // }
-
-  async matchingMany(
-    criteria: RootCriteria<UserSchema, any>,
-  ): Promise<UserReadModel[]> {
-    // Conceptual example with TypeORM:
-    // const alias = criteria.alias;
-    // const queryBuilder = this.dataSource
-    //   .getRepository(UserEntity) // DB entity repository
-    //   .createQueryBuilder(alias); // Alias must match the RootCriteria's alias
-
-    // // The translator modifies the queryBuilder based on the Criteria
-    // this.translator.translate(criteria, queryBuilder);
-
-    // // Execute the query
-    // const results = await queryBuilder.getMany();
-
-    // // Map DB entity results to UserReadModel if necessary
-    // return results.map(userEntity => ({
-    //   uuid: userEntity.uuid,
-    //   email: userEntity.email,
-    //   username: userEntity.username,
-    //   // ... other fields needed for UserReadModel
-    // }));
-
-    // Simplified example without a real ORM for the guide:
-    console.log(
-      'Simulating execution of matchingMany with Criteria:',
-      criteria, // Pass the criteria object directly
+  if (request.publisher_uuid) {
+    postCriteria.join(
+      'publisher',
+      CriteriaFactory.GetInnerJoinCriteria(UserSchema).where({
+        field: 'uuid',
+        operator: FilterOperator.EQUALS,
+        value: request.publisher_uuid,
+      }),
+      {
+        join_field: 'uuid',
+        parent_field: 'user_uuid',
+      },
     );
-    // Real translation and execution logic would go here
-    // which could return UserReadModel instances directly
-    // if the translator and ORM allow (by selecting only necessary fields).
-    return Promise.resolve([]); // Return an empty array as a placeholder
   }
 
-  async matchingOne(
-    criteria: RootCriteria<UserSchema, any>,
-  ): Promise<UserReadModel | null> {
-    // Conceptual example with TypeORM:
-    // const alias = criteria.alias;
-    // const queryBuilder = this.dataSource
-    //   .getRepository(UserEntity)
-    //   .createQueryBuilder(alias);
-
-    // this.translator.translate(criteria, queryBuilder);
-
-    // const result = await queryBuilder.getOne();
-
-    // if (!result) {
-    //   return null;
-    // }
-    // // Map the result to UserReadModel
-    // return {
-    //   uuid: result.uuid,
-    //   email: result.email,
-    //   username: result.username,
-    //   // ...
-    // };
-
-    // Simplified example without a real ORM for the guide:
-    console.log(
-      'Simulating execution of matchingOne with Criteria:',
-      criteria, // Pass the criteria object directly
+  if (request.cursor) {
+    postCriteria
+      .setCursor(
+        [
+          { field: 'created_at', value: request.cursor.created_at },
+          { field: 'uuid', value: request.cursor.uuid },
+        ],
+        FilterOperator.GREATER_THAN,
+        'ASC',
+      )
+      .orderBy('created_at', request.cursor.order)
+      .orderBy('uuid', request.cursor.order);
+  } else if (request.offset) {
+    postCriteria.setSkip(
+      Math.max(0, (request.offset.page - 1) * maxPostPerPage),
     );
-    return Promise.resolve(null); // Return null as a placeholder
+    postCriteria.orderBy('created_at', request.offset.order);
+  } else {
+    postCriteria.orderBy('created_at', 'DESC');
   }
 
-  // async count(criteria: RootCriteria<UserSchema, any>): Promise<number> {
-  //   // Conceptual example with TypeORM:
-  //   // const alias = criteria.alias;
-  //   // const queryBuilder = this.dataSource
-  //   //   .getRepository(UserEntity)
-  //   //   .createQueryBuilder(alias);
-  //   //
-  //   // // For count, you usually don't need complex joins or specific selects,
-  //   // // unless the criteria filters require them.
-  //   // // You might have a simplified version of translate for count,
-  //   // // or the translator could be smart enough.
-  //   // this.translator.translate(criteria, queryBuilder); // Apply necessary filters and joins
-  //   //
-  //   // return await queryBuilder.getCount();
-  //
-  //   console.log("Simulating execution of count with Criteria:", criteria);
-  //   return Promise.resolve(0);
-  // }
+  postCriteria.setTake(maxPostPerPage);
+
+  return postCriteria;
 }
 ```
 
-**Note:** This is a conceptual example. The actual implementation will depend on your specific ORM and translator. The key point is that the `Criteria` is passed to the translator, and the translator modifies a native query builder (`queryBuilder`) or generates the query in some other way.
+**Criteria Breakdown:**
+
+- **Initialization:** We start with a base `RootCriteria` for `PostSchema`.
+- **Conditional Filters:** Each `if (request.field)` block checks for a parameter's existence. If present, it uses a helper function (`dynamicFilterApplierHelper`) to apply the corresponding filter.
+- **Conditional Join:** The `JOIN` to the `publisher` (User) is only added if a `publisher_uuid` is provided for filtering. This ensures that the join is not performed unnecessarily.
+- **Conditional Pagination:** The logic handles three scenarios: applying cursor-based pagination if a cursor is present, falling back to offset-based pagination if an offset is provided, or applying a default ordering if neither is specified.
+- **Global Limit:** A `setTake()` is applied at the end, which serves as a default page size for both pagination methods.
 
-### 4.3. Repository Usage
+## 4. The Helper Function: A Good Practice
 
-From your service or application layer, you would instantiate the repository with its dependencies and then call its methods, passing them the constructed `Criteria`.
+The example uses a helper function, `dynamicFilterApplierHelper`, to manage the application of filters.
 
 ```typescript
-import {
-  CriteriaFactory,
-  FilterOperator,
-  OrderDirection,
-  type RootCriteria,
-} from '@nulledexp/translatable-criteria';
-import { UserSchema, PostSchema } from './domain/criteria/schemas'; // Adjust path to your project
-import type { IUserRepository } from './user.repository.interface'; // Adjust path
-import type { UserReadModel } from './domain/user.read-model'; // Adjust path
-
-async function demonstrateRepositoryUsage() {
-  // 1. Criteria Construction (similar to #CODIGOAQUI_EJEMPLO_1_EN)
-  // In a real application, this Criteria might be built by a service
-  // or a dedicated class for constructing specific queries.
-  const sixMonthsAgo = new Date();
-  sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
-
-  const postJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(
-    PostSchema,
-    'posts',
-  )
-    .where({
-      field: 'title',
-      operator: FilterOperator.CONTAINS,
-      value: 'TypeScript',
-    })
-    .andWhere({
-      field: 'created_at',
-      operator: FilterOperator.GREATER_THAN_OR_EQUALS,
-      value: sixMonthsAgo,
-    })
-    .orderBy('created_at', OrderDirection.DESC);
-
-  const userSearchCriteria: RootCriteria<typeof UserSchema, 'users'> =
-    CriteriaFactory.GetCriteria(UserSchema, 'users')
-      .where({
-        field: 'email',
-        operator: FilterOperator.CONTAINS,
-        value: '@example.com',
-      })
-      .andWhere({
-        field: 'username',
-        operator: FilterOperator.STARTS_WITH,
-        value: 'user_',
-      })
-      .join(postJoinCriteria, { parent_field: 'uuid', join_field: 'user_uuid' })
-      .orderBy('username', OrderDirection.ASC)
-      .setTake(10)
-      .setSkip(10);
-
-  // 2. Repository Instantiation and Usage (Conceptual)
-  // In a real application, `userRepository` would be an injected instance
-  // of a class implementing `IUserRepository` (e.g., TypeOrmUserRepository).
-  // Such a class would receive a `DataSource` and a `CriteriaTranslator` in its constructor.
-
-  // const userRepository: IUserRepository = new ConcreteUserRepository(dataSource, translator);
-  // const users: UserReadModel[] = await userRepository.matchingMany(userSearchCriteria);
-  // console.log(`Users found (simulated):`, users.length);
-
-  // For the purpose of this guide, we illustrate the concept:
-  console.log(
-    'The `userSearchCriteria` object (just constructed) would be passed to the `matchingMany` method of an `IUserRepository` instance.',
-  );
-  console.log(
-    'The concrete repository implementation (e.g., TypeOrmUserRepository) would use a `CriteriaTranslator` to convert the `Criteria` into a native query and execute it against the database.',
-  );
-  console.log(
-    'Finally, the repository method would return the results (e.g., UserReadModel[]).',
-  );
+function dynamicFilterApplierHelper<
+  TSchema extends CriteriaSchema,
+  Operator extends FilterOperator,
+>(
+  criteria: ICriteriaBase<TSchema>,
+  filterPrimitive: FilterPrimitive<FieldOfSchema<TSchema>, Operator>,
+) {
+  if (criteria.rootFilterGroup.items.length === 0) {
+    criteria.where(filterPrimitive);
+  } else {
+    criteria.andWhere(filterPrimitive);
+  }
 }
-
-demonstrateRepositoryUsage();
 ```
 
-In this flow:
-
-1.  The `Criteria` defining the desired query is constructed.
-2.  The repository (e.g., `TypeOrmUserRepository`) is instantiated with its dependencies (e.g., a TypeORM `DataSource` and a `TypeOrmMysqlTranslator` instance).
-3.  The appropriate repository method (`matchingMany` or `matchingOne`) is called, passing it the `Criteria`.
-4.  The repository internally uses the `CriteriaTranslator` to execute the query against the database.
-5.  The repository returns the data in the expected format (e.g., `UserReadModel[]`).
+This helper is provided purely as an **example** of how a developer can handle the complexity of building a criteria object. The key takeaway is not the specific implementation of the helper, but the **principle** behind it:
 
-This keeps the query construction logic separate from the data access logic.
+- **Encapsulation:** It encapsulates the logic of solving the common problem of whether to call `.where()` (for the first filter) or `.andWhere()` (for subsequent filters) when building a query dynamically.
+- **Type Safety:** The helper is generic (`<TSchema extends CriteriaSchema, ...>`). This is a **highly recommended practice**. By extending the generic types from the library, you ensure that your own abstractions maintain full type safety and autocompletion, preventing bugs and improving code maintainability throughout your project.
 
-## 5. Translation (Brief Mention)
+Developers are entirely free to create their own solutions or helpers for dynamically building their criteria. The important thing is to leverage the library's type system to build robust and maintainable code.
 
-As detailed in the Developing Custom Translators guide, the step of converting the `Criteria` object into a native query is handled by a concrete implementation of `CriteriaTranslator`.
+## 5. Conclusion: A Philosophy of Flexibility
 
-For example, a `TypeOrmMysqlTranslator` would take the `userSearchCriteria` and a TypeORM `SelectQueryBuilder` (which the repository would have available), and would modify the `queryBuilder` by adding the corresponding `WHERE`, `JOIN`, `ORDER BY`, `LIMIT`, `OFFSET` clauses.
+This example is not intended to impose or propose any specific architectural pattern. The purpose is to demonstrate how `@nulledexp/translatable-criteria` provides the tools to solve a potentially complex problem in a decoupled and organized way.
 
-The beauty of this pattern is that the `Criteria` definition doesn't need to know _how_ the query will be translated, only that it can be translated.
-
-## 6. Conclusion
-
-This example demonstrates how `@nulledexp/translatable-criteria` allows you to build complex query specifications in a structured, typed, and data-source-agnostic manner. By integrating this library with the Repository pattern, you can achieve a cleaner, more maintainable, and testable data access architecture.
+The same principles shown here apply equally to simpler or even more complex scenarios. The library gives you the building blocks; how you integrate them into your services, repositories, or use cases is entirely up to your architectural decisions.
 
 ---
 
 ## Next Steps
 
-With an understanding of the concepts, criteria construction, and translator development, you now have the tools to start using `@nulledexp/translatable-criteria` in your own projects.
-
-For a detailed reference of all classes and types, consult the [API Reference.](../api-reference/en.md)
+- For a detailed reference of all classes and types, consult the [API Reference.](../api-reference/en.md)
+- To learn how to convert a `Criteria` object into a native query, see the [Developing Custom Translators guide.](../guides/developing-translators/en.md)
diff --git a/src/docs/use-cases/es.md b/src/docs/use-cases/es.md
index b831673..22bd49c 100644
--- a/src/docs/use-cases/es.md
+++ b/src/docs/use-cases/es.md
@@ -1,454 +1,242 @@
-# Gua Prctica: Ejemplos de Uso
+# Gua Prctica: Construccin Dinmica de Criterios
 
-Las guas anteriores te han mostrado cmo [Definir Esquemas](../guides/defining-schemas.md) y [Construir Criterios](../guides/building-criteria.md). Ahora, veamos cmo estas piezas encajan en un escenario de aplicacin ms realista.
+Las guas anteriores te han mostrado cmo [Definir Esquemas](../guides/schema-definitions/es.md) y [Construir Criterios](../guides/building-criteria/es.md). Ahora, veamos cmo estas piezas encajan en un escenario de aplicacin ms realista y dinmico.
 
-Esta gua presenta un ejemplo completo que demuestra la construccin de un `Criteria` complejo y cmo podra ser utilizado por un repositorio para consultar datos.
+Esta gua presenta un ejemplo completo que demuestra la construccin de un objeto `Criteria` complejo basado en parmetros de entrada opcionales, como los de una peticin de API. El objetivo es ilustrar cmo la librera puede ser utilizada para resolver problemas de una manera sutil, ordenada y desacoplada, sin importar si el contexto es simple o muy complejo.
 
 ## ndice
 
 - 1. [El Escenario del Ejemplo](#1-el-escenario-del-ejemplo)
 - 2. [Definicin de Esquemas (Recordatorio)](#2-definicin-de-esquemas-recordatorio)
-- 3. [Construyendo el Criteria Complejo](#3-construyendo-el-criteria-complejo)
-- 4. [Usando el Criteria en un Repositorio](#4-usando-el-criteria-en-un-repositorio)
-  - 4.1. [Interfaz del Repositorio](#41-interfaz-del-repositorio)
-  - 4.1.1. [Optimizando Modelos de Lectura con `setSelect`](#411-optimizando-modelos-de-lectura-con-setselect)
-  - 4.2. [Implementacin del Repositorio (Conceptual)](#42-implementacin-del-repositorio-conceptual)
-  - 4.3. [Uso del Repositorio](#43-uso-del-repositorio)
-- 5. [La Traduccin (Breve Mencin)](#5-la-traduccin-breve-mencin)
-- 6. [Conclusin](#6-conclusin)
+- 3. [Construyendo el Criteria Dinmico](#3-construyendo-el-criteria-dinmico)
+- 4. [La Funcin de Ayuda (Helper): Una Buena Prctica](#4-la-funcin-de-ayuda-helper-una-buena-prctica)
+- 5. [Conclusin: Una Filosofa de Flexibilidad](#5-conclusin-una-filosofa-de-flexibilidad)
 
 ---
 
 ## 1. El Escenario del Ejemplo
 
-Imagina que necesitas implementar una funcionalidad de bsqueda paginada de usuarios. El requisito especfico es:
+Imagina que ests construyendo un endpoint de API para buscar publicaciones de blog. El endpoint debe soportar el filtrado por varios parmetros opcionales como ttulo, contenido del cuerpo, etiquetas y detalles del autor. Tambin necesita manejar diferentes estrategias de paginacin (offset y basada en cursor).
 
-> Obtener una lista paginada de usuarios cuyo email contenga "@example.com" Y cuyo nombre de usuario comience con "user\_", que adems hayan publicado posts que contengan la palabra "TypeScript" en su ttulo y que hayan sido creados en los ltimos 6 meses. Los resultados deben estar ordenados primero por el nombre de usuario (ascendente) y luego por la fecha de creacin del post (descendente).
+Un objeto de peticin tpico podra verse as, donde cualquier campo puede ser omitido:
 
-Este escenario requiere:
+```typescript
+type getPostByCriteriaRequest = {
+  offset?: { page: number; order: 'ASC' | 'DESC' };
+  cursor?: {
+    uuid: string;
+    created_at: string;
+    order: 'ASC' | 'DESC';
+  };
+  title?: string;
+  body?: string;
+  metadata?: {
+    tags?: string[];
+    views?: number;
+    ratings?: number[];
+    extra?: Record<string, any>;
+  };
+  publisher_uuid?: string;
+  categories?: string[];
+};
+```
 
-- Filtrado en la entidad raz (`User`).
-- Una unin (`JOIN`) a la entidad `Post`.
-- Filtrado en la entidad unida (`Post`).
-- Ordenamiento por campos de ambas entidades (raz y unida).
-- Paginacin basada en offset (`LIMIT`/`OFFSET`).
+Nuestro objetivo es construir una nica funcin que tome este objeto de peticin y construya dinmicamente un objeto [`Criteria`](../api-reference/es.md#criteria-clase-abstracta-base), aplicando filtros, uniones y lgica de paginacin solo si se proporcionan los parmetros correspondientes.
 
 ## 2. Definicin de Esquemas (Recordatorio)
 
-Para este ejemplo, utilizaremos los esquemas `UserSchema` y `PostSchema` que definimos en la gua de Definicin de Esquemas. Asumimos que estos esquemas estn disponibles en tu proyecto.
+Para este ejemplo, utilizaremos los esquemas `PostSchema` y `UserSchema`. Para una gua detallada sobre cmo crearlos, por favor consulta [la gua de Definicin de Esquemas.](../guides/schema-definitions/es.md)
 
 ```typescript
-// La ubicacin de tus esquemas depender de la arquitectura de tu proyecto.
-// Por ejemplo, en una arquitectura hexagonal:
-// - src/user/application/criteria/user-criteria.schema.ts
-// - src/post/application/criteria/post-criteria.schema.ts
-// A continuacin, se muestran como si estuvieran en un directorio comn por simplicidad del ejemplo.
-
-import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
+export interface EntityBase {
+  uuid: string;
+  created_at: string;
+}
+export interface User extends EntityBase {
+  email: string;
+  username: string;
+  posts: Post[];
+}
 
 export const UserSchema = GetTypedCriteriaSchema({
   source_name: 'user',
-  alias: ['users', 'user', 'publisher'],
+  alias: 'users',
   fields: ['uuid', 'email', 'username', 'created_at'],
+  identifier_field: 'uuid',
   joins: [
     {
-      alias: 'posts', // Alias para la entidad Post
-      join_relation_type: 'one_to_many',
+      alias: 'posts',
+      relation_type: 'one_to_many',
+      target_source_name: 'post',
     },
-    // ... otras uniones si existen (ej. con PermissionSchema, AddressSchema)
   ],
 });
 export type UserSchema = typeof UserSchema;
 
+export interface Post extends EntityBase {
+  title: string;
+  body: string;
+  publisher: User;
+  categories: string[] | null;
+  metadata?: {
+    tags?: string[];
+    views?: number;
+    ratings?: number[];
+    extra?: Record<string, any>;
+  };
+}
 export const PostSchema = GetTypedCriteriaSchema({
   source_name: 'post',
-  alias: ['posts', 'post'],
+  alias: 'posts',
+  identifier_field: 'uuid',
   fields: [
     'uuid',
+    'categories',
     'title',
     'body',
-    'user_uuid', // Clave fornea al User (publisher)
+    'user_uuid',
     'created_at',
-    'categories', // Podra ser un array de strings
-    'metadata', // Podra ser un campo JSON
+    'metadata',
   ],
   joins: [
     {
-      alias: 'publisher', // Alias para la entidad User (el autor del post)
-      join_relation_type: 'many_to_one',
+      alias: 'publisher',
+      relation_type: 'many_to_one',
+      target_source_name: 'user',
     },
-    // ... otras uniones si existen (ej. con PostCommentSchema)
   ],
 });
 export type PostSchema = typeof PostSchema;
-
-// Podras tener otros esquemas aqu si fueran necesarios para el ejemplo,
-// como PostCommentSchema, PermissionSchema, etc.
-// Por simplicidad, nos centraremos en User y Post para este ejemplo principal.
 ```
 
-## 3. Construyendo el Criteria Complejo
+## 3. Construyendo el Criteria Dinmico
 
-Ahora, construyamos el objeto `Criteria` que representa la consulta descrita en el escenario. Utilizaremos `CriteriaFactory` y los mtodos fluidos.
+Crearemos una funcin, `buildPostPaginatedCriteria`, que acepte el objeto de la peticin y construya condicionalmente el objeto `Criteria`. Este enfoque mantiene la lgica de construccin de la consulta limpia y centralizada.
 
 ```typescript
-import {
-  CriteriaFactory,
-  FilterOperator,
-  OrderDirection,
-} from '@nulledexp/translatable-criteria';
-import { UserSchema, PostSchema } from './domain/criteria/schemas'; // Ajusta la ruta segn tu proyecto
-
-// Calcular la fecha de hace 6 meses
-const sixMonthsAgo = new Date();
-sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
-
-const userSearchCriteria = CriteriaFactory.GetCriteria(UserSchema, 'users')
-  // Filtros en la entidad raz (User)
-  .where({
-    field: 'email',
-    operator: FilterOperator.CONTAINS,
-    value: '@example.com',
-  })
-  .andWhere({
-    field: 'username',
-    operator: FilterOperator.STARTS_WITH,
-    value: 'user_',
-  })
-  // Unir con Post y aplicar orderBy directamente al JoinCriteria
-  .join(
-    CriteriaFactory.GetInnerJoinCriteria(PostSchema, 'posts')
-      // Filtros en la entidad unida (Post)
-      .where({
-        field: 'title',
-        operator: FilterOperator.CONTAINS,
-        value: 'TypeScript',
-      })
-      .andWhere({
-        field: 'created_at',
-        operator: FilterOperator.GREATER_THAN_OR_EQUALS,
-        value: sixMonthsAgo,
-      })
-      // Ordenamiento especfico para los posts, aplicado aqu mismo
-      .orderBy('created_at', OrderDirection.DESC), // <--- orderBy en el JoinCriteria
-    // Parmetros de la unin (User.uuid = Post.user_uuid)
-    { parent_field: 'uuid', join_field: 'user_uuid' },
-  )
-  // Ordenamiento para la entidad raz (User)
-  .orderBy('username', OrderDirection.ASC)
-  // Paginacin
-  .setTake(10)
-  .setSkip(10);
-```
-
-**Desglose del Criteria:**
-
-- `CriteriaFactory.GetCriteria(UserSchema, 'users')`: Iniciamos la consulta desde la entidad `User`, usando el alias `users`.
-- `.where(...)`, `.andWhere(...)`: Aplicamos los filtros iniciales sobre los campos `email` y `username` de la entidad raz (`User`).
-- `.join(...)`: Aadimos una unin a la entidad `Post`.
-  - `CriteriaFactory.GetInnerJoinCriteria(PostSchema, 'posts')`: Creamos el `Criteria` para la unin, especificando el esquema `PostSchema` y el alias `posts`. Usamos `InnerJoin` porque solo queremos usuarios que _tengan_ posts que cumplan las condiciones.
-  - `.where(...)`, `.andWhere(...)`: Aplicamos los filtros sobre los campos `title` y `created_at` _de la entidad unida (`Post`)_.
-  - `{ parent_field: 'uuid', join_field: 'user_uuid' }`: Definimos cmo se relacionan `User` (padre) y `Post` (hijo).
-- `.orderBy(...)`: Definimos el ordenamiento. Primero por `username` (campo de la raz) ascendente, luego por `created_at` (campo de la unin) descendente.
-- `.setTake(...)`, `.setSkip(...)`: Aplicamos la paginacin.
-
-Este objeto `userSearchCriteria` encapsula ahora toda la lgica de la consulta de forma agnstica a la base de datos.
+const maxPostPerPage = 5;
 
-## 4. Usando el Criteria en un Repositorio
+function buildPostPaginatedCriteria(request: getPostByCriteriaRequest) {
+  const postCriteria = CriteriaFactory.GetCriteria(PostSchema);
 
-Un repositorio es un patrn de diseo que media entre el dominio y las capas de mapeo de datos, utilizando una interfaz similar a una coleccin para acceder a los objetos del dominio. Un repositorio podra tener mtodos que acepten un `Criteria` para desacoplar la lgica de consulta del ORM/base de datos especfico.
-
-### 4.1. Interfaz del Repositorio
-
-Podras definir una interfaz de repositorio agnstica a la implementacin:
-
-```typescript
-import { RootCriteria } from '@nulledexp/translatable-criteria';
-import { UserSchema } from './domain/criteria/schemas';
-import { UserReadModel } from './domain/user.read-model';
-
-// Define la interfaz del repositorio de lectura para Usuarios
-export interface IUserRepository {
-  /**
-   * Busca mltiples usuarios que coincidan con el Criteria proporcionado.
-   * @param criteria El RootCriteria que define la consulta.
-   * @returns Una promesa que resuelve a un array de UserReadModel.
-   */
-  matchingMany(
-    criteria: RootCriteria<UserSchema, any>,
-  ): Promise<UserReadModel[]>;
-
-  /**
-   * Busca un nico usuario que coincida con el Criteria proporcionado.
-   * Se espera que el Criteria est configurado para devolver un nico resultado o ninguno.
-   * @param criteria El RootCriteria que define la consulta.
-   * @returns Una promesa que resuelve a un UserReadModel o null si no se encuentra.
-   */
-  matchingOne(
-    criteria: RootCriteria<UserSchema, any>,
-  ): Promise<UserReadModel | null>;
-
-  // Podras aadir otros mtodos comunes de repositorio si fueran necesarios,
-  // por ejemplo, para contar resultados:
-  // count(criteria: RootCriteria<UserSchema, any>): Promise<number>;
-}
-```
-
-- `UserReadModel`: Sera la interfaz o tipo que representa la estructura de datos que tu capa de aplicacin espera recibir.
-- `RootCriteria<UserSchema, any>`: Indica que los mtodos esperan un `Criteria` cuya entidad raz sea `UserSchema`.
-
-### 4.1.1. Optimizando Modelos de Lectura con `setSelect`
+  if (request.title) {
+    dynamicFilterApplierHelper(postCriteria, {
+      field: 'title',
+      operator: FilterOperator.CONTAINS,
+      value: request.title,
+    });
+  }
 
-Aunque la interfaz `IUserRepository` define mtodos que devuelven `UserReadModel`, puedes optimizar an ms la recuperacin de datos especificando exactamente qu campos se necesitan utilizando el mtodo `setSelect()` en tu objeto `Criteria`.
+  if (request.body) {
+    dynamicFilterApplierHelper(postCriteria, {
+      field: 'body',
+      operator: FilterOperator.CONTAINS,
+      value: request.body,
+    });
+  }
 
-Cuando usas `setSelect()`, instruyes al `CriteriaTranslator` (y subsecuentemente al ORM o controlador de base de datos) para que obtenga solo esos campos especificados. Esto puede mejorar significativamente el rendimiento al reducir la cantidad de datos transferidos desde la base de datos y procesados por tu aplicacin.
+  if (request.categories) {
+    dynamicFilterApplierHelper(postCriteria, {
+      field: 'categories',
+      operator: FilterOperator.SET_CONTAINS_ANY,
+      value: request.categories,
+    });
+  }
 
-Por ejemplo, si solo necesitas el `uuid` y el `email` de un usuario para una vista de lista particular, podras construir tu `Criteria` as:
+  if (request.metadata) {
+    dynamicFilterApplierHelper(postCriteria, {
+      field: 'metadata',
+      operator: FilterOperator.JSON_CONTAINS,
+      value: request.metadata,
+    });
+  }
 
-```typescript
-import {
-  CriteriaFactory,
-  FilterOperator,
-} from '@nulledexp/translatable-criteria';
-import { UserSchema } from './domain/criteria/schemas'; // Ajusta la ruta
-
-const lightweightUserCriteria = CriteriaFactory.GetCriteria(UserSchema, 'users')
-  .setSelect(['uuid', 'email']) // Selecciona solo uuid y email
-  .where({
-    field: 'username',
-    operator: FilterOperator.STARTS_WITH,
-    value: 'user_',
-  })
-  .setTake(10);
-```
+  if (request.publisher_uuid) {
+    postCriteria.join(
+      'publisher',
+      CriteriaFactory.GetInnerJoinCriteria(UserSchema).where({
+        field: 'uuid',
+        operator: FilterOperator.EQUALS,
+        value: request.publisher_uuid,
+      }),
+      {
+        join_field: 'uuid',
+        parent_field: 'user_uuid',
+      },
+    );
+  }
 
-En este escenario, tu `UserReadModel` an podra definir ms campos, pero los datos realmente poblados para las instancias devueltas por `matchingMany(lightweightUserCriteria)` idealmente solo contendran `uuid` y `email` (ms cualquier campo esencial para la hidratacin del ORM, si aplica).
+  if (request.cursor) {
+    postCriteria
+      .setCursor(
+        [
+          { field: 'created_at', value: request.cursor.created_at },
+          { field: 'uuid', value: request.cursor.uuid },
+        ],
+        FilterOperator.GREATER_THAN,
+        'ASC',
+      )
+      .orderBy('created_at', request.cursor.order)
+      .orderBy('uuid', request.cursor.order);
+  } else if (request.offset) {
+    postCriteria.setSkip(
+      Math.max(0, (request.offset.page - 1) * maxPostPerPage),
+    );
+    postCriteria.orderBy('created_at', request.offset.order);
+  } else {
+    postCriteria.orderBy('created_at', 'DESC');
+  }
 
-Alternativamente, podras definir modelos de lectura ms especficos, como un `UserEmailListReadModel`:
+  postCriteria.setTake(maxPostPerPage);
 
-```typescript
-// Conceptual: Un modelo de lectura ms especfico
-interface UserEmailListReadModel {
-  uuid: string;
-  email: string;
+  return postCriteria;
 }
 ```
 
-La implementacin del repositorio, al procesar `lightweightUserCriteria`, buscara entonces devolver un array de objetos que coincidan con `UserEmailListReadModel` (o instancias de `UserReadModel` escasamente pobladas). Esto minimiza la sobrecarga de datos y alinea los datos obtenidos precisamente con los requisitos del caso de uso.
+**Desglose del Criteria:**
 
-Este enfoque es particularmente beneficioso cuando se trata con entidades con muchos campos o al obtener grandes listas de datos.
+- **Inicializacin:** Empezamos con un `RootCriteria` base para `PostSchema`.
+- **Filtros Condicionales:** Cada bloque `if (request.campo)` comprueba la existencia de un parmetro. Si est presente, utiliza una funcin de ayuda (`dynamicFilterApplierHelper`) para aplicar el filtro correspondiente.
+- **Unin Condicional:** El `JOIN` al `publisher` (User) solo se aade si se proporciona un `publisher_uuid` para filtrar. Esto asegura que la unin no se realice innecesariamente.
+- **Paginacin Condicional:** La lgica maneja tres escenarios: aplica paginacin basada en cursor si hay un cursor presente, recurre a la paginacin por offset si se proporciona un offset, o aplica un ordenamiento por defecto si no se especifica ninguno.
+- **Lmite Global:** Se aplica un `setTake()` al final, que sirve como un tamao de pgina por defecto para ambos mtodos de paginacin.
 
-### 4.2. Implementacin del Repositorio (Conceptual)
+## 4. La Funcin de Ayuda (Helper): Una Buena Prctica
 
-La implementacin concreta de este repositorio (por ejemplo, usando TypeORM, Sequelize, o una base de datos NoSQL) sera la responsable de utilizar un `CriteriaTranslator` para convertir el `Criteria` en una consulta nativa. El repositorio recibira las dependencias necesarias, como el constructor de consultas de un ORM y una instancia del traductor, en su constructor.
+El ejemplo utiliza una funcin de ayuda, `dynamicFilterApplierHelper`, para gestionar la aplicacin de filtros.
 
 ```typescript
-import { RootCriteria } from '@nulledexp/translatable-criteria';
-import { UserSchema } from './domain/criteria/schemas'; // Ajusta la ruta
-import { UserReadModel } from './domain/user.read-model'; // Ajusta la ruta
-import { IUserRepository } from './user.repository.interface'; // La interfaz definida arriba
-
-// --- Dependencias Especficas de la Implementacin (Ejemplo con TypeORM) ---
-// import { DataSource, SelectQueryBuilder } from 'typeorm';
-// import { UserEntity } from './infrastructure/typeorm/entities/user.entity'; // Tu entidad TypeORM
-// import { TypeOrmMysqlTranslator } from '@nulledexp/typeorm-mysql-translator'; // Tu traductor
-
-export class TypeOrmUserRepository implements IUserRepository {
-  // private readonly translator: TypeOrmMysqlTranslator<UserReadModel>; // O el tipo de entidad que devuelve TypeORM
-
-  // constructor(
-  //   private readonly dataSource: DataSource,
-  //   // Podras instanciar el traductor aqu o inyectarlo
-  // ) {
-  //   this.translator = new TypeOrmMysqlTranslator<UserReadModel>();
-  // }
-
-  async matchingMany(
-    criteria: RootCriteria<UserSchema, any>,
-  ): Promise<UserReadModel[]> {
-    // Ejemplo conceptual con TypeORM:
-    // const alias = criteria.alias;
-    // const queryBuilder = this.dataSource
-    //   .getRepository(UserEntity) // Repositorio de la entidad de BD
-    //   .createQueryBuilder(alias); // Alias debe coincidir con el del RootCriteria
-
-    // // El traductor modifica el queryBuilder basndose en el Criteria
-    // this.translator.translate(criteria, queryBuilder);
-
-    // // Ejecuta la consulta
-    // const results = await queryBuilder.getMany();
-
-    // // Mapea los resultados de la entidad de BD a UserReadModel si es necesario
-    // return results.map(userEntity => ({
-    //   uuid: userEntity.uuid,
-    //   email: userEntity.email,
-    //   username: userEntity.username,
-    //   // ... otros campos necesarios para UserReadModel
-    // }));
-
-    // Ejemplo simplificado sin ORM real para la gua:
-    console.log('Simulando ejecucin de matchingMany con Criteria:', criteria);
-    // Aqu ira la lgica real de traduccin y ejecucin
-    // que podra devolver instancias de UserReadModel directamente
-    // si el traductor y el ORM lo permiten (seleccionando solo los campos necesarios).
-    return Promise.resolve([]); // Devuelve un array vaco como placeholder
+function dynamicFilterApplierHelper<
+  TSchema extends CriteriaSchema,
+  Operator extends FilterOperator,
+>(
+  criteria: ICriteriaBase<TSchema>,
+  filterPrimitive: FilterPrimitive<FieldOfSchema<TSchema>, Operator>,
+) {
+  if (criteria.rootFilterGroup.items.length === 0) {
+    criteria.where(filterPrimitive);
+  } else {
+    criteria.andWhere(filterPrimitive);
   }
-
-  async matchingOne(
-    criteria: RootCriteria<UserSchema, any>,
-  ): Promise<UserReadModel | null> {
-    // Ejemplo conceptual con TypeORM:
-    // const alias = criteria.alias;
-    // const queryBuilder = this.dataSource
-    //   .getRepository(UserEntity)
-    //   .createQueryBuilder(alias);
-
-    // this.translator.translate(criteria, queryBuilder);
-
-    // const result = await queryBuilder.getOne();
-
-    // if (!result) {
-    //   return null;
-    // }
-    // // Mapea el resultado a UserReadModel
-    // return {
-    //   uuid: result.uuid,
-    //   email: result.email,
-    //   username: result.username,
-    //   // ...
-    // };
-
-    // Ejemplo simplificado sin ORM real para la gua:
-    console.log('Simulando ejecucin de matchingOne con Criteria:', criteria);
-    return Promise.resolve(null); // Devuelve null como placeholder
-  }
-
-  // async count(criteria: RootCriteria<UserSchema, any>): Promise<number> {
-  //   // Ejemplo conceptual con TypeORM:
-  //   // const alias = criteria.alias;
-  //   // const queryBuilder = this.dataSource
-  //   //   .getRepository(UserEntity)
-  //   //   .createQueryBuilder(alias);
-  //   //
-  //   // // Para count, usualmente no necesitas joins complejos o selects especficos,
-  //   // // a menos que los filtros del criteria los requieran.
-  //   // // Podras tener una versin simplificada del translate para count,
-  //   // // o el traductor podra ser lo suficientemente inteligente.
-  //   // this.translator.translate(criteria, queryBuilder); // Aplicar filtros y joins necesarios
-  //   //
-  //   // return await queryBuilder.getCount();
-  //
-  //   console.log("Simulando ejecucin de count con Criteria:", criteria);
-  //   return Promise.resolve(0);
-  // }
 }
 ```
 
-**Nota:** Este es un ejemplo conceptual. La implementacin real depender de tu ORM y traductor especfico. El punto clave es que el `Criteria` se pasa al traductor, y el traductor modifica un constructor de consultas nativo (`queryBuilder`) o genera la consulta de alguna otra forma.
+Este helper se proporciona puramente como un **ejemplo** de cmo un desarrollador puede manejar la complejidad de construir un objeto de criterio. La clave no es la implementacin especfica del helper, sino el **principio** que hay detrs:
 
-### 4.3. Uso del Repositorio
+- **Encapsulacin:** Encapsula la lgica para resolver el problema comn de decidir si se debe llamar a `.where()` (para el primer filtro) o a `.andWhere()` (para los filtros posteriores) al construir una consulta de forma dinmica.
+- **Seguridad de Tipos:** El helper es genrico (`<TSchema extends CriteriaSchema, ...>`). Esta es una **prctica muy recomendada**. Al extender los tipos genricos de la librera, te aseguras de que tus propias abstracciones mantengan una seguridad de tipos y un autocompletado completos, previniendo errores y mejorando la mantenibilidad del cdigo en todo tu proyecto.
 
-Desde tu capa de servicio o aplicacin, instanciaras el repositorio con sus dependencias y luego llamaras a sus mtodos pasndoles el `Criteria` construido.
+Los desarrolladores son totalmente libres de crear sus propias soluciones o helpers para construir dinmicamente sus criterios. Lo importante es aprovechar el sistema de tipos de la librera para construir un cdigo robusto y mantenible.
 
-```typescript
-import {
-  CriteriaFactory,
-  FilterOperator,
-  OrderDirection,
-  type RootCriteria,
-} from '@nulledexp/translatable-criteria';
-import { UserSchema, PostSchema } from './domain/criteria/schemas'; // Ajusta la ruta segn tu proyecto
-import type { IUserRepository } from './user.repository.interface'; // Ajusta la ruta
-import type { UserReadModel } from './domain/user.read-model'; // Ajusta la ruta
-
-async function demostrarUsoRepositorio() {
-  // En una aplicacin real, este Criteria podra ser construido por un servicio
-  // o una clase dedicada a la construccin de consultas especficas.
-  const sixMonthsAgo = new Date();
-  sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
-
-  const postJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(
-    PostSchema,
-    'posts',
-  )
-    .where({
-      field: 'title',
-      operator: FilterOperator.CONTAINS,
-      value: 'TypeScript',
-    })
-    .andWhere({
-      field: 'created_at',
-      operator: FilterOperator.GREATER_THAN_OR_EQUALS,
-      value: sixMonthsAgo,
-    })
-    .orderBy('created_at', OrderDirection.DESC);
-
-  const userSearchCriteria: RootCriteria<typeof UserSchema, 'users'> =
-    CriteriaFactory.GetCriteria(UserSchema, 'users')
-      .where({
-        field: 'email',
-        operator: FilterOperator.CONTAINS,
-        value: '@example.com',
-      })
-      .andWhere({
-        field: 'username',
-        operator: FilterOperator.STARTS_WITH,
-        value: 'user_',
-      })
-      .join(postJoinCriteria, { parent_field: 'uuid', join_field: 'user_uuid' })
-      .orderBy('username', OrderDirection.ASC)
-      .setTake(10)
-      .setSkip(10);
-
-  // 2. Instanciacin y Uso del Repositorio (Conceptual)
-  // En una aplicacin real, `userRepository` sera una instancia inyectada
-  // de una clase que implementa `IUserRepository` (ej. TypeOrmUserRepository).=
-
-  // const userRepository: IUserRepository = new ConcreteUserRepository(dataSource, translator);
-  // const usuarios: UserReadModel[] = await userRepository.matchingMany(userSearchCriteria);
-  // console.log(`Usuarios encontrados (simulado):`, usuarios.length);
-
-  // Para fines de esta gua, ilustramos el concepto:
-  console.log(
-    'El objeto `userSearchCriteria` (recin construido) se pasara al mtodo `matchingMany` de una instancia de `IUserRepository`.',
-  );
-  console.log(
-    'La implementacin concreta del repositorio (ej. TypeOrmUserRepository) utilizara un `CriteriaTranslator` para convertir el `Criteria` en una consulta nativa y ejecutarla contra la base de datos.',
-  );
-  console.log(
-    'Finalmente, el mtodo del repositorio devolvera los resultados (ej. UserReadModel[]).',
-  );
-}
-
-demostrarUsoRepositorio();
-```
-
-En este flujo:
-
-1.  Se construye el `Criteria` que define la consulta deseada.
-2.  Se instancia el repositorio (ej. `TypeOrmUserRepository`) con sus dependencias (ej. un `DataSource` de TypeORM y una instancia del `TypeOrmMysqlTranslator`).
-3.  Se llama al mtodo apropiado del repositorio (`matchingMany` o `matchingOne`), pasndole el `Criteria`.
-4.  El repositorio utiliza internamente el `CriteriaTranslator` para ejecutar la consulta en la base de datos.
-5.  El repositorio devuelve los datos en el formato esperado (ej. `UserReadModel[]`).
+## 5. Conclusin: Una Filosofa de Flexibilidad
 
-Esto mantiene la lgica de construccin de la consulta separada de la lgica de acceso a datos.
+Este ejemplo no pretende imponer ni proponer ningn patrn de arquitectura especfico. El propsito es demostrar cmo `@nulledexp/translatable-criteria` proporciona las herramientas para resolver un problema potencialmente complejo de una manera desacoplada y organizada.
 
-## 5. La Traduccin (Breve Mencin)
-
-Como se detalla en la gua de Desarrollo de Traductores Personalizados, el paso de convertir el objeto `Criteria` a una consulta nativa es manejado por una implementacin concreta de `CriteriaTranslator`.
-
-Por ejemplo, un `TypeOrmMysqlTranslator` tomara el `userSearchCriteria` y un `SelectQueryBuilder` de TypeORM (que el repositorio tendra disponible), y modificara el `queryBuilder` aadiendo las clusulas `WHERE`, `JOIN`, `ORDER BY`, `LIMIT`, `OFFSET` correspondientes.
-
-La belleza de este patrn es que la definicin del `Criteria` no necesita saber _cmo_ se traducir la consulta, solo que se puede traducir.
-
-## 6. Conclusin
-
-Este ejemplo demuestra cmo `@nulledexp/translatable-criteria` te permite construir especificaciones de consulta complejas de manera estructurada, tipada y agnstica a la fuente de datos. Al integrar esta librera con el patrn Repositorio, puedes lograr una arquitectura de acceso a datos ms limpia, mantenible y testeable.
+Los mismos principios mostrados aqu se aplican igualmente a escenarios ms simples o incluso ms complejos. La librera te da los bloques de construccin; cmo los integres en tus servicios, repositorios o casos de uso depende enteramente de tus decisiones de arquitectura.
 
 ---
 
 ## Prximos Pasos
 
-Con una comprensin de los conceptos, la construccin de criterios y el desarrollo de traductores, ahora tienes las herramientas para empezar a utilizar `@nulledexp/translatable-criteria` en tus propios proyectos.
-
-Para una referencia detallada de todas las clases y tipos, consulta la [Referencia de API.](../api-reference/es.md)
+- Para una referencia detallada de todas las clases y tipos, consulta la [Referencia de API.](../api-reference/es.md)
+- Para aprender a convertir un objeto `Criteria` en una consulta nativa, consulta la [gua de Desarrollo de Traductores Personalizados.](../guides/developing-translators/es.md)
diff --git a/tsconfig.json b/tsconfig.json
index e15c036..3732f2c 100644
--- a/tsconfig.json
+++ b/tsconfig.json
@@ -38,6 +38,8 @@
     "vitest.config.js",
     "vitest.config.js.map",
     "**/*.test.ts",
-    "**/test"
+    "**/test",
+    "src/docs",
+    "src/criteria/translator/example"
   ]
 }
