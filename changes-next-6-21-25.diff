diff --git a/README.md b/README.md
index 472115f..156d852 100644
--- a/README.md
+++ b/README.md
@@ -3,7 +3,8 @@
 [![NPM Version](https://img.shields.io/npm/v/@nulledexp/translatable-criteria.svg)](https://www.npmjs.com/package/@nulledexp/translatable-criteria)
 ![NPM Downloads](https://img.shields.io/npm/dw/%40nulledexp%2Ftranslatable-criteria)
 [![Development Stage](https://img.shields.io/badge/Development-Active%20Development-green)]()
-[![Documentation](https://img.shields.io/badge/Documentation-EN/ES-blue)](./src/docs/introduction/en.md)
+[![Documentation](https://img.shields.io/badge/Documentation-EN-blue)](./src/docs/introduction/en.md)
+[![Documentation](https://img.shields.io/badge/Documentation-ES-blue)](./src/docs/introduction/es.md)
 [![CI](https://github.com/Techscq/translatable-criteria/actions/workflows/ci.yml/badge.svg)](https://github.com/Techscq/translatable-criteria/actions/workflows/ci.yml)
 
 A TypeScript library for building data-source agnostic, translatable query criteria. Define complex filtering, ordering, and join logic in a structured, type-safe way, then translate it to your specific data source using custom translators.
@@ -16,29 +17,27 @@ npm install @nulledexp/translatable-criteria
 
 ## Overview
 
-This library simplifies the construction of complex data queries by providing a consistent and abstract way to define filtering, ordering, field selection, pagination (offset and cursor-based), and relationship (joins) configurations. The core concept revolves around the `Criteria` object hierarchy, which allows developers to define sophisticated query specifications in a data source-agnostic manner. These `Criteria` objects can then be processed by a `CriteriaTranslator` (using the Visitor pattern) to generate queries for various data sources.
+This library simplifies the construction of complex data queries by providing a consistent and abstract way to define filtering, ordering, field selection, pagination (offset and cursor-based), and relationship (joins) configurations. The core concept revolves around the `Criteria` object hierarchy, which allows developers to define sophisticated query specifications in a data source-agnostic manner, now with enhanced schema validation (including `identifier_field`) and richer context for translators (like `parent_identifier`). These `Criteria` objects can then be processed by a `CriteriaTranslator` to generate queries for various data sources.
 
 ## Key Features
 
-- **Enhanced Type-Safety:** Construct queries with a fluent, strongly-typed interface, benefiting from compile-time and runtime validation of field names, aliases, and join parameters based on your schemas.
-- **Powerful Filtering:** Define intricate filtering logic with multiple operators (including for JSON and arrays) and grouping. Filter groups are automatically normalized for consistency.
-- **Flexible Join System:** Support for various join types (inner, left, full outer) and pivot table configurations, with validation of join parameters according to the relation type.
-- **Default Join Field Selection:** When a join is added, if `setSelect()` is not explicitly called on the `JoinCriteria`, all fields from the joined schema will be automatically included in the main `SELECT` clause. This can be overridden by using `setSelect()` on the specific `JoinCriteria`.
-- **Field Selection:** Specify exactly which fields to retrieve using `setSelect()`. Use `resetSelect()` to select all fields (which is also the default behavior).
+- **Enhanced Type-Safety:** Construct queries with a fluent, strongly-typed interface, benefiting from compile-time and runtime validation of field names (including `identifier_field`), aliases, and join parameters based on your schemas.
+- **Powerful Filtering:** Define intricate filtering logic with multiple operators (including for JSON, arrays, sets, ranges, and regex) and grouping. Filter groups are automatically normalized for consistency.
+- **Flexible Join System:** Support for various join types (inner, left, full outer) and pivot table configurations. Join parameters now include `parent_identifier` to provide richer context to translators for relationship inference (e.g., for `one_to_one`).
+- **Field Selection & `identifier_field`:** Specify exactly which fields to retrieve using `setSelect()`. The `identifier_field` of an entity is automatically included when `setSelect()` is used. Use `resetSelect()` to select all fields (default behavior).
 - **Pagination:** Supports both offset-based (`setTake()`, `setSkip()`) and cursor-based (`setCursor()`) pagination.
-- **Visitor Pattern for Translation:** Criteria objects implement an `accept` method, allowing for clean and extensible translation logic via the Visitor pattern.
 - **Data Source Agnostic:** Design criteria independently of the underlying data source.
 - **Translator-Based Architecture:** The core library defines criteria; actual translation is handled by separate translator packages that implement the `CriteriaTranslator` interface.
 - **Full TypeScript Support:** Benefit from compile-time validation and autocompletion.
 
 ## Core Concepts
 
-The library is built upon a few fundamental concepts. For detailed explanations, please refer to our Core Concepts Documentation.
+The library is built upon a few fundamental concepts. For detailed explanations, please refer to our documentation guides.
 
-- **`Criteria` Hierarchy:** Abstract base for query specifications (`RootCriteria`, `InnerJoinCriteria`, etc.). Learn more.
-- **`CriteriaFactory`:** Recommended utility for creating `Criteria` instances (e.g., `CriteriaFactory.GetCriteria(...)`, `CriteriaFactory.GetInnerJoinCriteria(...)`). Learn more.
-- **Schemas (`CriteriaSchema` & `GetTypedCriteriaSchema`):** Define your data entities' structure for type-safe criteria construction. Learn more.
-- **`CriteriaTranslator`:** Abstract class for converting `Criteria` objects into specific data source queries using the Visitor pattern. Learn more.
+- [**`Criteria` Hierarchy:**](./src/docs/core-concepts/en.md#criteria-hierarchy) Abstract base for query specifications (`RootCriteria`, `InnerJoinCriteria`, etc.).
+- [**`CriteriaFactory`:**](./src/docs/core-concepts/en.md#criteriafactory) Recommended utility for creating `Criteria` instances.
+- [**Schemas (`CriteriaSchema` & `GetTypedCriteriaSchema`):**](./src/docs/guides/schema-definitions/en.md) Define your data entities' structure for type-safe criteria construction.
+- [**`CriteriaTranslator`:**](./src/docs/guides/developing-translators/en.md) Abstract class responsible for converting `Criteria` objects into specific data source queries.
 
 ## Usage Example (Core Library)
 
@@ -46,54 +45,54 @@ This package provides the tools to define your query criteria.
 
 ### 1. Define Schemas
 
+First, define your entity schemas using `GetTypedCriteriaSchema` to enable type-safety.
+
 ```typescript
 import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
 
 export const UserSchema = GetTypedCriteriaSchema({
-  source_name: 'user',
-  alias: ['users', 'user', 'publisher'],
-  fields: ['uuid', 'email', 'username', 'created_at'],
+  source_name: 'users',
+  alias: 'u',
+  fields: ['id', 'username', 'email', 'age', 'isActive', 'createdAt'],
+  identifier_field: 'id',
   joins: [
-    { alias: 'posts', relation_type: 'one_to_many' },
-    // other joins like 'permissions', 'addresses' can be defined here
+    {
+      alias: 'posts',
+      target_source_name: 'posts',
+      relation_type: 'one_to_many',
+    },
   ],
 });
-export type UserSchema = typeof UserSchema;
 
 export const PostSchema = GetTypedCriteriaSchema({
-  source_name: 'post',
-  alias: ['posts', 'post'],
-  fields: [
-    'uuid',
-    'title',
-    'body',
-    'user_uuid',
-    'created_at',
-    'categories', // Example: for array filters
-    'metadata', // Example: for JSON filters
-  ],
+  source_name: 'posts',
+  alias: 'p',
+  fields: ['id', 'title', 'content', 'userId', 'createdAt'],
+  identifier_field: 'id',
   joins: [
-    { alias: 'comments', relation_type: 'one_to_many' },
-    { alias: 'publisher', relation_type: 'many_to_one' },
+    {
+      alias: 'user',
+      target_source_name: 'users',
+      relation_type: 'many_to_one',
+    },
   ],
 });
-export type PostSchema = typeof PostSchema;
-
-// Define other schemas (PermissionSchema, PostCommentSchema, AddressSchema) as needed for your application.
-// See the full documentation for more examples.
 ```
 
 ### 2. Create Criteria
 
+Use `CriteriaFactory` to create a `Criteria` object from your schema.
+
 ```typescript
 import {
   CriteriaFactory,
   FilterOperator,
+  OrderDirection,
 } from '@nulledexp/translatable-criteria';
-import { UserSchema } from './path/to/your/criteria/schemas'; // Adjust path
+import { UserSchema } from './path/to/your/schemas'; // Adjust path
 
 // Create Criteria for the User entity
-const userCriteria = CriteriaFactory.GetCriteria(UserSchema, 'users');
+const userCriteria = CriteriaFactory.GetCriteria(UserSchema);
 
 // Example: Add a simple filter
 userCriteria.where({
@@ -103,17 +102,17 @@ userCriteria.where({
 });
 
 // Example: Add ordering
-userCriteria.orderBy('created_at', 'DESC');
+userCriteria.orderBy('createdAt', OrderDirection.DESC);
 
 // The 'userCriteria' object is now ready to be passed to a translator.
 ```
 
 ## Available Translators
 
-To interact with a database, you'll need a translator package.
+To interact with a database, you'll need a translator package. You can either build your own following our Criteria Translator Development Guide or use one from the community.
 
 - **`@nulledexp/typeorm-mysql-criteria-translator`**:
-  A translator for generating TypeORM `SelectQueryBuilder` instances for MySQL.
+  - A translator for generating TypeORM `SelectQueryBuilder` instances for MySQL.
   - **Author:** Nelson Cabrera
   - **Installation**:
 
@@ -121,58 +120,25 @@ To interact with a database, you'll need a translator package.
   npm install @nulledexp/typeorm-mysql-criteria-translator
 ```
 
-- **Usage (basic)**:
-
-```typescript
-import {
-  CriteriaFactory,
-  FilterOperator,
-} from '@nulledexp/translatable-criteria';
-import { TypeOrmMysqlTranslator } from '@nulledexp/typeorm-mysql-criteria-translator'; // Using new suggested name
-import { UserSchema } from './path/to/your/criteria/schemas'; // Your Criteria Schema
-// import { YourTypeOrmUserEntity } from './path/to/your/typeorm/entities'; // Your actual TypeORM entity
-// import { DbDatasource } from './path-to-your-datasource-config'; // Your initialized TypeORM DataSource instance
-
-// 1. Define your Criteria using @nulledexp/translatable-criteria
-const criteria = CriteriaFactory.GetCriteria(UserSchema, 'users') // 'users' is an alias from UserSchema
-  .where({
-    field: 'username', // Field from UserSchema
-    operator: FilterOperator.EQUALS,
-    value: 'testuser',
-  })
-  .setTake(10);
-
-// 2. Use the translator with your TypeORM QueryBuilder
-// (Conceptual - assuming DbDatasource and YourTypeOrmUserEntity are set up)
-
-// const queryBuilder = DbDatasource.getRepository(YourTypeOrmUserEntity)
-//   .createQueryBuilder(criteria.alias); // Alias must match root criteria alias
-
-// const translator = new TypeOrmMysqlTranslator<YourTypeOrmUserEntity>();
-// translator.translate(criteria, queryBuilder);
-
-// Now queryBuilder is populated with the translated criteria
-// console.log(queryBuilder.getSql(), queryBuilder.getParameters());
-// const results = await queryBuilder.getMany();
-```
+- **Usage:**
 
-- **Note:** This translator has been tested with integration tests. Please review its implementation at its repository (replace with actual repo link if different) to ensure it meets your specific project needs and production requirements. Contributions and bug reports are welcome!
+  - See the TypeORM Translator Usage Guide for detailed instructions.
 
 - **(More translators coming soon or can be created by the community)**
 
-### Developing Custom Translators
-
-You can create your own translators by extending the abstract `CriteriaTranslator` class. See the Developing Custom Translators Guide for details.
+**Important Note for Translator Developers:** Translators should be updated to handle the new `parent_identifier` in join parameters (especially for inferring `one_to_one` relationships) and to support the new filter operators. Refer to the Developing Custom Translators Guide for details.
 
 ## Type Safety Features
 
 - Compile-time validation of field names within criteria based on schemas.
+- Validation of `identifier_field` definition within schemas.
 - Type-checked join configurations ensuring compatibility between schemas.
 - Autocomplete support for schema fields and defined join aliases.
 - Validation of alias usage in `Criteria` constructors.
 - Robust validation of join parameters based on `join_relation_type`.
 - Validation for selected fields, cursor fields, take/skip values.
 - Strictly typed filter values based on the `FilterOperator` used.
+- Inclusion of `parent_identifier` in resolved join parameters for translator use.
 
 ## Roadmap (Core Library)
 
@@ -182,9 +148,11 @@ You can create your own translators by extending the abstract `CriteriaTranslato
 - [x] Implement `LIMIT` and `OFFSET` (take/skip) for pagination.
 - [x] Implement `PivotJoin` for many-to-many relationships.
 - [x] Strictly typed filter values based on operator.
-- [x] New filter operators (JSON, Array, Set).
-- [x] Enhanced documentation with detailed examples for translator development.
+- [x] New filter operators (JSON, Array, Set, Range, Regex, ILIKE).
 - [x] `OuterJoinCriteria` support in the core logic.
+- [x] Introduce `identifier_field` in schemas and `parent_identifier` in join parameters.
+- [x] Enforce stricter schema validation at type level.
+- [ ] Enhanced documentation with detailed examples for translator development.
 - [ ] Explore utility functions to simplify translator development.
 - [ ] Explore utility functions to simplify schema development.
 - [ ] Add more comprehensive unit test coverage for criteria construction and edge cases.
diff --git a/changes-next-v2-06-20.diff b/changes-next-v2-06-20.diff
deleted file mode 100644
index 026d09c..0000000
--- a/changes-next-v2-06-20.diff
+++ /dev/null
@@ -1,325 +0,0 @@
-diff --git a/src/criteria/criteria-factory.ts b/src/criteria/criteria-factory.ts
-index f89951e..d139131 100644
---- a/src/criteria/criteria-factory.ts
-+++ b/src/criteria/criteria-factory.ts
-@@ -3,6 +3,7 @@ import type { CriteriaSchema, SelectedAliasOf } from './types/schema.types.js';
- import { InnerJoinCriteria } from './join/inner.join-criteria.js';
- import { LeftJoinCriteria } from './join/left.join-criteria.js';
- import { OuterJoinCriteria } from './join/outer.join-criteria.js';
-+import type { ValidSchema } from './criteria.js';
- 
- /**
-  * Provides static methods for creating instances of different types of `Criteria`.
-@@ -26,7 +27,7 @@ export class CriteriaFactory {
-   static GetCriteria<
-     CSchema extends CriteriaSchema,
-     Alias extends SelectedAliasOf<CSchema>,
--  >(schema: CSchema, alias: Alias): RootCriteria<CSchema, Alias> {
-+  >(schema: ValidSchema<CSchema>, alias: Alias): RootCriteria<CSchema, Alias> {
-     return new RootCriteria(schema, alias);
-   }
- 
-@@ -47,7 +48,10 @@ export class CriteriaFactory {
-   static GetInnerJoinCriteria<
-     CSchema extends CriteriaSchema,
-     Alias extends SelectedAliasOf<CSchema>,
--  >(schema: CSchema, alias: Alias): InnerJoinCriteria<CSchema, Alias> {
-+  >(
-+    schema: ValidSchema<CSchema>,
-+    alias: Alias,
-+  ): InnerJoinCriteria<CSchema, Alias> {
-     return new InnerJoinCriteria(schema, alias);
-   }
- 
-@@ -67,7 +71,10 @@ export class CriteriaFactory {
-   static GetLeftJoinCriteria<
-     CSchema extends CriteriaSchema,
-     Alias extends SelectedAliasOf<CSchema>,
--  >(schema: CSchema, alias: Alias): LeftJoinCriteria<CSchema, Alias> {
-+  >(
-+    schema: ValidSchema<CSchema>,
-+    alias: Alias,
-+  ): LeftJoinCriteria<CSchema, Alias> {
-     return new LeftJoinCriteria(schema, alias);
-   }
- 
-@@ -87,7 +94,10 @@ export class CriteriaFactory {
-   static GetOuterJoinCriteria<
-     CSchema extends CriteriaSchema,
-     Alias extends SelectedAliasOf<CSchema>,
--  >(schema: CSchema, alias: Alias): OuterJoinCriteria<CSchema, Alias> {
-+  >(
-+    schema: ValidSchema<CSchema>,
-+    alias: Alias,
-+  ): OuterJoinCriteria<CSchema, Alias> {
-     return new OuterJoinCriteria(schema, alias);
-   }
- }
-diff --git a/src/criteria/criteria.ts b/src/criteria/criteria.ts
-index d59322c..67a7735 100644
---- a/src/criteria/criteria.ts
-+++ b/src/criteria/criteria.ts
-@@ -25,6 +25,10 @@ import type {
- import type { PivotJoin, SimpleJoin } from './types/join-parameter.types.js';
- import type { FilterGroup } from './filter/filter-group.js';
- 
-+export type ValidSchema<CSchema extends CriteriaSchema> =
-+  CSchema['identifier_field'] extends CSchema['fields'][number]
-+    ? CSchema
-+    : `Schema identifier_field '${CSchema['identifier_field']}' must be one of the schema's defined fields. Schema: ${CSchema['source_name']}`;
- /**
-  * Abstract base class for constructing query criteria.
-  * It provides a fluent API for defining filters, joins, selections, ordering, and pagination.
-@@ -71,9 +75,7 @@ export abstract class Criteria<
-    * @protected
-    */
-   constructor(
--    schema: TSchema['identifier_field'] extends TSchema['fields'][number]
--      ? TSchema
--      : `Schema identifier_field '${TSchema['identifier_field']}' must be one of the schema's defined fields. Schema: ${TSchema['source_name']}`,
-+    schema: ValidSchema<TSchema>,
-     protected _alias: CurrentAlias,
-   ) {
-     if (typeof schema === 'string') {
-@@ -93,7 +95,7 @@ export abstract class Criteria<
-     this._source_name = schema.source_name;
-   }
- 
--  private get schema(): TSchema {
-+  protected get schema(): TSchema {
-     return this._schema;
-   }
- 
-@@ -385,6 +387,7 @@ export abstract class Criteria<
-         this.schema.joins.find((join) => join.alias === criteriaToJoin.alias)
-           ?.metadata ?? {},
-       parent_schema_metadata: this.schema.metadata ?? {},
-+      parent_identifier: this.identifierField,
-     };
-     this._joinManager.addJoin(criteriaToJoin, fullJoinParameters);
-     return this;
-diff --git a/src/criteria/join/inner.join-criteria.ts b/src/criteria/join/inner.join-criteria.ts
-index d973075..bcf542d 100644
---- a/src/criteria/join/inner.join-criteria.ts
-+++ b/src/criteria/join/inner.join-criteria.ts
-@@ -4,7 +4,7 @@ import type {
-   SelectedAliasOf,
- } from '../types/schema.types.js';
- import type { PivotJoin, SimpleJoin } from '../types/join-parameter.types.js';
--import { Criteria } from '../criteria.js';
-+import { Criteria, type ValidSchema } from '../criteria.js';
- import type { ICriteriaVisitor } from '../types/visitor-interface.types.js';
- 
- /**
-@@ -48,6 +48,9 @@ export class InnerJoinCriteria<
-    * @returns {InnerJoinCriteria<CSchema, Alias>} A new, reset `RootCriteria` instance.
-    */
-   resetCriteria(): InnerJoinCriteria<CSchema, Alias> {
--    return new InnerJoinCriteria(this.schema, this._alias);
-+    return new InnerJoinCriteria(
-+      this.schema as ValidSchema<CSchema>,
-+      this._alias,
-+    );
-   }
- }
-diff --git a/src/criteria/join/left.join-criteria.ts b/src/criteria/join/left.join-criteria.ts
-index 58e2b60..1227d5a 100644
---- a/src/criteria/join/left.join-criteria.ts
-+++ b/src/criteria/join/left.join-criteria.ts
-@@ -4,7 +4,7 @@ import type {
-   SelectedAliasOf,
- } from '../types/schema.types.js';
- import type { PivotJoin, SimpleJoin } from '../types/join-parameter.types.js';
--import { Criteria } from '../criteria.js';
-+import { Criteria, type ValidSchema } from '../criteria.js';
- import type { ICriteriaVisitor } from '../types/visitor-interface.types.js';
- 
- /**
-@@ -47,6 +47,9 @@ export class LeftJoinCriteria<
-    * @returns {LeftJoinCriteria<CSchema, Alias>} A new, reset `RootCriteria` instance.
-    */
-   resetCriteria(): LeftJoinCriteria<CSchema, Alias> {
--    return new LeftJoinCriteria(this.schema, this._alias);
-+    return new LeftJoinCriteria(
-+      this.schema as ValidSchema<CSchema>,
-+      this._alias,
-+    );
-   }
- }
-diff --git a/src/criteria/join/outer.join-criteria.ts b/src/criteria/join/outer.join-criteria.ts
-index 66ff186..1ae0d07 100644
---- a/src/criteria/join/outer.join-criteria.ts
-+++ b/src/criteria/join/outer.join-criteria.ts
-@@ -4,7 +4,7 @@ import type {
-   SelectedAliasOf,
- } from '../types/schema.types.js';
- import type { PivotJoin, SimpleJoin } from '../types/join-parameter.types.js';
--import { Criteria } from '../criteria.js';
-+import { Criteria, type ValidSchema } from '../criteria.js';
- import type { ICriteriaVisitor } from '../types/visitor-interface.types.js';
- 
- /**
-@@ -47,6 +47,9 @@ export class OuterJoinCriteria<
-    * @returns {OuterJoinCriteria<CSchema, Alias>} A new, reset `RootCriteria` instance.
-    */
-   resetCriteria(): OuterJoinCriteria<CSchema, Alias> {
--    return new OuterJoinCriteria(this.schema, this._alias);
-+    return new OuterJoinCriteria(
-+      this.schema as ValidSchema<CSchema>,
-+      this._alias,
-+    );
-   }
- }
-diff --git a/src/criteria/root.criteria.ts b/src/criteria/root.criteria.ts
-index f08978d..4136946 100644
---- a/src/criteria/root.criteria.ts
-+++ b/src/criteria/root.criteria.ts
-@@ -1,4 +1,4 @@
--import { Criteria } from './criteria.js';
-+import { Criteria, type ValidSchema } from './criteria.js';
- import type { CriteriaSchema, SelectedAliasOf } from './types/schema.types.js';
- import type { ICriteriaVisitor } from './types/visitor-interface.types.js';
- 
-@@ -38,6 +38,6 @@ export class RootCriteria<
-    * @returns {RootCriteria<CSchema, Alias>} A new, reset `RootCriteria` instance.
-    */
-   resetCriteria(): RootCriteria<CSchema, Alias> {
--    return new RootCriteria(this.schema, this._alias);
-+    return new RootCriteria(this.schema as ValidSchema<CSchema>, this._alias);
-   }
- }
-diff --git a/src/criteria/test/criteria.test.ts b/src/criteria/test/criteria.test.ts
-index 4ff5813..93fdaf8 100644
---- a/src/criteria/test/criteria.test.ts
-+++ b/src/criteria/test/criteria.test.ts
-@@ -4,7 +4,7 @@ import { OrderDirection } from '../order/order.js';
- import { InnerJoinCriteria } from '../join/inner.join-criteria.js';
- import { LeftJoinCriteria } from '../join/left.join-criteria.js';
- import type { StoredJoinDetails } from '../types/join-utility.types.js';
--import type { CriteriaSchema, SelectedAliasOf } from '../types/schema.types.js';
-+
- import { FilterOperator, LogicalOperator } from '../types/operator.types.js';
- import {
-   PermissionSchema,
-@@ -12,16 +12,26 @@ import {
-   PostSchema,
-   UserSchema,
- } from './fake-entities.js';
-+import {
-+  type CriteriaSchema,
-+  GetTypedCriteriaSchema,
-+  type SelectedAliasOf,
-+} from '../types/schema.types.js';
- 
- const testJoinsData = (
-   joinDetails: StoredJoinDetails<CriteriaSchema>,
-   joinParameter: { join_field: string | object; parent_field: string | object },
--  criteria: RootCriteria<CriteriaSchema, SelectedAliasOf<CriteriaSchema>>,
-+  parentCriteria: RootCriteria<CriteriaSchema, SelectedAliasOf<CriteriaSchema>>,
- ) => {
-   expect(joinDetails.parameters.join_field).toBe(joinParameter.join_field);
-   expect(joinDetails.parameters.parent_field).toBe(joinParameter.parent_field);
--  expect(joinDetails.parameters.parent_alias).toBe(criteria.alias);
--  expect(joinDetails.parameters.parent_source_name).toBe(criteria.sourceName);
-+  expect(joinDetails.parameters.parent_alias).toBe(parentCriteria.alias);
-+  expect(joinDetails.parameters.parent_source_name).toBe(
-+    parentCriteria.sourceName,
-+  );
-+  expect(joinDetails.parameters.parent_identifier).toBe(
-+    parentCriteria.identifierField,
-+  );
- };
- 
- describe('Criteria', () => {
-@@ -418,7 +428,7 @@ describe('Criteria', () => {
-       );
-     });
- 
--    it('should add an inner join', () => {
-+    it('should add an inner join and correctly populate parent_identifier', () => {
-       const userJoinCriteria = new InnerJoinCriteria(UserSchema, 'publisher');
-       const joinParameter = {
-         parent_field: 'user_uuid',
-@@ -440,7 +450,36 @@ describe('Criteria', () => {
-       }
-     });
- 
--    it('should add multiple joins', () => {
-+    it('should add a many-to-many join and correctly populate parent_identifier', () => {
-+      const userCriteriaRoot = new RootCriteria(UserSchema, 'users');
-+      const permissionJoinCriteria = new InnerJoinCriteria(
-+        PermissionSchema,
-+        'permissions',
-+      );
-+      const joinParameter = {
-+        pivot_source_name: 'user_permission_pivot',
-+        parent_field: { pivot_field: 'user_uuid', reference: 'uuid' },
-+        join_field: { pivot_field: 'permission_uuid', reference: 'uuid' },
-+      } as const;
-+
-+      userCriteriaRoot.join(permissionJoinCriteria, joinParameter);
-+
-+      const joinsArray = userCriteriaRoot.joins;
-+      expect(joinsArray.length).toBe(1);
-+      const joinEntry = joinsArray[0];
-+      expect(joinEntry).toBeDefined();
-+      if (joinEntry) {
-+        expect(joinEntry.criteria.alias).toBe('permissions');
-+        expect(joinEntry.criteria).toBeInstanceOf(InnerJoinCriteria);
-+        testJoinsData(joinEntry, joinParameter, userCriteriaRoot);
-+        expect(joinEntry.criteria).toBe(permissionJoinCriteria);
-+        expect(joinEntry.parameters.parent_identifier).toBe(
-+          UserSchema.identifier_field,
-+        );
-+      }
-+    });
-+
-+    it('should add multiple joins and correctly populate parent_identifier for each', () => {
-       const userJoinCriteria = new InnerJoinCriteria(UserSchema, 'publisher');
-       const userJoinParameter = {
-         parent_field: 'user_uuid',
-@@ -483,7 +522,7 @@ describe('Criteria', () => {
-       }
-     });
- 
--    it('should replace a join if the same alias is used', () => {
-+    it('should replace a join if the same alias is used and check parent_identifier', () => {
-       const userJoinCriteria1 = new InnerJoinCriteria(UserSchema, 'publisher');
-       const userJoinCriteria2 = new LeftJoinCriteria(UserSchema, 'publisher');
- 
-@@ -688,14 +727,3 @@ describe('Criteria', () => {
-     });
-   });
- });
--
--/**
-- * Helper function to create a typed schema for testing.
-- * This is a simplified version of GetTypedCriteriaSchema for test purposes
-- * if the main one causes issues with complex generic inference in tests.
-- */
--function GetTypedCriteriaSchema<const TInput extends CriteriaSchema>(
--  schema: TInput,
--): TInput {
--  return schema;
--}
-diff --git a/src/criteria/types/join-parameter.types.ts b/src/criteria/types/join-parameter.types.ts
-index db7a837..fe12361 100644
---- a/src/criteria/types/join-parameter.types.ts
-+++ b/src/criteria/types/join-parameter.types.ts
-@@ -23,7 +23,7 @@ export type PivotJoin<
-   parent_source_name: ParentSchema['source_name'];
-   /** The alias used for the parent entity in the query. */
-   parent_alias: ParentSchema['alias'][number];
--
-+  parent_identifier: FieldOfSchema<ParentSchema>;
-   /** The source name (table name) of the pivot table. */
-   pivot_source_name: string;
-   /** Configuration for the join field on the parent side, referencing the pivot table. */
-@@ -82,6 +82,7 @@ export type SimpleJoin<
-   parent_source_name: ParentSchema['source_name'];
-   /** The alias used for the parent entity in the query. */
-   parent_alias: ParentSchema['alias'][number];
-+  parent_identifier: FieldOfSchema<ParentSchema>;
-   /**
-    * The field name in the parent schema used for the join condition.
-    * Must be a valid field from `ParentSchema['fields']`.
diff --git a/src/criteria/criteria-factory.ts b/src/criteria/criteria-factory.ts
index d139131..dff7d4b 100644
--- a/src/criteria/criteria-factory.ts
+++ b/src/criteria/criteria-factory.ts
@@ -1,5 +1,5 @@
 import { RootCriteria } from './root.criteria.js';
-import type { CriteriaSchema, SelectedAliasOf } from './types/schema.types.js';
+import type { CriteriaSchema } from './types/schema.types.js';
 import { InnerJoinCriteria } from './join/inner.join-criteria.js';
 import { LeftJoinCriteria } from './join/left.join-criteria.js';
 import { OuterJoinCriteria } from './join/outer.join-criteria.js';
@@ -24,11 +24,10 @@ export class CriteriaFactory {
    *
    * const userCriteria = CriteriaFactory.GetCriteria(UserSchema, 'users');
    */
-  static GetCriteria<
-    CSchema extends CriteriaSchema,
-    Alias extends SelectedAliasOf<CSchema>,
-  >(schema: ValidSchema<CSchema>, alias: Alias): RootCriteria<CSchema, Alias> {
-    return new RootCriteria(schema, alias);
+  static GetCriteria<CSchema extends CriteriaSchema>(
+    schema: ValidSchema<CSchema>,
+  ): RootCriteria<CSchema> {
+    return new RootCriteria(schema);
   }
 
   /**
@@ -45,14 +44,10 @@ export class CriteriaFactory {
    * const postJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(PostSchema, 'posts');
    * // postJoinCriteria can then be used in the .join() method of another Criteria
    */
-  static GetInnerJoinCriteria<
-    CSchema extends CriteriaSchema,
-    Alias extends SelectedAliasOf<CSchema>,
-  >(
+  static GetInnerJoinCriteria<CSchema extends CriteriaSchema>(
     schema: ValidSchema<CSchema>,
-    alias: Alias,
-  ): InnerJoinCriteria<CSchema, Alias> {
-    return new InnerJoinCriteria(schema, alias);
+  ): InnerJoinCriteria<CSchema> {
+    return new InnerJoinCriteria(schema);
   }
 
   /**
@@ -68,14 +63,10 @@ export class CriteriaFactory {
    *
    * const commentJoinCriteria = CriteriaFactory.GetLeftJoinCriteria(CommentSchema, 'comments');
    */
-  static GetLeftJoinCriteria<
-    CSchema extends CriteriaSchema,
-    Alias extends SelectedAliasOf<CSchema>,
-  >(
+  static GetLeftJoinCriteria<CSchema extends CriteriaSchema>(
     schema: ValidSchema<CSchema>,
-    alias: Alias,
-  ): LeftJoinCriteria<CSchema, Alias> {
-    return new LeftJoinCriteria(schema, alias);
+  ): LeftJoinCriteria<CSchema> {
+    return new LeftJoinCriteria(schema);
   }
 
   /**
@@ -91,13 +82,9 @@ export class CriteriaFactory {
    *
    * const profileJoinCriteria = CriteriaFactory.GetOuterJoinCriteria(ProfileSchema, 'profiles');
    */
-  static GetOuterJoinCriteria<
-    CSchema extends CriteriaSchema,
-    Alias extends SelectedAliasOf<CSchema>,
-  >(
+  static GetOuterJoinCriteria<CSchema extends CriteriaSchema>(
     schema: ValidSchema<CSchema>,
-    alias: Alias,
-  ): OuterJoinCriteria<CSchema, Alias> {
-    return new OuterJoinCriteria(schema, alias);
+  ): OuterJoinCriteria<CSchema> {
+    return new OuterJoinCriteria(schema);
   }
 }
diff --git a/src/criteria/criteria.ts b/src/criteria/criteria.ts
index 67a7735..b0d5416 100644
--- a/src/criteria/criteria.ts
+++ b/src/criteria/criteria.ts
@@ -2,7 +2,6 @@ import type {
   CriteriaSchema,
   FieldOfSchema,
   SchemaJoins,
-  SelectedAliasOf,
 } from './types/schema.types.js';
 
 import { CriteriaFilterManager } from './criteria-filter-manager.js';
@@ -35,13 +34,9 @@ export type ValidSchema<CSchema extends CriteriaSchema> =
  * Concrete criteria types (e.g., RootCriteria, JoinCriteria) will extend this class.
  *
  * @template TSchema - The schema definition for the entity this criteria operates on.
- * @template CurrentAlias - The selected alias for the entity from its schema.
  */
-export abstract class Criteria<
-  const TSchema extends CriteriaSchema,
-  const CurrentAlias extends
-    SelectedAliasOf<TSchema> = SelectedAliasOf<TSchema>,
-> implements ICriteriaBase<TSchema, CurrentAlias>
+export abstract class Criteria<const TSchema extends CriteriaSchema>
+  implements ICriteriaBase<TSchema>
 {
   private readonly _filterManager = new CriteriaFilterManager<TSchema>();
   private readonly _joinManager = new CriteriaJoinManager<TSchema>();
@@ -68,23 +63,14 @@ export abstract class Criteria<
   protected readonly _schema: TSchema;
   /**
    * Initializes a new instance of the Criteria class.
-   * @param {TSchema} schema - The schema definition for the entity.
-   * @param {CurrentAlias} _alias - The alias to use for this entity in the query.
-   * @throws {Error} If the provided alias is not supported by the schema.
+   * @param {ValidSchema<TSchema>} schema - The schema definition for the entity.
    * @throws {Error} If the schema's identifier_field is not one of its defined fields.
    * @protected
    */
-  constructor(
-    schema: ValidSchema<TSchema>,
-    protected _alias: CurrentAlias,
-  ) {
+  constructor(schema: ValidSchema<TSchema>) {
     if (typeof schema === 'string') {
       throw new Error(`Invalid Schema: ${schema}`);
     }
-    if (!schema.alias.includes(this._alias))
-      throw new Error(
-        `Unsupported alia ${this._alias} for schema ${schema.source_name}`,
-      );
     if (!schema.fields.includes(schema.identifier_field)) {
       throw new Error(
         `Schema identifier_field '${String(schema.identifier_field)}' must be one of the schema's defined fields. Schema: ${schema.source_name}`,
@@ -216,8 +202,8 @@ export abstract class Criteria<
    * Gets the alias used for the entity of this criteria.
    * @returns {CurrentAlias} The alias string.
    */
-  get alias(): CurrentAlias {
-    return this._alias;
+  get alias(): TSchema['alias'] {
+    return this.schema.alias;
   }
   /**
    * Sets the maximum number of records to return (LIMIT).
@@ -324,35 +310,36 @@ export abstract class Criteria<
   /**
    * Adds a join to another criteria.
    * @template TJoinSchema - The schema of the entity to join.
-   * @template TJoinedCriteriaAlias - The alias for the joined entity.
-   * @template TMatchingJoinConfig - The specific join configuration from the parent schema that matches the joined
-   *   alias.
-   * @param {JoinCriteriaParameterType<TSchema, TJoinSchema, TJoinedCriteriaAlias, TMatchingJoinConfig>} criteriaToJoin
-   * The criteria instance representing the entity to join (e.g., `InnerJoinCriteria`, `LeftJoinCriteria`).
-   * @param {JoinParameterType<TSchema, TJoinSchema, TMatchingJoinConfig>} joinParameter
-   * The parameters defining how the join should be performed (e.g., fields for simple join, pivot table details for
+   * @template TJoinedCriteriaSourceName - The `source_name` of the entity being joined.
+   * @template TMatchingJoinConfig - The specific join configuration from the parent schema that matches the provided `joinAlias` and `criteriaToJoin.sourceName`.
+   * @param {TMatchingJoinConfig['alias']} joinAlias - The specific alias defined in the parent schema's `joins` array for this relation.
+   * @param {JoinCriteriaParameterType<TSchema, TJoinSchema, TJoinedCriteriaSourceName, TMatchingJoinConfig>} criteriaToJoin -
+   *   The criteria instance representing the entity to join (e.g., `InnerJoinCriteria`, `LeftJoinCriteria`).
+   * @param {JoinParameterType<TSchema, TJoinSchema, TMatchingJoinConfig>} joinParameter -
+   *   The parameters defining how the join should be performed (e.g., fields for simple join, pivot table details for
    *   many-to-many).
    * @returns {this} The current criteria instance for chaining.
    * @throws {Error} If `criteriaToJoin` is a string (which is invalid).
    * @throws {Error} If `parent_field` in `joinParameter` (or `parent_field.reference` for pivot joins) is not defined
    *   in the parent schema.
-   * @throws {Error} If the join configuration for the given `criteriaToJoin.alias` is not found in the parent schema's
+   * @throws {Error} If the join configuration for the given `joinAlias` and `criteriaToJoin.sourceName` is not found in the parent schema's
    *   `joins` array.
    * @throws {Error} If `joinParameter` is invalid for the `relation_type` defined in the schema (e.g., using
    *   simple join input for many-to-many or vice-versa).
    */
   join<
     TJoinSchema extends CriteriaSchema,
-    TJoinedCriteriaAlias extends SelectedAliasOf<TJoinSchema>,
+    TJoinedCriteriaSourceName extends TJoinSchema['source_name'],
     TMatchingJoinConfig extends SpecificMatchingJoinConfig<
       TSchema,
-      TJoinedCriteriaAlias
+      TJoinedCriteriaSourceName
     >,
   >(
+    joinAlias: TMatchingJoinConfig['alias'],
     criteriaToJoin: JoinCriteriaParameterType<
       TSchema,
       TJoinSchema,
-      TJoinedCriteriaAlias,
+      TJoinedCriteriaSourceName,
       TMatchingJoinConfig
     >,
     joinParameter: JoinParameterType<TSchema, TJoinSchema, TMatchingJoinConfig>,
@@ -366,11 +353,13 @@ export abstract class Criteria<
       : this.assetFieldOnSchema(joinParameter.parent_field);
 
     const joinConfig = this.schema.joins.find(
-      (join) => join.alias === criteriaToJoin.alias,
+      (join) =>
+        join.target_source_name === criteriaToJoin.sourceName &&
+        join.alias === joinAlias,
     );
     if (!joinConfig) {
       throw new Error(
-        `Join configuration for alias '${String(criteriaToJoin.alias)}' not found in schema '${this.schema.source_name}'.`,
+        `Join configuration for '${String(joinAlias)}' of '${String(criteriaToJoin.sourceName)}' not found in schema '${this.schema.source_name}'.`,
       );
     }
 
@@ -383,9 +372,13 @@ export abstract class Criteria<
       parent_alias: this.alias,
       parent_source_name: this.sourceName,
       relation_type: joinConfig.relation_type,
+      join_alias: joinAlias,
       join_metadata:
-        this.schema.joins.find((join) => join.alias === criteriaToJoin.alias)
-          ?.metadata ?? {},
+        this.schema.joins.find(
+          (join) =>
+            join.alias === joinAlias &&
+            join.target_source_name === criteriaToJoin.sourceName,
+        )?.metadata ?? {},
       parent_schema_metadata: this.schema.metadata ?? {},
       parent_identifier: this.identifierField,
     };
diff --git a/src/criteria/cursor.ts b/src/criteria/cursor.ts
index 107eaf0..d4111a4 100644
--- a/src/criteria/cursor.ts
+++ b/src/criteria/cursor.ts
@@ -78,4 +78,8 @@ export class Cursor<
     this.filters = filterArray as typeof this.filters;
     this.order = order;
   }
+
+  get operator() {
+    return this.filters[0].operator;
+  }
 }
diff --git a/src/criteria/filter/filter-group.ts b/src/criteria/filter/filter-group.ts
index 2c5070d..86bea90 100644
--- a/src/criteria/filter/filter-group.ts
+++ b/src/criteria/filter/filter-group.ts
@@ -36,7 +36,7 @@ export class FilterGroup<T extends string = string>
     return this._logicalOperator;
   }
 
-  static createInitial<T extends string = string>(
+  public static createInitial<T extends string = string>(
     filterPrimitive: FilterPrimitive<T, FilterOperator>,
   ): FilterGroup<T> {
     return new FilterGroup({
@@ -45,14 +45,16 @@ export class FilterGroup<T extends string = string>
     });
   }
 
-  toPrimitive(): FilterGroupPrimitive<T> {
+  public toPrimitive(): FilterGroupPrimitive<T> {
     return {
       logicalOperator: this._logicalOperator,
       items: this._items.map((item) => item.toPrimitive()),
     };
   }
 
-  addAnd(filterPrimitive: FilterPrimitive<T, FilterOperator>): FilterGroup<T> {
+  public addAnd(
+    filterPrimitive: FilterPrimitive<T, FilterOperator>,
+  ): FilterGroup<T> {
     if (this._logicalOperator === LogicalOperator.AND) {
       return new FilterGroup({
         logicalOperator: LogicalOperator.AND,
@@ -88,7 +90,9 @@ export class FilterGroup<T extends string = string>
     });
   }
 
-  addOr(filterPrimitive: FilterPrimitive<T, FilterOperator>): FilterGroup<T> {
+  public addOr(
+    filterPrimitive: FilterPrimitive<T, FilterOperator>,
+  ): FilterGroup<T> {
     const currentItems = this._items.map((item) => item.toPrimitive());
 
     if (this._logicalOperator === LogicalOperator.AND) {
@@ -123,13 +127,21 @@ export class FilterGroup<T extends string = string>
     });
   }
 
-  accept<TranslationContext, TranslationOutput = TranslationContext>(
-    visitor: ICriteriaVisitor<TranslationContext, TranslationOutput>,
+  /**
+   * Accepts a visitor and calls the appropriate visit method based on the logical operator.
+   * @param visitor The visitor implementation.
+   * @param currentAlias The alias of the current entity being processed.
+   * @param context The mutable context object for the translation.
+   */
+  public accept<TranslationContext>(
+    visitor: ICriteriaVisitor<TranslationContext>,
     currentAlias: string,
     context: TranslationContext,
-  ): TranslationOutput {
-    return this.logicalOperator === LogicalOperator.AND
-      ? visitor.visitAndGroup(this, currentAlias, context)
-      : visitor.visitOrGroup(this, currentAlias, context);
+  ): void {
+    if (this.logicalOperator === LogicalOperator.AND) {
+      visitor.visitAndGroup(this, currentAlias, context);
+    } else {
+      visitor.visitOrGroup(this, currentAlias, context);
+    }
   }
 }
diff --git a/src/criteria/filter/filter.ts b/src/criteria/filter/filter.ts
index 916c91c..fcc5dfc 100644
--- a/src/criteria/filter/filter.ts
+++ b/src/criteria/filter/filter.ts
@@ -26,24 +26,27 @@ export class Filter<T extends string, Operator extends FilterOperator>
     return this.primitive.value;
   }
 
-  accept<
-    TranslationContext,
-    TranslationOutput = TranslationContext,
-    TFilterVisitorOutput extends any = any,
-  >(
-    visitor: ICriteriaVisitor<
-      TranslationContext,
-      TranslationOutput,
-      TFilterVisitorOutput
-    >,
+  /**
+   * Accepts a visitor and calls the appropriate visit method.
+   * @template TranslationContext The type of the context object.
+   * @template TFilterVisitorOutput The specific return type expected from `visitFilter`.
+   * @param visitor The visitor implementation.
+   * @param currentAlias The alias of the current entity being processed.
+   * @param context The mutable context object for the translation.
+   * @returns The result of the visitor processing this filter.
+   */
+  public accept<TranslationContext, TFilterVisitorOutput extends any>(
+    visitor: ICriteriaVisitor<TranslationContext, TFilterVisitorOutput>,
     currentAlias: string,
+    context: TranslationContext,
   ): TFilterVisitorOutput {
-    return visitor.visitFilter(this, currentAlias);
+    return visitor.visitFilter(this, currentAlias, context);
   }
 
-  toPrimitive(): FilterPrimitive<T, Operator> {
+  public toPrimitive(): FilterPrimitive<T, Operator> {
     return this.primitive;
   }
+
   private isString(value: any): value is string {
     return typeof value === 'string';
   }
diff --git a/src/criteria/index.ts b/src/criteria/index.ts
index c79689e..6b14d0e 100644
--- a/src/criteria/index.ts
+++ b/src/criteria/index.ts
@@ -19,7 +19,6 @@ export { GetTypedCriteriaSchema } from './types/schema.types.js';
 export type {
   CriteriaSchema,
   FieldOfSchema,
-  SelectedAliasOf,
   JoinRelationType,
   SchemaJoins,
 } from './types/schema.types.js';
diff --git a/src/criteria/join/inner.join-criteria.ts b/src/criteria/join/inner.join-criteria.ts
index bcf542d..fffd8d1 100644
--- a/src/criteria/join/inner.join-criteria.ts
+++ b/src/criteria/join/inner.join-criteria.ts
@@ -1,7 +1,6 @@
 import type {
   CriteriaSchema,
   JoinRelationType,
-  SelectedAliasOf,
 } from '../types/schema.types.js';
 import type { PivotJoin, SimpleJoin } from '../types/join-parameter.types.js';
 import { Criteria, type ValidSchema } from '../criteria.js';
@@ -9,48 +8,38 @@ import type { ICriteriaVisitor } from '../types/visitor-interface.types.js';
 
 /**
  * Represents an INNER JOIN criteria.
- * It extends the base {@link Criteria} and defines how it's visited by a {@link ICriteriaVisitor}.
  * @template CSchema - The {@link CriteriaSchema} of the entity being joined.
  * @template Alias - The selected alias for the joined entity from its schema.
  */
 export class InnerJoinCriteria<
   CSchema extends CriteriaSchema,
-  Alias extends SelectedAliasOf<CSchema> = SelectedAliasOf<CSchema>,
-> extends Criteria<CSchema, Alias> {
+> extends Criteria<CSchema> {
   /**
    * Accepts a criteria visitor to process this inner join criteria.
-   * It first validates the join field against the schema before dispatching to the visitor.
-   * @template TranslationContext - The type of the context object passed during traversal.
-   * @template TranslationOutput - The type of the result returned by visitor methods.
-   * @param {ICriteriaVisitor<TranslationContext, TranslationOutput>} visitor - The visitor instance.
-   * @param {PivotJoin<CriteriaSchema, CSchema, JoinRelationType> | SimpleJoin<CriteriaSchema, CSchema,
-   *   JoinRelationType>} parameters - The fully resolved parameters for this join, including parent and join field
-   *   details.
-   * @param {TranslationContext} context - The context object to be passed to the visitor.
-   * @returns {TranslationOutput} The result of the visitor processing this join.
+   * @param visitor The visitor instance.
+   * @param parameters The fully resolved parameters for this join.
+   * @param context The context object to be passed to the visitor.
    */
-  accept<TranslationContext, TranslationOutput>(
-    visitor: ICriteriaVisitor<TranslationContext, TranslationOutput>,
+  public accept<TranslationContext>(
+    visitor: ICriteriaVisitor<TranslationContext>,
     parameters:
       | PivotJoin<CriteriaSchema, CSchema, JoinRelationType>
       | SimpleJoin<CriteriaSchema, CSchema, JoinRelationType>,
     context: TranslationContext,
-  ): TranslationOutput {
+  ): void {
     typeof parameters.join_field === 'object'
       ? this.assetFieldOnSchema(parameters.join_field.reference)
       : this.assetFieldOnSchema(parameters.join_field);
 
-    return visitor.visitInnerJoin(this, parameters, context);
+    visitor.visitInnerJoin(this, parameters, context);
   }
+
   /**
-   * Returns a new instance of `RootCriteria` with the same schema and alias configuration,
-   * but with all other states (filters, joins, ordering, pagination, selection) reset to their defaults.
-   * @returns {InnerJoinCriteria<CSchema, Alias>} A new, reset `RootCriteria` instance.
+   * Returns a new instance of `InnerJoinCriteria` with the same schema and alias configuration,
+   * but with all other states reset to their defaults.
+   * @returns {InnerJoinCriteria<CSchema, Alias>} A new, reset `InnerJoinCriteria` instance.
    */
-  resetCriteria(): InnerJoinCriteria<CSchema, Alias> {
-    return new InnerJoinCriteria(
-      this.schema as ValidSchema<CSchema>,
-      this._alias,
-    );
+  public resetCriteria(): InnerJoinCriteria<CSchema> {
+    return new InnerJoinCriteria(this.schema as ValidSchema<CSchema>);
   }
 }
diff --git a/src/criteria/join/left.join-criteria.ts b/src/criteria/join/left.join-criteria.ts
index 1227d5a..4eeaa6e 100644
--- a/src/criteria/join/left.join-criteria.ts
+++ b/src/criteria/join/left.join-criteria.ts
@@ -1,7 +1,6 @@
 import type {
   CriteriaSchema,
   JoinRelationType,
-  SelectedAliasOf,
 } from '../types/schema.types.js';
 import type { PivotJoin, SimpleJoin } from '../types/join-parameter.types.js';
 import { Criteria, type ValidSchema } from '../criteria.js';
@@ -15,8 +14,7 @@ import type { ICriteriaVisitor } from '../types/visitor-interface.types.js';
  */
 export class LeftJoinCriteria<
   CSchema extends CriteriaSchema,
-  Alias extends SelectedAliasOf<CSchema> = SelectedAliasOf<CSchema>,
-> extends Criteria<CSchema, Alias> {
+> extends Criteria<CSchema> {
   /**
    * Accepts a criteria visitor to process this left join criteria.
    * It first validates the join field against the schema before dispatching to the visitor.
@@ -28,28 +26,25 @@ export class LeftJoinCriteria<
    * @param {TranslationContext} context - The context object to be passed to the visitor.
    * @returns {TranslationOutput} The result of the visitor processing this join.
    */
-  accept<TranslationContext, TranslationOutput>(
-    visitor: ICriteriaVisitor<TranslationContext, TranslationOutput>,
+  accept<TranslationContext>(
+    visitor: ICriteriaVisitor<TranslationContext>,
     parameters:
       | PivotJoin<CriteriaSchema, CSchema, JoinRelationType>
       | SimpleJoin<CriteriaSchema, CSchema, JoinRelationType>,
     context: TranslationContext,
-  ): TranslationOutput {
+  ): void {
     typeof parameters.join_field === 'object'
       ? this.assetFieldOnSchema(parameters.join_field.reference)
       : this.assetFieldOnSchema(parameters.join_field);
 
-    return visitor.visitLeftJoin(this, parameters, context);
+    visitor.visitLeftJoin(this, parameters, context);
   }
   /**
    * Returns a new instance of `RootCriteria` with the same schema and alias configuration,
    * but with all other states (filters, joins, ordering, pagination, selection) reset to their defaults.
    * @returns {LeftJoinCriteria<CSchema, Alias>} A new, reset `RootCriteria` instance.
    */
-  resetCriteria(): LeftJoinCriteria<CSchema, Alias> {
-    return new LeftJoinCriteria(
-      this.schema as ValidSchema<CSchema>,
-      this._alias,
-    );
+  resetCriteria(): LeftJoinCriteria<CSchema> {
+    return new LeftJoinCriteria(this.schema as ValidSchema<CSchema>);
   }
 }
diff --git a/src/criteria/join/outer.join-criteria.ts b/src/criteria/join/outer.join-criteria.ts
index 1ae0d07..3906396 100644
--- a/src/criteria/join/outer.join-criteria.ts
+++ b/src/criteria/join/outer.join-criteria.ts
@@ -1,7 +1,6 @@
 import type {
   CriteriaSchema,
   JoinRelationType,
-  SelectedAliasOf,
 } from '../types/schema.types.js';
 import type { PivotJoin, SimpleJoin } from '../types/join-parameter.types.js';
 import { Criteria, type ValidSchema } from '../criteria.js';
@@ -10,46 +9,39 @@ import type { ICriteriaVisitor } from '../types/visitor-interface.types.js';
 /**
  * Represents an OUTER JOIN (typically FULL OUTER JOIN) criteria.
  * It extends the base {@link Criteria} and defines how it's visited by a {@link ICriteriaVisitor}.
- * Note: Full OUTER JOIN support can vary between database systems.
  * @template CSchema - The {@link CriteriaSchema} of the entity being joined.
  * @template Alias - The selected alias for the joined entity from its schema.
  */
 export class OuterJoinCriteria<
   CSchema extends CriteriaSchema,
-  Alias extends SelectedAliasOf<CSchema> = SelectedAliasOf<CSchema>,
-> extends Criteria<CSchema, Alias> {
+> extends Criteria<CSchema> {
   /**
    * Accepts a criteria visitor to process this outer join criteria.
-   * It first validates the join field against the schema before dispatching to the visitor.
-   * @template TranslationContext - The type of the context object passed during traversal.
-   * @template TranslationOutput - The type of the result returned by visitor methods.
-   * @param {ICriteriaVisitor<TranslationContext, TranslationOutput>} visitor - The visitor instance.
-   * @param {PivotJoin<CriteriaSchema, CSchema, JoinRelationType> | SimpleJoin<CriteriaSchema, CSchema, JoinRelationType>} parameters -
-   *   The fully resolved parameters for this join, including parent and join field details.
-   * @param {TranslationContext} context - The context object to be passed to the visitor.
-   * @returns {TranslationOutput} The result of the visitor processing this join.
+   * @template TranslationContext The type of the context object passed during traversal.
+   * @template TOuterJoinVisitorOutput The specific return type expected from the visitor's `visitOuterJoin` method.
+   * @param visitor The visitor instance.
+   * @param parameters The fully resolved parameters for this join.
+   * @param context The context object to be passed to the visitor.
+   * @returns The result of the visitor processing this join.
    */
-  accept<TranslationContext, TranslationOutput>(
-    visitor: ICriteriaVisitor<TranslationContext, TranslationOutput>,
+  public accept<TranslationContext>(
+    visitor: ICriteriaVisitor<TranslationContext>,
     parameters:
       | PivotJoin<CriteriaSchema, CSchema, JoinRelationType>
       | SimpleJoin<CriteriaSchema, CSchema, JoinRelationType>,
     context: TranslationContext,
-  ): TranslationOutput {
+  ): void {
     typeof parameters.join_field === 'object'
       ? this.assetFieldOnSchema(parameters.join_field.reference)
       : this.assetFieldOnSchema(parameters.join_field);
-    return visitor.visitOuterJoin(this, parameters, context);
+    visitor.visitOuterJoin(this, parameters, context);
   }
   /**
-   * Returns a new instance of `RootCriteria` with the same schema and alias configuration,
-   * but with all other states (filters, joins, ordering, pagination, selection) reset to their defaults.
-   * @returns {OuterJoinCriteria<CSchema, Alias>} A new, reset `RootCriteria` instance.
+   * Returns a new instance of `OuterJoinCriteria` with the same schema and alias configuration,
+   * but with all other states reset to their defaults.
+   * @returns {OuterJoinCriteria<CSchema, Alias>} A new, reset `OuterJoinCriteria` instance.
    */
-  resetCriteria(): OuterJoinCriteria<CSchema, Alias> {
-    return new OuterJoinCriteria(
-      this.schema as ValidSchema<CSchema>,
-      this._alias,
-    );
+  public resetCriteria(): OuterJoinCriteria<CSchema> {
+    return new OuterJoinCriteria(this.schema as ValidSchema<CSchema>);
   }
 }
diff --git a/src/criteria/root.criteria.ts b/src/criteria/root.criteria.ts
index 4136946..bcac7f2 100644
--- a/src/criteria/root.criteria.ts
+++ b/src/criteria/root.criteria.ts
@@ -1,43 +1,33 @@
 import { Criteria, type ValidSchema } from './criteria.js';
-import type { CriteriaSchema, SelectedAliasOf } from './types/schema.types.js';
+import type { CriteriaSchema } from './types/schema.types.js';
 import type { ICriteriaVisitor } from './types/visitor-interface.types.js';
 
 /**
  * Represents the root criteria for a query.
- * This is the main entry point for building a query and defines the primary entity being queried.
- * It extends the base {@link Criteria} and defines how it's visited by a {@link ICriteriaVisitor}.
  * @template CSchema - The {@link CriteriaSchema} of the root entity.
  * @template Alias - The selected alias for the root entity from its schema.
  */
 export class RootCriteria<
   CSchema extends CriteriaSchema,
-  Alias extends SelectedAliasOf<CSchema>,
-> extends Criteria<CSchema, Alias> {
+> extends Criteria<CSchema> {
   /**
    * Accepts a criteria visitor to process this root criteria.
-   * This method is the entry point for the visitor pattern to traverse the criteria tree.
-   * @template TranslationContext - The type of the context object passed during traversal (e.g., a query builder
-   *   instance).
-   * @template TranslationOutput - The type of the result returned by visitor methods (e.g., the modified query builder
-   *   or a query string).
-   * @param {ICriteriaVisitor<TranslationContext, TranslationOutput>} visitor - The visitor instance responsible for
-   *   translating criteria parts.
-   * @param {TranslationContext} context - The context object to be passed to the visitor (e.g., an initial query
-   *   builder or an empty string for SQL).
-   * @returns {TranslationOutput} The result of the visitor processing this root criteria and its components.
+   * @param visitor The visitor instance responsible for translating criteria parts.
+   * @param context The context object to be passed to the visitor.
    */
-  accept<TranslationContext, TranslationOutput>(
-    visitor: ICriteriaVisitor<TranslationContext, TranslationOutput>,
+  public accept<TranslationContext>(
+    visitor: ICriteriaVisitor<TranslationContext>,
     context: TranslationContext,
-  ): TranslationOutput {
-    return visitor.visitRoot(this, context);
+  ): void {
+    visitor.visitRoot(this, context);
   }
+
   /**
    * Returns a new instance of `RootCriteria` with the same schema and alias configuration,
    * but with all other states (filters, joins, ordering, pagination, selection) reset to their defaults.
    * @returns {RootCriteria<CSchema, Alias>} A new, reset `RootCriteria` instance.
    */
-  resetCriteria(): RootCriteria<CSchema, Alias> {
-    return new RootCriteria(this.schema as ValidSchema<CSchema>, this._alias);
+  public resetCriteria(): RootCriteria<CSchema> {
+    return new RootCriteria(this.schema as ValidSchema<CSchema>);
   }
 }
diff --git a/src/criteria/test/criteria-factory.test.ts b/src/criteria/test/criteria-factory.test.ts
index a066af0..2be4526 100644
--- a/src/criteria/test/criteria-factory.test.ts
+++ b/src/criteria/test/criteria-factory.test.ts
@@ -8,8 +8,8 @@ import { UserSchema, PostSchema } from './fake-entities.js';
 describe('CriteriaFactory', () => {
   describe('GetCriteria', () => {
     it('should create a RootCriteria instance with correct sourceName and alias', () => {
-      const alias = UserSchema.alias[0]!;
-      const criteria = CriteriaFactory.GetCriteria(UserSchema, alias);
+      const alias = UserSchema.alias;
+      const criteria = CriteriaFactory.GetCriteria(UserSchema);
 
       expect(criteria).toBeInstanceOf(RootCriteria);
       expect(criteria.sourceName).toBe(UserSchema.source_name);
@@ -19,8 +19,8 @@ describe('CriteriaFactory', () => {
 
   describe('GetInnerJoinCriteria', () => {
     it('should create an InnerJoinCriteria instance with correct sourceName and alias', () => {
-      const alias = PostSchema.alias[0]!;
-      const criteria = CriteriaFactory.GetInnerJoinCriteria(PostSchema, alias);
+      const alias = PostSchema.alias;
+      const criteria = CriteriaFactory.GetInnerJoinCriteria(PostSchema);
 
       expect(criteria).toBeInstanceOf(InnerJoinCriteria);
       expect(criteria.sourceName).toBe(PostSchema.source_name);
@@ -30,8 +30,8 @@ describe('CriteriaFactory', () => {
 
   describe('GetLeftJoinCriteria', () => {
     it('should create a LeftJoinCriteria instance with correct sourceName and alias', () => {
-      const alias = PostSchema.alias[0]!;
-      const criteria = CriteriaFactory.GetLeftJoinCriteria(PostSchema, alias);
+      const alias = PostSchema.alias;
+      const criteria = CriteriaFactory.GetLeftJoinCriteria(PostSchema);
 
       expect(criteria).toBeInstanceOf(LeftJoinCriteria);
       expect(criteria.sourceName).toBe(PostSchema.source_name);
@@ -41,8 +41,8 @@ describe('CriteriaFactory', () => {
 
   describe('GetOuterJoinCriteria', () => {
     it('should create an OuterJoinCriteria instance with correct sourceName and alias', () => {
-      const alias = PostSchema.alias[0]!;
-      const criteria = CriteriaFactory.GetOuterJoinCriteria(PostSchema, alias);
+      const alias = PostSchema.alias;
+      const criteria = CriteriaFactory.GetOuterJoinCriteria(PostSchema);
 
       expect(criteria).toBeInstanceOf(OuterJoinCriteria);
       expect(criteria.sourceName).toBe(PostSchema.source_name);
diff --git a/src/criteria/test/criteria.test.ts b/src/criteria/test/criteria.test.ts
index 93fdaf8..ef8da55 100644
--- a/src/criteria/test/criteria.test.ts
+++ b/src/criteria/test/criteria.test.ts
@@ -1,10 +1,3 @@
-import { RootCriteria } from '../root.criteria.js';
-import { FilterGroup } from '../filter/filter-group.js';
-import { OrderDirection } from '../order/order.js';
-import { InnerJoinCriteria } from '../join/inner.join-criteria.js';
-import { LeftJoinCriteria } from '../join/left.join-criteria.js';
-import type { StoredJoinDetails } from '../types/join-utility.types.js';
-
 import { FilterOperator, LogicalOperator } from '../types/operator.types.js';
 import {
   PermissionSchema,
@@ -15,13 +8,18 @@ import {
 import {
   type CriteriaSchema,
   GetTypedCriteriaSchema,
-  type SelectedAliasOf,
 } from '../types/schema.types.js';
+import { type StoredJoinDetails } from '../types/join-utility.types.js';
+import { RootCriteria } from '../root.criteria.js';
+import { FilterGroup } from '../filter/filter-group.js';
+import { OrderDirection } from '../order/order.js';
+import { InnerJoinCriteria } from '../join/inner.join-criteria.js';
+import { LeftJoinCriteria } from '../join/left.join-criteria.js';
 
 const testJoinsData = (
   joinDetails: StoredJoinDetails<CriteriaSchema>,
   joinParameter: { join_field: string | object; parent_field: string | object },
-  parentCriteria: RootCriteria<CriteriaSchema, SelectedAliasOf<CriteriaSchema>>,
+  parentCriteria: RootCriteria<CriteriaSchema>,
 ) => {
   expect(joinDetails.parameters.join_field).toBe(joinParameter.join_field);
   expect(joinDetails.parameters.parent_field).toBe(joinParameter.parent_field);
@@ -35,10 +33,10 @@ const testJoinsData = (
 };
 
 describe('Criteria', () => {
-  let criteriaRoot: RootCriteria<typeof PostSchema, 'posts'>;
+  let criteriaRoot: RootCriteria<typeof PostSchema>;
 
   beforeEach(() => {
-    criteriaRoot = new RootCriteria(PostSchema, 'posts');
+    criteriaRoot = new RootCriteria(PostSchema);
   });
 
   describe('Initialization and Defaults', () => {
@@ -67,7 +65,7 @@ describe('Criteria', () => {
         ...PostSchema,
         metadata: { customInfo: 'testValue' },
       });
-      const criteriaWithMeta = new RootCriteria(schemaWithMetadata, 'posts');
+      const criteriaWithMeta = new RootCriteria(schemaWithMetadata);
       expect(criteriaWithMeta.schemaMetadata).toEqual({
         customInfo: 'testValue',
       });
@@ -87,7 +85,6 @@ describe('Criteria', () => {
           new RootCriteria(
             // @ts-expect-error Testing invalid schema
             invalidSchema,
-            'users',
           ),
       ).toThrow(
         `Schema identifier_field 'non_existent_field' must be one of the schema's defined fields. Schema: user`,
@@ -406,15 +403,8 @@ describe('Criteria', () => {
   });
 
   describe('Join Functionality', () => {
-    it('should throw an error if join configuration for alias is not found in schema', () => {
-      expect(() => {
-        // @ts-expect-error testing invalid join_alias type
-        new InnerJoinCriteria(UserSchema, 'non_existent_join_alias');
-      }).toThrow('Unsupported alia non_existent_join_alias for schema user');
-    });
-
     it('should throw an error if parent_field in joinParameter is not in parent schema', () => {
-      const userJoinCriteria = new InnerJoinCriteria(UserSchema, 'publisher');
+      const userJoinCriteria = new InnerJoinCriteria(UserSchema);
       const joinParameter = {
         parent_field: 'invalid_parent_field',
         join_field: 'uuid',
@@ -422,20 +412,20 @@ describe('Criteria', () => {
 
       expect(() => {
         // @ts-expect-error testing invalid parent_field type
-        criteriaRoot.join(userJoinCriteria, joinParameter);
+        criteriaRoot.join('publisher', userJoinCriteria, joinParameter);
       }).toThrow(
         "The field 'invalid_parent_field' is not defined in the schema 'post'.",
       );
     });
 
     it('should add an inner join and correctly populate parent_identifier', () => {
-      const userJoinCriteria = new InnerJoinCriteria(UserSchema, 'publisher');
+      const userJoinCriteria = new InnerJoinCriteria(UserSchema);
       const joinParameter = {
         parent_field: 'user_uuid',
         join_field: 'uuid',
       } as const;
 
-      criteriaRoot.join(userJoinCriteria, joinParameter);
+      criteriaRoot.join('publisher', userJoinCriteria, joinParameter);
 
       const joinsArray = criteriaRoot.joins;
       expect(joinsArray.length).toBe(1);
@@ -443,7 +433,7 @@ describe('Criteria', () => {
       const joinEntry = joinsArray[0];
       expect(joinEntry).toBeDefined();
       if (joinEntry) {
-        expect(joinEntry.criteria.alias).toBe('publisher');
+        expect(joinEntry.parameters.join_alias).toBe('publisher');
         expect(joinEntry.criteria).toBeInstanceOf(InnerJoinCriteria);
         testJoinsData(joinEntry, joinParameter, criteriaRoot);
         expect(joinEntry.criteria).toBe(userJoinCriteria);
@@ -451,18 +441,19 @@ describe('Criteria', () => {
     });
 
     it('should add a many-to-many join and correctly populate parent_identifier', () => {
-      const userCriteriaRoot = new RootCriteria(UserSchema, 'users');
-      const permissionJoinCriteria = new InnerJoinCriteria(
-        PermissionSchema,
-        'permissions',
-      );
+      const userCriteriaRoot = new RootCriteria(UserSchema);
+      const permissionJoinCriteria = new InnerJoinCriteria(PermissionSchema);
       const joinParameter = {
         pivot_source_name: 'user_permission_pivot',
         parent_field: { pivot_field: 'user_uuid', reference: 'uuid' },
         join_field: { pivot_field: 'permission_uuid', reference: 'uuid' },
       } as const;
 
-      userCriteriaRoot.join(permissionJoinCriteria, joinParameter);
+      userCriteriaRoot.join(
+        'permissions',
+        permissionJoinCriteria,
+        joinParameter,
+      );
 
       const joinsArray = userCriteriaRoot.joins;
       expect(joinsArray.length).toBe(1);
@@ -480,33 +471,30 @@ describe('Criteria', () => {
     });
 
     it('should add multiple joins and correctly populate parent_identifier for each', () => {
-      const userJoinCriteria = new InnerJoinCriteria(UserSchema, 'publisher');
+      const userJoinCriteria = new InnerJoinCriteria(UserSchema);
       const userJoinParameter = {
         parent_field: 'user_uuid',
         join_field: 'uuid',
       } as const;
 
-      const commentJoinCriteria = new LeftJoinCriteria(
-        PostCommentSchema,
-        'comments',
-      );
+      const commentJoinCriteria = new LeftJoinCriteria(PostCommentSchema);
       const commentJoinParameter = {
         parent_field: 'uuid',
         join_field: 'post_uuid',
       } as const;
 
       criteriaRoot
-        .join(userJoinCriteria, userJoinParameter)
-        .join(commentJoinCriteria, commentJoinParameter);
+        .join('publisher', userJoinCriteria, userJoinParameter)
+        .join('comments', commentJoinCriteria, commentJoinParameter);
 
       const joinsArray = criteriaRoot.joins;
       expect(joinsArray.length).toBe(2);
 
       const publisherJoin = joinsArray.find(
-        (entry) => entry.criteria.alias === 'publisher',
+        (entry) => entry.parameters.join_alias === 'publisher',
       );
       const commentsJoin = joinsArray.find(
-        (entry) => entry.criteria.alias === 'comments',
+        (entry) => entry.parameters.join_alias === 'comments',
       );
 
       expect(publisherJoin).toBeDefined();
@@ -523,8 +511,8 @@ describe('Criteria', () => {
     });
 
     it('should replace a join if the same alias is used and check parent_identifier', () => {
-      const userJoinCriteria1 = new InnerJoinCriteria(UserSchema, 'publisher');
-      const userJoinCriteria2 = new LeftJoinCriteria(UserSchema, 'publisher');
+      const userJoinCriteria1 = new InnerJoinCriteria(UserSchema);
+      const userJoinCriteria2 = new LeftJoinCriteria(UserSchema);
 
       const userJoinParameter = {
         parent_field: 'user_uuid',
@@ -532,8 +520,8 @@ describe('Criteria', () => {
       } as const;
 
       criteriaRoot
-        .join(userJoinCriteria1, userJoinParameter)
-        .join(userJoinCriteria2, userJoinParameter);
+        .join('publisher', userJoinCriteria1, userJoinParameter)
+        .join('publisher', userJoinCriteria2, userJoinParameter);
 
       const joinsArray = criteriaRoot.joins;
       expect(joinsArray.length).toBe(1);
@@ -541,7 +529,7 @@ describe('Criteria', () => {
       const joinEntry = joinsArray[0];
       expect(joinEntry).toBeDefined();
       if (joinEntry) {
-        expect(joinEntry.criteria.alias).toBe('publisher');
+        expect(joinEntry.parameters.join_alias).toBe('publisher');
         expect(joinEntry.criteria).toBeInstanceOf(LeftJoinCriteria);
         testJoinsData(joinEntry, userJoinParameter, criteriaRoot);
         expect(joinEntry.criteria).toBe(userJoinCriteria2);
@@ -604,17 +592,16 @@ describe('Criteria', () => {
         'should throw for $description',
         ({
           rootSchema,
-          rootAlias,
           joinSchema,
-          joinAlias,
           joinParam,
+          joinAlias,
           expectedErrorMsg,
         }) => {
-          const root = new RootCriteria(rootSchema, rootAlias);
-          const joinCrit = new InnerJoinCriteria(joinSchema, joinAlias);
+          const root = new RootCriteria(rootSchema);
+          const joinCrit = new InnerJoinCriteria(joinSchema);
           expect(() => {
             // @ts-expect-error - Testing invalid types
-            root.join(joinCrit, joinParam);
+            root.join(joinAlias, joinCrit, joinParam);
           }).toThrow(expectedErrorMsg);
         },
       );
@@ -656,11 +643,11 @@ describe('Criteria', () => {
         } as const,
       ])(
         'should pass validation for a valid $description',
-        ({ rootSchema, rootAlias, joinSchema, joinAlias, joinParam }) => {
-          const root = new RootCriteria(rootSchema, rootAlias);
-          const joinCrit = new InnerJoinCriteria(joinSchema, joinAlias);
+        ({ rootSchema, joinSchema, joinAlias, joinParam }) => {
+          const root = new RootCriteria(rootSchema);
+          const joinCrit = new InnerJoinCriteria(joinSchema);
           expect(() => {
-            root.join(joinCrit, joinParam as any);
+            root.join(joinAlias, joinCrit, joinParam as any);
           }).not.toThrow();
         },
       );
@@ -669,7 +656,7 @@ describe('Criteria', () => {
 
   describe('Complex Criteria Building', () => {
     it('should build a complete criteria with all features', () => {
-      const criteria = new RootCriteria(PostSchema, 'posts')
+      const criteria = new RootCriteria(PostSchema)
         .setSelect(['uuid', 'title', 'user_uuid'])
         .where({
           field: 'title',
@@ -677,7 +664,8 @@ describe('Criteria', () => {
           value: '%test%',
         })
         .join(
-          new InnerJoinCriteria(PostCommentSchema, 'comments')
+          'comments',
+          new InnerJoinCriteria(PostCommentSchema)
             .setSelect(['uuid', 'comment_text'])
             .where({
               field: 'comment_text',
@@ -713,8 +701,7 @@ describe('Criteria', () => {
       expect(criteria.joins).toHaveLength(1);
       expect(criteria.orders).toHaveLength(1);
       const joinCriteria = criteria.joins[0]?.criteria as InnerJoinCriteria<
-        typeof PostCommentSchema,
-        'comments'
+        typeof PostCommentSchema
       >;
       expect(joinCriteria?.select).toEqual(
         expect.arrayContaining([
diff --git a/src/criteria/test/fake-entities.ts b/src/criteria/test/fake-entities.ts
index a52af05..54a519f 100644
--- a/src/criteria/test/fake-entities.ts
+++ b/src/criteria/test/fake-entities.ts
@@ -16,21 +16,24 @@ export interface User extends EntityBase {
 
 export const UserSchema = GetTypedCriteriaSchema({
   source_name: 'user',
-  alias: ['users', 'user', 'publisher'],
+  alias: 'users',
   fields: ['uuid', 'email', 'username', 'created_at'],
   identifier_field: 'uuid',
   joins: [
     {
       alias: 'permissions',
       relation_type: 'many_to_many',
+      target_source_name: 'permission',
     },
     {
       alias: 'addresses',
       relation_type: 'one_to_many',
+      target_source_name: 'address',
     },
     {
       alias: 'posts',
       relation_type: 'one_to_many',
+      target_source_name: 'post',
     },
   ],
 });
@@ -52,7 +55,7 @@ export interface Post extends EntityBase {
 
 export const PostSchema = GetTypedCriteriaSchema({
   source_name: 'post',
-  alias: ['posts', 'post'],
+  alias: 'posts',
   identifier_field: 'uuid',
   fields: [
     'uuid',
@@ -64,8 +67,16 @@ export const PostSchema = GetTypedCriteriaSchema({
     'metadata',
   ],
   joins: [
-    { alias: 'comments', relation_type: 'one_to_many' },
-    { alias: 'publisher', relation_type: 'many_to_one' },
+    {
+      alias: 'comments',
+      relation_type: 'one_to_many',
+      target_source_name: 'post_comment',
+    },
+    {
+      alias: 'publisher',
+      relation_type: 'many_to_one',
+      target_source_name: 'user',
+    },
   ],
 });
 export type PostSchema = typeof PostSchema;
@@ -78,12 +89,12 @@ export interface Comment extends EntityBase {
 
 export const PostCommentSchema = GetTypedCriteriaSchema({
   source_name: 'post_comment',
-  alias: ['comments', 'comment'],
+  alias: 'comments',
   fields: ['uuid', 'comment_text', 'user_uuid', 'post_uuid', 'created_at'],
   identifier_field: 'uuid',
   joins: [
-    { alias: 'post', relation_type: 'many_to_one' },
-    { alias: 'user', relation_type: 'many_to_one' },
+    { alias: 'post', relation_type: 'many_to_one', target_source_name: 'post' },
+    { alias: 'user', relation_type: 'many_to_one', target_source_name: 'user' },
   ],
 });
 export type PostCommentSchema = typeof PostCommentSchema;
@@ -94,13 +105,14 @@ export interface Permission extends EntityBase {
 
 export const PermissionSchema = GetTypedCriteriaSchema({
   source_name: 'permission',
-  alias: ['permissions', 'permission'],
+  alias: 'permissions',
   fields: ['uuid', 'name', 'created_at'],
   identifier_field: 'uuid',
   joins: [
     {
       alias: 'users',
       relation_type: 'many_to_many',
+      target_source_name: 'user',
     },
   ],
 });
@@ -112,13 +124,14 @@ export interface Address extends EntityBase {
 
 export const AddressSchema = GetTypedCriteriaSchema({
   source_name: 'address',
-  alias: ['addresses', 'address'],
+  alias: 'addresses',
   fields: ['uuid', 'direction', 'user_uuid', 'created_at'],
   identifier_field: 'uuid',
   joins: [
     {
       alias: 'user',
       relation_type: 'many_to_one',
+      target_source_name: 'user',
     },
   ],
 });
@@ -168,7 +181,7 @@ export interface DomainEvent<T extends { [key: string]: any }> {
 
 export const DomainEventsSchema = GetTypedCriteriaSchema({
   source_name: 'event',
-  alias: ['event', 'events'],
+  alias: 'events',
   identifier_field: 'id',
   fields: [
     'id',
diff --git a/src/criteria/translator/criteria-translator.ts b/src/criteria/translator/criteria-translator.ts
index 67b507a..5e69f1c 100644
--- a/src/criteria/translator/criteria-translator.ts
+++ b/src/criteria/translator/criteria-translator.ts
@@ -1,124 +1,96 @@
+import type { ICriteriaVisitor } from '../types/visitor-interface.types.js';
+import type { RootCriteria } from '../root.criteria.js';
 import type {
   CriteriaSchema,
   JoinRelationType,
-  SelectedAliasOf,
 } from '../types/schema.types.js';
-import type { RootCriteria } from '../root.criteria.js';
-import type { PivotJoin, SimpleJoin } from '../types/join-parameter.types.js';
-import type { FilterGroup } from '../filter/filter-group.js';
 import type { InnerJoinCriteria } from '../join/inner.join-criteria.js';
 import type { LeftJoinCriteria } from '../join/left.join-criteria.js';
 import type { OuterJoinCriteria } from '../join/outer.join-criteria.js';
+import type { PivotJoin, SimpleJoin } from '../types/join-parameter.types.js';
 import type { Filter } from '../filter/filter.js';
-import type { ICriteriaVisitor } from '../types/visitor-interface.types.js';
+import type { FilterGroup } from '../filter/filter-group.js';
 import type { FilterOperator } from '../types/operator.types.js';
 
 /**
- * Abstract Class for translating criteria into various query formats
- * @template TranslationContext - The target format (e.g., QueryBuilder, raw SQL string, etc.)
- * @template TranslationOutput - The output format by default its Source (Only specify this if
- * you really need something like a memory translator and the output would be different
- * from the TranslationContext itself)
- * @template RootSchema - The schema type for the root criteria
- * @example
- * // TypeORM QueryBuilder translator
- * class TypeORMTranslator implements CriteriaTranslator<SelectQueryBuilder<Entity>> {
- *  ...Concrete implementation
- * }
+ * An abstract base class for creating specific criteria translators.
+ * It implements the ICriteriaVisitor interface and provides a structured way to handle the translation process.
  *
- * // Raw MySQL translator
- * export class MysqlTranslator extends CriteriaTranslator<string, string> { {
- *  ...Concrete implementation
- * }
+ * @template TranslationContext The mutable context object (e.g., a query builder) passed through the traversal.
+ * @template TranslationOutput The final result type of the translation process. Defaults to `TranslationContext`.
+ * @template TFilterVisitorOutput The specific type returned by `visitFilter`.
  */
 export abstract class CriteriaTranslator<
   TranslationContext,
   TranslationOutput = TranslationContext,
-  TFilterVisitorOutput extends any = any,
-> implements
-    ICriteriaVisitor<
-      TranslationContext,
-      TranslationOutput,
-      TFilterVisitorOutput
-    >
+  TFilterVisitorOutput = any,
+> implements ICriteriaVisitor<TranslationContext, TFilterVisitorOutput>
 {
   /**
-   * Translates a criteria into the target source format
-   * @param criteria - The criteria to translate
-   * @param source - The source object to translate into (e.g., QueryBuilder instance, or raw SQL string)
-   * @returns The modified source or the output format if specified
+   * Translates a `RootCriteria` object into a target format.
+   * This is the main entry point for the translation process.
+   * @param criteria The `RootCriteria` to translate.
+   * @param source The initial context for the translation (e.g., a new query builder).
+   * @returns The final translated output.
    */
-  translate<RootCriteriaSchema extends CriteriaSchema>(
-    criteria: RootCriteria<
-      RootCriteriaSchema,
-      SelectedAliasOf<RootCriteriaSchema>
-    >,
+  public abstract translate<RootCriteriaSchema extends CriteriaSchema>(
+    criteria: RootCriteria<RootCriteriaSchema>,
     source: TranslationContext,
-  ): TranslationOutput {
-    return criteria.accept(this, source);
-  }
+  ): TranslationOutput;
 
-  abstract visitRoot<
-    RootCriteriaSchema extends CriteriaSchema,
-    RootAlias extends SelectedAliasOf<RootCriteriaSchema>,
-  >(
-    criteria: RootCriteria<RootCriteriaSchema, RootAlias>,
+  public abstract visitRoot<RootCSchema extends CriteriaSchema>(
+    criteria: RootCriteria<RootCSchema>,
     context: TranslationContext,
-  ): TranslationOutput;
+  ): void;
 
-  abstract visitInnerJoin<
+  public abstract visitInnerJoin<
     ParentCSchema extends CriteriaSchema,
-    JoinCriteriaSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCriteriaSchema>,
+    JoinCSchema extends CriteriaSchema,
   >(
-    criteria: InnerJoinCriteria<JoinCriteriaSchema, JoinAlias>,
+    criteria: InnerJoinCriteria<JoinCSchema>,
     parameters:
-      | PivotJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>
-      | SimpleJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>,
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
     context: TranslationContext,
-  ): TranslationOutput;
+  ): void;
 
-  abstract visitLeftJoin<
+  public abstract visitLeftJoin<
     ParentCSchema extends CriteriaSchema,
-    JoinCriteriaSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCriteriaSchema>,
+    JoinCSchema extends CriteriaSchema,
   >(
-    criteria: LeftJoinCriteria<JoinCriteriaSchema, JoinAlias>,
+    criteria: LeftJoinCriteria<JoinCSchema>,
     parameters:
-      | PivotJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>
-      | SimpleJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>,
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
     context: TranslationContext,
-  ): TranslationOutput;
+  ): void;
 
-  abstract visitOuterJoin<
+  public abstract visitOuterJoin<
     ParentCSchema extends CriteriaSchema,
-    JoinCriteriaSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCriteriaSchema>,
+    JoinCSchema extends CriteriaSchema,
   >(
-    criteria: OuterJoinCriteria<JoinCriteriaSchema, JoinAlias>,
+    criteria: OuterJoinCriteria<JoinCSchema>,
     parameters:
-      | PivotJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>
-      | SimpleJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>,
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
     context: TranslationContext,
-  ): TranslationOutput;
+  ): void;
 
-  abstract visitFilter<
-    FieldType extends string,
-    Operator extends FilterOperator,
-  >(
-    filter: Filter<FieldType, Operator>,
+  public abstract visitFilter<FieldType extends string>(
+    filter: Filter<FieldType, FilterOperator>,
     currentAlias: string,
+    context: TranslationContext,
   ): TFilterVisitorOutput;
 
-  abstract visitAndGroup<FieldType extends string>(
+  public abstract visitAndGroup<FieldType extends string>(
     group: FilterGroup<FieldType>,
     currentAlias: string,
     context: TranslationContext,
-  ): TranslationOutput;
+  ): void;
 
-  abstract visitOrGroup<FieldType extends string>(
+  public abstract visitOrGroup<FieldType extends string>(
     group: FilterGroup<FieldType>,
     currentAlias: string,
     context: TranslationContext,
-  ): TranslationOutput;
+  ): void;
 }
diff --git a/src/criteria/types/criteria.interface.ts b/src/criteria/types/criteria.interface.ts
index f55e11c..76c85e7 100644
--- a/src/criteria/types/criteria.interface.ts
+++ b/src/criteria/types/criteria.interface.ts
@@ -1,8 +1,4 @@
-import type {
-  CriteriaSchema,
-  FieldOfSchema,
-  SelectedAliasOf,
-} from './schema.types.js';
+import type { CriteriaSchema, FieldOfSchema } from './schema.types.js';
 import type { FilterGroup } from '../filter/filter-group.js';
 
 import type { Cursor } from '../cursor.js';
@@ -20,12 +16,8 @@ import type { FilterPrimitive } from '../filter/types/filter-primitive.types.js'
  * Base interface for defining query criteria.
  * It provides methods for filtering, joining, selecting fields, ordering, and paginating results.
  * @template TSchema - The schema definition for the primary entity.
- * @template CurrentAlias - The selected alias for the primary entity from its schema.
  */
-export interface ICriteriaBase<
-  TSchema extends CriteriaSchema,
-  CurrentAlias extends SelectedAliasOf<TSchema>,
-> {
+export interface ICriteriaBase<TSchema extends CriteriaSchema> {
   /**
    * Gets the metadata associated with the root schema of this criteria.
    * @returns {TSchema['metadata']} The metadata object from the schema, which can be undefined.
@@ -153,9 +145,9 @@ export interface ICriteriaBase<
 
   /**
    * Gets the alias for the root entity of this criteria.
-   * @returns {CurrentAlias} The alias string.
+   * @returns {TSchema['alias']} The alias string.
    */
-  get alias(): CurrentAlias;
+  get alias(): TSchema['alias'];
 
   /**
    * Gets the source name (e.g., table name) for the root entity of this criteria.
@@ -217,29 +209,31 @@ export interface ICriteriaBase<
   /**
    * Adds a join to another criteria.
    * @template TJoinSchema - The schema of the entity to join.
-   * @template TJoinedCriteriaAlias - The alias for the joined entity.
-   * @template TMatchingJoinConfig - The specific join configuration from the parent schema that matches the joined alias.
-   * @param {JoinCriteriaParameterType<TSchema, TJoinSchema, TJoinedCriteriaAlias, TMatchingJoinConfig>} criteriaToJoin
-   * The criteria instance representing the entity to join (e.g., `InnerJoinCriteria`, `LeftJoinCriteria`).
-   * @param {JoinParameterType<TSchema, TJoinSchema, TMatchingJoinConfig>} joinParameter
-   * The parameters defining how the join should be performed (e.g., fields for simple join, pivot table details for many-to-many).
+   * @template TJoinedCriteriaSourceName - The `source_name` of the entity being joined.
+   * @template TMatchingJoinConfig - The specific join configuration from the parent schema that matches the provided `joinAlias` and `criteriaToJoin.sourceName`.
+   * @param {TMatchingJoinConfig['alias']} joinAlias - The specific alias defined in the parent schema's `joins` array for this relation.
+   * @param {JoinCriteriaParameterType<TSchema, TJoinSchema, TJoinedCriteriaSourceName, TMatchingJoinConfig>} criteriaToJoin -
+   *   The criteria instance representing the entity to join (e.g., `InnerJoinCriteria`, `LeftJoinCriteria`).
+   * @param {JoinParameterType<TSchema, TJoinSchema, TMatchingJoinConfig>} joinParameter -
+   *   The parameters defining how the join should be performed (e.g., fields for simple join, pivot table details for many-to-many).
    * @returns {this} The current criteria instance for chaining.
-   * @throws {Error} If the join configuration for the given alias is not found in the parent schema.
+   * @throws {Error} If the join configuration for the given `joinAlias` and `criteriaToJoin.sourceName` is not found in the parent schema.
    * @throws {Error} If `parent_field` in `joinParameter` is not defined in the parent schema.
    * @throws {Error} If `joinParameter` is invalid for the `relation_type` defined in the schema (e.g., using simple join input for many-to-many).
    */
   join<
     TJoinSchema extends CriteriaSchema,
-    TJoinedCriteriaAlias extends SelectedAliasOf<TJoinSchema>,
+    TJoinedCriteriaSourceName extends TJoinSchema['source_name'],
     TMatchingJoinConfig extends SpecificMatchingJoinConfig<
       TSchema,
-      TJoinedCriteriaAlias
+      TJoinedCriteriaSourceName
     >,
   >(
+    joinAlias: TMatchingJoinConfig['alias'],
     criteriaToJoin: JoinCriteriaParameterType<
       TSchema,
       TJoinSchema,
-      TJoinedCriteriaAlias,
+      TJoinedCriteriaSourceName,
       TMatchingJoinConfig
     >,
     joinParameter: JoinParameterType<TSchema, TJoinSchema, TMatchingJoinConfig>,
diff --git a/src/criteria/types/join-parameter.types.ts b/src/criteria/types/join-parameter.types.ts
index fe12361..9ab9d9a 100644
--- a/src/criteria/types/join-parameter.types.ts
+++ b/src/criteria/types/join-parameter.types.ts
@@ -23,6 +23,7 @@ export type PivotJoin<
   parent_source_name: ParentSchema['source_name'];
   /** The alias used for the parent entity in the query. */
   parent_alias: ParentSchema['alias'][number];
+  join_alias: ParentSchema['joins'][number]['alias'];
   parent_identifier: FieldOfSchema<ParentSchema>;
   /** The source name (table name) of the pivot table. */
   pivot_source_name: string;
@@ -82,6 +83,7 @@ export type SimpleJoin<
   parent_source_name: ParentSchema['source_name'];
   /** The alias used for the parent entity in the query. */
   parent_alias: ParentSchema['alias'][number];
+  join_alias: ParentSchema['joins'][number]['alias'];
   parent_identifier: FieldOfSchema<ParentSchema>;
   /**
    * The field name in the parent schema used for the join condition.
diff --git a/src/criteria/types/join-utility.types.ts b/src/criteria/types/join-utility.types.ts
index d01f6f6..466c107 100644
--- a/src/criteria/types/join-utility.types.ts
+++ b/src/criteria/types/join-utility.types.ts
@@ -2,7 +2,6 @@ import type {
   CriteriaSchema,
   JoinRelationType,
   SchemaJoins,
-  SelectedAliasOf,
 } from './schema.types.js';
 import type { PivotJoin, SimpleJoin } from './join-parameter.types.js';
 
@@ -14,15 +13,11 @@ import type { PivotJoinInput, SimpleJoinInput } from './join-input.types.js';
 /**
  * Represents any type of join criteria (Inner, Left, or Outer).
  * @template CSchema - The {@link CriteriaSchema} of the entity being joined.
- * @template Alias - The selected alias for the joined entity from its schema.
  */
-export type AnyJoinCriteria<
-  CSchema extends CriteriaSchema,
-  Alias extends SelectedAliasOf<CSchema> = SelectedAliasOf<CSchema>,
-> =
-  | InnerJoinCriteria<CSchema, Alias>
-  | LeftJoinCriteria<CSchema, Alias>
-  | OuterJoinCriteria<CSchema, Alias>;
+export type AnyJoinCriteria<CSchema extends CriteriaSchema> =
+  | InnerJoinCriteria<CSchema>
+  | LeftJoinCriteria<CSchema>
+  | OuterJoinCriteria<CSchema>;
 
 /**
  * Defines the structure for storing the details of a configured join.
@@ -39,40 +34,40 @@ export interface StoredJoinDetails<ParentSchema extends CriteriaSchema> {
   /**
    * The criteria instance representing the joined entity (e.g., InnerJoinCriteria).
    */
-  criteria: AnyJoinCriteria<CriteriaSchema, SelectedAliasOf<CriteriaSchema>>;
+  criteria: AnyJoinCriteria<CriteriaSchema>;
 }
 
 /**
  * Determines the type of the criteria object to be passed to the `.join()` method.
- * If the `ActualJoinedAlias` is not a valid join alias in the `ParentSchema`,
+ * If the `ActualJoinedSourceName` is not configured for join in the `ParentSchema`,
  * this type resolves to an error message string, providing strong type-time feedback.
  * Otherwise, it resolves to {@link AnyJoinCriteria}.
  *
  * @template ParentSchema - The {@link CriteriaSchema} of the parent entity.
  * @template JoinedSchema - The {@link CriteriaSchema} of the entity to be joined.
- * @template ActualJoinedAlias - The specific alias used for the `JoinedSchema`.
- * @template MatchingConfigForActualAlias - The join configuration from `ParentSchema` that matches `ActualJoinedAlias`.
+ * @template ActualJoinedSourceName - The specific `source_name` of the `JoinedSchema` being joined.
+ * @template MatchingConfigForActualSourceName - The join configuration from `ParentSchema` that matches `ActualJoinedSourceName`.
  *                                         Should be `never` if no match is found.
  */
 export type JoinCriteriaParameterType<
   ParentSchema extends CriteriaSchema,
   JoinedSchema extends CriteriaSchema,
-  ActualJoinedAlias extends SelectedAliasOf<JoinedSchema>,
-  MatchingConfigForActualAlias extends SchemaJoins<string> | never,
-> = [MatchingConfigForActualAlias] extends [never]
-  ? `Error: The alias '${ActualJoinedAlias}' of schema '${JoinedSchema['source_name']}' is not configured for join in '${ParentSchema['source_name']}'.`
-  : AnyJoinCriteria<JoinedSchema, ActualJoinedAlias>;
+  ActualJoinedSourceName extends JoinedSchema['source_name'],
+  MatchingConfigForActualSourceName extends SchemaJoins<string> | never,
+> = [MatchingConfigForActualSourceName] extends [never]
+  ? `Error: The joined parent source name '${ActualJoinedSourceName}' is not configured for join in '${ParentSchema['source_name']}'.`
+  : AnyJoinCriteria<JoinedSchema>;
 
 /**
  * Determines the expected shape of the join parameters object passed to the `.join()` method,
- * based on the `relation_type` defined in the `ParentSchema` for the `ActualJoinedAlias`.
- * If the `ActualJoinedAlias` is not a valid join alias, this type resolves to `never`.
+ * based on the `relation_type` defined in the `ParentSchema` for the matching join configuration.
+ * If no matching join configuration is found for the `ActualJoinedSourceName`, this type resolves to `never`.
  * For 'many_to_many' relations, it expects {@link PivotJoinInput}.
  * For other relations (one-to-one, one-to-many, many-to-one), it expects {@link SimpleJoinInput}.
  *
  * @template ParentSchema - The {@link CriteriaSchema} of the parent entity.
  * @template JoinedSchema - The {@link CriteriaSchema} of the entity to be joined.
- * @template MatchingConfigForActualAlias - The join configuration from `ParentSchema` that matches the alias of `JoinedSchema`.
+ * @template MatchingConfigForActualSourceName - The join configuration from `ParentSchema` that matches the `source_name` of `JoinedSchema`.
  *                                         Should be `never` if no match is found.
  */
 export type JoinParameterType<
@@ -87,22 +82,22 @@ export type JoinParameterType<
 
 /**
  * Extracts the specific join configuration object from the `ParentSchema`'s `joins` array
- * that matches the provided `JoinedSchemaSpecificAlias`.
+ * that matches the provided `JoinedSchemaSpecificSourceName`.
  * This utility type is crucial for inferring the `relation_type` and other
  * join-specific details defined in the parent schema.
  *
  * @template ParentSchema - The {@link CriteriaSchema} of the parent entity.
- * @template JoinedSchemaSpecificAlias - The specific alias of the joined entity,
+ * @template JoinedSchemaSpecificSourceName - The specific `source_name` of the joined entity,
  *                                       as defined in the `ParentSchema.joins` configuration.
  * @example
- * // Given UserSchema has a join defined as: { alias: 'posts', relation_type: 'one_to_many' }
- * // type UserPostsJoinConfig = SpecificMatchingJoinConfig<typeof UserSchema, 'posts'>;
- * // UserPostsJoinConfig would be: { alias: 'posts'; relation_type: 'one_to_many'; }
+ * // Given UserSchema has a join defined as: { alias: 'posts', target_source_name: 'posts_table', relation_type: 'one_to_many' }
+ * // type UserPostsJoinConfig = SpecificMatchingJoinConfig<typeof UserSchema, 'posts_table'>;
+ * // UserPostsJoinConfig would be: { alias: 'posts'; target_source_name: 'posts_table'; relation_type: 'one_to_many'; }
  */
 export type SpecificMatchingJoinConfig<
   ParentSchema extends CriteriaSchema,
-  JoinedSchemaSpecificAlias extends string,
+  JoinedSchemaSpecificSourceName extends string,
 > = Extract<
   ParentSchema['joins'][number],
-  { alias: JoinedSchemaSpecificAlias }
+  { target_source_name: JoinedSchemaSpecificSourceName }
 >;
diff --git a/src/criteria/types/manager.interface.ts b/src/criteria/types/manager.interface.ts
index d0c8688..bd6ee27 100644
--- a/src/criteria/types/manager.interface.ts
+++ b/src/criteria/types/manager.interface.ts
@@ -3,7 +3,6 @@ import type {
   CriteriaSchema,
   FieldOfSchema,
   JoinRelationType,
-  SelectedAliasOf,
 } from './schema.types.js';
 
 import type { FilterPrimitive } from '../filter/types/filter-primitive.types.js';
@@ -64,13 +63,13 @@ export interface IJoinManager<CSchema extends CriteriaSchema> {
   /**
    * Adds a join configuration to the Criteria.
    * @template JoinSchema - The {@link CriteriaSchema} of the entity being joined.
-   * @param {AnyJoinCriteria<JoinSchema, SelectedAliasOf<JoinSchema>>} criteriaToJoin -
+   * @param {AnyJoinCriteria<JoinSchema>} criteriaToJoin -
    *   The criteria instance representing the entity to join (e.g., InnerJoinCriteria, LeftJoinCriteria).
    * @param {PivotJoin<CSchema, JoinSchema, JoinRelationType> | SimpleJoin<CSchema, JoinSchema, JoinRelationType>} joinParameter -
    *   The fully resolved parameters defining how the join should be performed.
    */
   addJoin<JoinSchema extends CriteriaSchema>(
-    criteriaToJoin: AnyJoinCriteria<JoinSchema, SelectedAliasOf<JoinSchema>>,
+    criteriaToJoin: AnyJoinCriteria<JoinSchema>,
     joinParameter:
       | PivotJoin<CSchema, JoinSchema, JoinRelationType>
       | SimpleJoin<CSchema, JoinSchema, JoinRelationType>,
diff --git a/src/criteria/types/schema.types.ts b/src/criteria/types/schema.types.ts
index fb339f4..8852114 100644
--- a/src/criteria/types/schema.types.ts
+++ b/src/criteria/types/schema.types.ts
@@ -13,13 +13,15 @@ export type JoinRelationType =
 
 /**
  * Describes the configuration for a joinable relation within a {@link CriteriaSchema}.
- * @template ValidAlias - A string literal type representing a valid alias for the join.
+ * @template ValidAlias - A string literal type representing the alias to be used for the joined entity in the query.
  */
 export type SchemaJoins<ValidAlias extends string> = {
-  /** The alias used to refer to this join in criteria construction. */
+  /** The alias to be used for the joined entity in the final query (e.g., 'p' for posts). */
   alias: ValidAlias;
   /** The type of relationship this join represents (e.g., 'one_to_many'). */
   relation_type: JoinRelationType;
+  /** The `source_name` of the schema that this relation targets. Used for robust validation. */
+  target_source_name: string;
   /**
    * Optional metadata associated with this specific join configuration.
    * This allows for storing arbitrary, translator-specific information
@@ -32,23 +34,23 @@ export type SchemaJoins<ValidAlias extends string> = {
 
 /**
  * Represents the schema definition for an entity, used by the Criteria system.
- * It defines the entity's source name (e.g., table name), available aliases,
+ * It defines the entity's source name (e.g., table name), a single canonical alias,
  * fields, and joinable relations.
  * @template TFields - A readonly array of string literal types representing the entity's field names.
- * @template TAliases - A readonly array of string literal types representing the entity's valid aliases.
+ * @template TAliase - A string literal type for the entity's canonical alias.
  * @template TSourceName - A string literal type for the entity's source name.
  * @template JoinsAlias - A string literal type representing valid aliases for its joinable relations.
  */
 export type CriteriaSchema<
   TFields extends ReadonlyArray<string> = ReadonlyArray<string>,
-  TAliases extends ReadonlyArray<string> = ReadonlyArray<string>,
+  TAliase extends string = string,
   TSourceName extends string = string,
   JoinsAlias extends string = string,
 > = {
   /** The source name of the entity (e.g., database table name). */
   source_name: TSourceName;
-  /** An array of valid aliases that can be used to refer to this entity. */
-  alias: TAliases;
+  /** The canonical alias used to refer to this entity in queries. */
+  alias: TAliase;
   /** An array of field names available for this entity. */
   fields: TFields;
   /** An array of configurations for entities that can be joined from this entity. */
@@ -80,10 +82,10 @@ export type CriteriaSchema<
  * @example
  * export const UserSchema = GetTypedCriteriaSchema({
  *   source_name: 'users_table',
- *   alias: ['user', 'u'],
+ *   alias: 'u', // Single alias
  *   fields: ['id', 'name', 'email'],
  *   identifier_field: 'id', // Must be one of 'id', 'name', or 'email'
- *   joins: [{ alias: 'posts', relation_type: 'one_to_many' }]
+ *   joins: [{ alias: 'posts', target_source_name: 'posts_table', relation_type: 'one_to_many' }]
  * });
  */
 export function GetTypedCriteriaSchema<const TInput extends CriteriaSchema>(
@@ -99,11 +101,3 @@ export function GetTypedCriteriaSchema<const TInput extends CriteriaSchema>(
  */
 export type FieldOfSchema<T extends CriteriaSchema> =
   T['fields'] extends ReadonlyArray<string> ? T['fields'][number] : never;
-
-/**
- * Extracts a union type of all valid aliases from a given {@link CriteriaSchema}.
- * @template T - The {@link CriteriaSchema} from which to extract aliases.
- * @example type UserAliases = SelectedAliasOf<typeof UserSchema>; // "user" | "u"
- */
-export type SelectedAliasOf<T extends CriteriaSchema> =
-  T['alias'] extends ReadonlyArray<string> ? T['alias'][number] : never;
diff --git a/src/criteria/types/visitor-interface.types.ts b/src/criteria/types/visitor-interface.types.ts
index f9407ab..fad6c80 100644
--- a/src/criteria/types/visitor-interface.types.ts
+++ b/src/criteria/types/visitor-interface.types.ts
@@ -4,82 +4,93 @@ import type { LeftJoinCriteria } from '../join/left.join-criteria.js';
 import type { OuterJoinCriteria } from '../join/outer.join-criteria.js';
 import type { Filter } from '../filter/filter.js';
 import type { FilterGroup } from '../filter/filter-group.js';
-import type {
-  CriteriaSchema,
-  JoinRelationType,
-  SelectedAliasOf,
-} from './schema.types.js';
+import type { CriteriaSchema, JoinRelationType } from './schema.types.js';
 import type { PivotJoin, SimpleJoin } from './join-parameter.types.js';
 import type { FilterOperator } from './operator.types.js';
 
 /**
- * Visitor interface for traversing Criteria objects.
- * @template TranslationContext - The type of the context object passed during traversal.
- * @template TranslationOutput - The type of the result returned by visitor methods.
+ * Defines the contract for a visitor that traverses a Criteria object graph.
+ * @template TranslationContext The mutable context object (e.g., a query builder) passed through the traversal.
+ * @template TFilterVisitorOutput The specific type returned by `visitFilter`, typically an intermediate representation of a condition.
  */
 export interface ICriteriaVisitor<
   TranslationContext,
-  TranslationOutput = TranslationContext,
-  TFilterVisitorOutput extends any = any,
+  TFilterVisitorOutput = any,
 > {
-  visitRoot<
-    RootCSchema extends CriteriaSchema,
-    RootAlias extends SelectedAliasOf<RootCSchema>,
-  >(
-    criteria: RootCriteria<RootCSchema, RootAlias>,
+  /**
+   * Visits the root node of the Criteria tree.
+   */
+  visitRoot<RootCSchema extends CriteriaSchema>(
+    criteria: RootCriteria<RootCSchema>,
     context: TranslationContext,
-  ): TranslationOutput;
+  ): void;
 
+  /**
+   * Visits an Inner Join node.
+   */
   visitInnerJoin<
     ParentCSchema extends CriteriaSchema,
     JoinCSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCSchema>,
   >(
-    criteria: InnerJoinCriteria<JoinCSchema, JoinAlias>,
+    criteria: InnerJoinCriteria<JoinCSchema>,
     parameters:
       | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
       | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
     context: TranslationContext,
-  ): TranslationOutput;
+  ): void;
 
+  /**
+   * Visits a Left Join node.
+   */
   visitLeftJoin<
     ParentCSchema extends CriteriaSchema,
     JoinCSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCSchema>,
   >(
-    criteria: LeftJoinCriteria<JoinCSchema, JoinAlias>,
+    criteria: LeftJoinCriteria<JoinCSchema>,
     parameters:
       | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
       | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
     context: TranslationContext,
-  ): TranslationOutput;
+  ): void;
 
+  /**
+   * Visits an Outer Join node.
+   */
   visitOuterJoin<
     ParentCSchema extends CriteriaSchema,
     JoinCSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCSchema>,
   >(
-    criteria: OuterJoinCriteria<JoinCSchema, JoinAlias>,
+    criteria: OuterJoinCriteria<JoinCSchema>,
     parameters:
       | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
       | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
     context: TranslationContext,
-  ): TranslationOutput;
+  ): void;
 
+  /**
+   * Visits a single Filter node and returns an intermediate representation.
+   */
   visitFilter<FieldType extends string>(
     filter: Filter<FieldType, FilterOperator>,
     currentAlias: string,
+    context: TranslationContext,
   ): TFilterVisitorOutput;
 
+  /**
+   * Visits a group of filters joined by a logical AND.
+   */
   visitAndGroup<FieldType extends string>(
     group: FilterGroup<FieldType>,
     currentAlias: string,
     context: TranslationContext,
-  ): TranslationOutput;
+  ): void;
 
+  /**
+   * Visits a group of filters joined by a logical OR.
+   */
   visitOrGroup<FieldType extends string>(
     group: FilterGroup<FieldType>,
     currentAlias: string,
     context: TranslationContext,
-  ): TranslationOutput;
+  ): void;
 }
diff --git a/src/docs/api-reference/en.md b/src/docs/api-reference/en.md
index 396df9a..27e6131 100644
--- a/src/docs/api-reference/en.md
+++ b/src/docs/api-reference/en.md
@@ -25,7 +25,6 @@ This section provides a detailed reference for the public classes, interfaces, t
   - [`CriteriaSchema`](#criteriaschema)
   - [`GetTypedCriteriaSchema`](#gettypedcriteriaschema)
   - [`FieldOfSchema`](#fieldofschema)
-  - [`SelectedAliasOf`](#selectedaliasof)
   - [`JoinRelationType`](#joinrelationtype)
   - [`SchemaJoins`](#schemajoins)
   - [`FilterPrimitive`](#filterprimitive)
@@ -51,47 +50,47 @@ This section provides a detailed reference for the public classes, interfaces, t
 
 ### `CriteriaFactory`
 
-Provides static methods for creating instances of different types of `Criteria`. It simplifies the creation of `Criteria` objects and ensures they are instantiated with the correct schema and alias configuration.
+Provides static methods for creating instances of different types of `Criteria`. It simplifies the creation of `Criteria` objects and ensures they are instantiated with the correct schema. The alias is now inferred directly from the schema.
 
 **Static Methods:**
 
-- **`GetCriteria<CSchema extends CriteriaSchema, Alias extends SelectedAliasOf<CSchema>>(schema: CSchema, alias: Alias): RootCriteria<CSchema, Alias>`**
+- **`GetCriteria<CSchema extends CriteriaSchema>(schema: CSchema): RootCriteria<CSchema>`**
+
   - Creates an instance of `RootCriteria`. This is the starting point for building a main query.
   - **Parameters:**
     - `schema`: An instance of `CriteriaSchema` that defines the structure of the root entity.
-    - `alias`: A valid alias (string) for the root entity, defined within the `schema`.
   - **Returns:** An instance of `RootCriteria`.
   - **Example:**
 
 ```typescript
 import { CriteriaFactory, UserSchema } from '@nulledexp/translatable-criteria';
-const userCriteria = CriteriaFactory.GetCriteria(UserSchema, 'users');
+const userCriteria = CriteriaFactory.GetCriteria(UserSchema);
 ```
 
-- **`GetInnerJoinCriteria<CSchema extends CriteriaSchema, Alias extends SelectedAliasOf<CSchema>>(schema: CSchema, alias: Alias): InnerJoinCriteria<CSchema, Alias>`**
+- **`GetInnerJoinCriteria<CSchema extends CriteriaSchema>(schema: CSchema): InnerJoinCriteria<CSchema>`**
+
   - Creates an instance of `InnerJoinCriteria`. Used to define an `INNER JOIN` in a query.
   - **Parameters:**
     - `schema`: An instance of `CriteriaSchema` for the entity to be joined.
-    - `alias`: A valid alias for the joined entity, defined in its `schema`.
   - **Returns:** An instance of `InnerJoinCriteria`.
   - **Example:**
 
 ```typescript
 import { CriteriaFactory, PostSchema } from '@nulledexp/translatable-criteria';
-const postJoin = CriteriaFactory.GetInnerJoinCriteria(PostSchema, 'posts');
-// userCriteria.join(postJoin, { parent_field: 'id', join_field: 'user_id' });
+const postJoin = CriteriaFactory.GetInnerJoinCriteria(PostSchema);
+// userCriteria.join('posts', postJoin, { parent_field: 'id', join_field: 'userId' });
 ```
 
-- **`GetLeftJoinCriteria<CSchema extends CriteriaSchema, Alias extends SelectedAliasOf<CSchema>>(schema: CSchema, alias: Alias): LeftJoinCriteria<CSchema, Alias>`**
+- **`GetLeftJoinCriteria<CSchema extends CriteriaSchema>(schema: CSchema): LeftJoinCriteria<CSchema>`**
 
   - Creates an instance of `LeftJoinCriteria`. Used to define a `LEFT JOIN`.
   - **Returns:** An instance of `LeftJoinCriteria`.
 
-- **`GetOuterJoinCriteria<CSchema extends CriteriaSchema, Alias extends SelectedAliasOf<CSchema>>(schema: CSchema, alias: Alias): OuterJoinCriteria<CSchema, Alias>`**
+- **`GetOuterJoinCriteria<CSchema extends CriteriaSchema>(schema: CSchema): OuterJoinCriteria<CSchema>`**
   - Creates an instance of `OuterJoinCriteria`. Used to define a `FULL OUTER JOIN`.
   - **Returns:** An instance of `OuterJoinCriteria`.
 
-Back to Index
+[Back to Index](#index)
 
 ### `RootCriteria`
 
@@ -101,9 +100,9 @@ Instantiated via `CriteriaFactory.GetCriteria()`.
 **Main Methods (in addition to those inherited from `Criteria`):**
 
 - Implements `accept` for the Visitor pattern, calling `visitor.visitRoot()`.
-- `resetCriteria()`: Returns a new instance of `RootCriteria` with the same schema and alias configuration, but with all other states (filters, joins, etc.) reset.
+- `resetCriteria()`: Returns a new instance of `RootCriteria` with the same schema configuration, but with all other states (filters, joins, etc.) reset.
 
-Back to Index
+[Back to Index](#index)
 
 ### `InnerJoinCriteria`
 
@@ -115,7 +114,7 @@ Instantiated via `CriteriaFactory.GetInnerJoinCriteria()`.
 - Implements `accept` for the Visitor pattern, calling `visitor.visitInnerJoin()`.
 - `resetCriteria()`: Returns a new instance of `InnerJoinCriteria`.
 
-Back to Index
+[Back to Index](#index)
 
 ### `LeftJoinCriteria`
 
@@ -127,7 +126,7 @@ Instantiated via `CriteriaFactory.GetLeftJoinCriteria()`.
 - Implements `accept` for the Visitor pattern, calling `visitor.visitLeftJoin()`.
 - `resetCriteria()`: Returns a new instance of `LeftJoinCriteria`.
 
-Back to Index
+[Back to Index](#index)
 
 ### `OuterJoinCriteria`
 
@@ -139,7 +138,7 @@ Instantiated via `CriteriaFactory.GetOuterJoinCriteria()`.
 - Implements `accept` for the Visitor pattern, calling `visitor.visitOuterJoin()`.
 - `resetCriteria()`: Returns a new instance of `OuterJoinCriteria`.
 
-Back to Index
+[Back to Index](#index)
 
 ### `Criteria` (Abstract Base Class)
 
@@ -155,8 +154,10 @@ Abstract base class for all criteria types (`RootCriteria`, `InnerJoinCriteria`,
 - `joins: ReadonlyArray<StoredJoinDetails<TSchema>>`: Join configurations.
 - `rootFilterGroup: FilterGroup`: Root filter group.
 - `sourceName: TSchema['source_name']`: Source name from the schema.
-- `alias: CurrentAlias`: Current alias of the criteria.
+- `alias: TSchema['alias']`: The canonical alias from the schema.
 - `cursor: Cursor<...> | undefined`: Cursor configuration for pagination.
+- `identifierField: FieldOfSchema<TSchema>`: The name of the identifier field from the schema.
+- `schemaMetadata: TSchema['metadata']`: The metadata object from the schema.
 
 **Main Methods (chainable):**
 
@@ -168,10 +169,10 @@ Abstract base class for all criteria types (`RootCriteria`, `InnerJoinCriteria`,
 - **`where<Operator extends FilterOperator>(filterPrimitive: FilterPrimitive<...>): this`**: Initializes the filter group with a condition.
 - **`andWhere<Operator extends FilterOperator>(filterPrimitive: FilterPrimitive<...>): this`**: Adds an AND condition to the current filter group.
 - **`orWhere<Operator extends FilterOperator>(filterPrimitive: FilterPrimitive<...>): this`**: Adds an OR condition, creating a new group if necessary.
-- **`join<...>(criteriaToJoin: ..., joinParameter: ...): this`**: Adds a join condition.
+- **`join(joinAlias: string, criteriaToJoin: JoinCriteria, joinParameter: object): this`**: Adds a join condition.
 - **`setCursor(cursorFilters: [...], operator: ..., order: ...): this`**: Configures cursor-based pagination.
 
-Back to Index
+[Back to Index](#index)
 
 ### `Filter`
 
@@ -190,19 +191,14 @@ Represents an individual filter condition. Instantiated internally when using th
 
 **Methods:**
 
-- `accept(visitor: ICriteriaVisitor<...>, currentAlias: string): TFilterVisitorOutput`: For the Visitor pattern, calls `visitor.visitFilter()`.
+- `accept(visitor: ICriteriaVisitor<...>, currentAlias: string, context: ...): TFilterVisitorOutput`: For the Visitor pattern, calls `visitor.visitFilter()`.
 - `toPrimitive(): FilterPrimitive<T, Operator>`: Returns the primitive representation of the filter.
 
-Back to Index
+[Back to Index](#index)
 
 ### `FilterGroup`
 
-Represents a group of filters (`Filter` or nested `FilterGroup`) connected by a `LogicalOperator` (AND/OR). Instantiated and managed internally by `CriteriaFilterManager` when using `where`, `andWhere`, `orWhere` methods.
-
-**Constructor:**
-
-- `constructor(filterGroupPrimitive: FilterGroupPrimitive<T>)`
-  - Normalizes the primitive filter group (e.g., flattening nested AND groups).
+Represents a group of filters (`Filter` or nested `FilterGroup`) connected by a `LogicalOperator` (AND/OR). Instantiated and managed internally by `CriteriaFilterManager`.
 
 **Properties (getters):**
 
@@ -211,20 +207,15 @@ Represents a group of filters (`Filter` or nested `FilterGroup`) connected by a
 
 **Methods:**
 
-- `accept(visitor: ICriteriaVisitor<...>, currentAlias: string, context: ...): TranslationOutput`: For the Visitor pattern, calls `visitor.visitAndGroup()` or `visitor.visitOrGroup()` based on the `logicalOperator`.
+- `accept(visitor: ICriteriaVisitor<...>, currentAlias: string, context: ...): void`: For the Visitor pattern, calls `visitor.visitAndGroup()` or `visitor.visitOrGroup()` based on the `logicalOperator`.
 - `toPrimitive(): FilterGroupPrimitive<T>`: Returns the primitive representation of the filter group.
 
-Back to Index
+[Back to Index](#index)
 
 ### `Order`
 
 Represents an ordering rule. Instantiated internally when using the `orderBy()` method of a `Criteria`.
 
-**Constructor:**
-
-- `constructor(direction: OrderDirection, field: T)`
-  - Assigns a globally unique `sequenceId` to maintain a stable order.
-
 **Properties (getters):**
 
 - `sequenceId: number`: Sequence ID for stable ordering.
@@ -235,29 +226,19 @@ Represents an ordering rule. Instantiated internally when using the `orderBy()`
 
 - `toPrimitive(): OrderByPrimitive<T>`: Returns the primitive representation of the order rule.
 
-Back to Index
+[Back to Index](#index)
 
 ### `Cursor`
 
 Represents the configuration for cursor-based pagination. Instantiated internally when using the `setCursor()` method of a `Criteria`.
 
-**Constructor:**
-
-- `constructor(filterPrimitive: readonly [Omit<FilterPrimitive<...>, 'operator'>] | readonly [Omit<FilterPrimitive<...>, 'operator'>, Omit<FilterPrimitive<...>, 'operator'>], operator: FilterOperator.GREATER_THAN | FilterOperator.LESS_THAN, order: OrderDirection)`
-  - Validates that cursor fields and values are defined and valid.
-  - Supports 1 or 2 `FilterPrimitive`s for simple or composite cursors.
-  - @throws {Error} If any cursor field is not defined.
-  - @throws {Error} If any cursor value is undefined (null is allowed).
-  - @throws {Error} If two cursor fields are provided and they are identical.
-  - @throws {Error} If no filter primitives are provided.
-
 **Properties (readonly):**
 
-- `filters: [Filter<TFields, Operator>] | [Filter<TFields, Operator>, Filter<TFields, Operator>]`: The filters defining the cursor.
+- `filters: [Filter<...>] | [Filter<...>, Filter<...>]`: The filters defining the cursor.
 - `order: OrderDirection`: The ordering direction of the cursor.
 - `operator: FilterOperator.GREATER_THAN | FilterOperator.LESS_THAN`: The cursor operator.
 
-Back to Index
+[Back to Index](#index)
 
 ---
 
@@ -269,32 +250,22 @@ Abstract class that serves as the base for creating specific translators for dif
 
 - **Generics:**
 
-  - `TranslationContext`: The type of the context object that is passed and modified during translation (e.g., a TypeORM `SelectQueryBuilder`).
+  - `TranslationContext`: The type of the mutable context object (e.g., a query builder) passed through the traversal.
   - `TranslationOutput` (optional, defaults to `TranslationContext`): The type of the final translation result.
-  - `TFilterVisitorOutput` (optional, defaults to `any`): The specific output type for the `visitFilter`, `visitAndGroup`, and `visitOrGroup` methods.
-
-- **Main Method (for the translator user):**
-
-  - **`translate(criteria: RootCriteria<...>, source: TranslationContext): TranslationOutput`**
-    - Main public method to start the translation process.
-    - **Parameters:**
-      - `criteria`: The `RootCriteria` instance to translate.
-      - `source`: The initial context for the translation (e.g., a `SelectQueryBuilder` instance).
-    - **Returns:** The `TranslationOutput` (e.g., the modified `SelectQueryBuilder` or an SQL string).
+  - `TFilterVisitorOutput` (optional, defaults to `any`): The specific output type for the `visitFilter` method.
 
 - **Abstract Methods (to be implemented by child classes):**
 
-  - `visitRoot(...)`
-  - `visitInnerJoin(...)`
-  - `visitLeftJoin(...)`
-  - `visitOuterJoin(...)`
-  - `visitFilter(...)`
-  - `visitAndGroup(...)`
-  - `visitOrGroup(...)`
-
-  These methods receive the specific `Criteria` component (e.g., `RootCriteria`, `Filter`), the current alias or join parameters, and the `TranslationContext`. They should return the `TranslationOutput` or `TFilterVisitorOutput` as appropriate.
+  - **`translate(criteria: RootCriteria<...>, source: TranslationContext): TranslationOutput`**: The main public entry point to start the translation process.
+  - `visitRoot(...): void`: Visits the root node of the Criteria tree to initialize the translation.
+  - `visitInnerJoin(...): void`: Visits an Inner Join node to apply its logic.
+  - `visitLeftJoin(...): void`: Visits a Left Join node to apply its logic.
+  - `visitOuterJoin(...): void`: Visits an Outer Join node to apply its logic.
+  - `visitFilter(...): TFilterVisitorOutput`: Visits a single Filter node and returns an intermediate representation of the condition.
+  - `visitAndGroup(...): void`: Visits a group of filters joined by a logical AND.
+  - `visitOrGroup(...): void`: Visits a group of filters joined by a logical OR.
 
-Back to Index
+[Back to Index](#index)
 
 ---
 
@@ -317,27 +288,27 @@ Enumeration defining the available comparison operators for filters.
   - `NOT_IN` (`NOT IN`): The value is not within a set of values.
   - `IS_NULL` (`IS NULL`): The value is NULL.
   - `IS_NOT_NULL` (`IS NOT NULL`): The value is not NULL.
-  - `CONTAINS` (`CONTAINS`): For substring search (often case-insensitive, depends on the DB).
+  - `CONTAINS` (`CONTAINS`): For substring search.
   - `STARTS_WITH` (`STARTS_WITH`): Starts with a specific substring.
   - `ENDS_WITH` (`ENDS_WITH`): Ends with a specific substring.
   - `NOT_CONTAINS` (`NOT_CONTAINS`): Does not contain a specific substring.
   - `SET_CONTAINS`: For SET-type fields or simple arrays, checks if the set contains a value.
-  - `SET_NOT_CONTAINS`: For SET-type fields or simple arrays, checks if the set does NOT contain a value.
-  - `SET_CONTAINS_ANY` (`SET_CONTAINS_ANY`): For SET-type fields or simple arrays, checks if the set contains AT LEAST ONE of the specified values. Expects an array of values.
-  - `SET_CONTAINS_ALL` (`SET_CONTAINS_ALL`): For SET-type fields or simple arrays, checks if the set contains ALL of the specified values. Expects an array of values.
-  - `BETWEEN` (`BETWEEN`): Checks if a value is within a specified range (inclusive). Expects an array or tuple of two values: `[min, max]`.
-  - `NOT_BETWEEN` (`NOT_BETWEEN`): Checks if a value is outside a specified range (inclusive). Expects an array or tuple of two values: `[min, max]`.
-  - `MATCHES_REGEX` (`MATCHES_REGEX`): Checks if a string value matches a regular expression pattern. The specific regex syntax may depend on the database. Expects a string representing the regular expression.
-  - `ILIKE` (`ILIKE`): Checks if a string value matches a pattern (case-insensitive). Expects a string for the pattern.
-  - `NOT_ILIKE` (`NOT_ILIKE`): Checks if a string value does not match a pattern (case-insensitive). Expects a string for the pattern.
-  - `JSON_CONTAINS`: For JSON fields, checks if the JSON contains a specific structure or value at a path.
-  - `JSON_NOT_CONTAINS`: For JSON fields, checks if the JSON does NOT contain a specific structure or value.
-  - `ARRAY_CONTAINS_ELEMENT`: For Array fields (native or JSON), checks if the array contains an element.
-  - `ARRAY_CONTAINS_ALL_ELEMENTS`: For Array fields, checks if the array contains all elements from a given array.
-  - `ARRAY_CONTAINS_ANY_ELEMENT`: For Array fields, checks if the array contains any of the elements from a given array.
-  - `ARRAY_EQUALS`: For Array fields, checks if the array is exactly equal to a given array (order and elements).
-
-Back to Index
+  - `SET_NOT_CONTAINS`: The inverse of `SET_CONTAINS`.
+  - `SET_CONTAINS_ANY`: Checks if the set contains AT LEAST ONE of the specified values.
+  - `SET_CONTAINS_ALL`: Checks if the set contains ALL of the specified values.
+  - `BETWEEN` (`BETWEEN`): Checks if a value is within a specified range (inclusive).
+  - `NOT_BETWEEN` (`NOT_BETWEEN`): Checks if a value is outside a specified range.
+  - `MATCHES_REGEX` (`MATCHES_REGEX`): Checks if a string value matches a regular expression.
+  - `ILIKE` (`ILIKE`): Case-insensitive version of `LIKE`.
+  - `NOT_ILIKE` (`NOT_ILIKE`): Case-insensitive version of `NOT_ILIKE`.
+  - `JSON_CONTAINS`: For JSON fields, checks if the JSON contains a specific structure or value.
+  - `JSON_NOT_CONTAINS`: The inverse of `JSON_CONTAINS`.
+  - `ARRAY_CONTAINS_ELEMENT`: For Array fields, checks if the array contains an element.
+  - `ARRAY_CONTAINS_ALL_ELEMENTS`: Checks if the array contains all elements from a given array.
+  - `ARRAY_CONTAINS_ANY_ELEMENT`: Checks if the array contains any of the elements from a given array.
+  - `ARRAY_EQUALS`: Checks if the array is exactly equal to a given array.
+
+[Back to Index](#index)
 
 ### `LogicalOperator`
 
@@ -347,7 +318,7 @@ Enumeration defining the logical operators for combining filter groups.
   - `AND` (`AND`): All conditions must be met.
   - `OR` (`OR`): At least one condition must be met.
 
-Back to Index
+[Back to Index](#index)
 
 ### `OrderDirection`
 
@@ -357,7 +328,7 @@ Enumeration defining the direction of ordering.
   - `ASC` (`ASC`): Ascending order.
   - `DESC` (`DESC`): Descending order.
 
-Back to Index
+[Back to Index](#index)
 
 ---
 
@@ -369,40 +340,40 @@ Interface defining the structure of an entity schema. Schemas are crucial for ty
 
 - **Properties:**
   - `source_name: string`: The actual name of the table or collection in the database.
-  - `alias: readonly string[]`: An array of possible aliases for this entity. The first is usually the primary one.
+  - `alias: string`: A single, canonical alias for this entity.
   - `fields: readonly string[]`: An array of the names of queryable fields for this entity.
+  - `identifier_field: string`: **(Mandatory)** The name of the field that uniquely identifies an entity of this schema. Must be one of the names in `fields`.
   - `joins: readonly SchemaJoins<string>[]` (optional): An array defining possible join relationships with other schemas.
-    - `SchemaJoins<AliasUnion extends string>`:
-      - `alias: AliasUnion`: The alias of the joined entity (must match an alias in the joined entity's schema).
-      - `relation_type: JoinRelationType`: The type of relationship (e.g., `'one_to_many'`).
-      - `metadata?: { [key: string]: any }`: Optional metadata associated with the specific join configuration.
-  - `metadata?: { [key: string]: any }`: Optional metadata associated with the entire schema definition. Can be used by translators for custom logic or hints.
+  - `metadata?: { [key: string]: any }`: Optional metadata associated with the entire schema definition.
 
-Back to Index
+[Back to Index](#index)
 
 ### `GetTypedCriteriaSchema`
 
 Helper function for defining schemas. It preserves the literal types of `fields` and `alias`, improving autocompletion and type validation.
 
-- **Function:** `GetTypedCriteriaSchema<T extends MinimalCriteriaSchema>(schema: T): T`
-  - **Parameters:**
-    - `schema`: An object conforming to the `MinimalCriteriaSchema` structure (a looser version of `CriteriaSchema` for input).
-  - **Returns:** The same input `schema` object, but with its literal types preserved.
-  - **Example:**
+- **Function:** `GetTypedCriteriaSchema<T extends CriteriaSchema>(schema: T): T`
+- **Example:**
 
 ```typescript
 import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
 
-const MyUserSchema = GetTypedCriteriaSchema({
-  source_name: 'user_table',
-  alias: ['user', 'u'],
+export const UserSchema = GetTypedCriteriaSchema({
+  source_name: 'users',
+  alias: 'u',
   fields: ['id', 'name', 'email'],
-  joins: [{ alias: 'orders', relation_type: 'one_to_many' }],
+  identifier_field: 'id',
+  joins: [
+    {
+      alias: 'posts',
+      target_source_name: 'posts',
+      relation_type: 'one_to_many',
+    },
+  ],
 });
-// MyUserSchema now has literal types for alias and fields.
 ```
 
-Back to Index
+[Back to Index](#index)
 
 ### `FieldOfSchema`
 
@@ -410,15 +381,7 @@ Helper type that extracts the valid field names from a given `CriteriaSchema`.
 
 - **Type:** `FieldOfSchema<T extends CriteriaSchema> = T['fields'][number];`
 
-Back to Index
-
-### `SelectedAliasOf`
-
-Helper type that extracts the valid aliases from a given `CriteriaSchema`.
-
-- **Type:** `SelectedAliasOf<T extends CriteriaSchema> = T['alias'][number];`
-
-Back to Index
+[Back to Index](#index)
 
 ### `JoinRelationType`
 
@@ -426,225 +389,173 @@ String union type representing the possible types of join relationships.
 
 - **Possible Values:** `'one_to_one' | 'one_to_many' | 'many_to_one' | 'many_to_many'`
 
-Back to Index
+[Back to Index](#index)
 
 ### `SchemaJoins`
 
 Interface defining the structure of a join configuration within the `joins` property of a `CriteriaSchema`.
 
 - **Properties:**
-  - `alias: AliasUnion`: The alias of the entity being joined to.
+  - `alias: string`: The alias for this specific join relation (e.g., `'posts'`, `'author'`).
   - `relation_type: JoinRelationType`: The type of relationship.
+  - `target_source_name: string`: The `source_name` of the schema being joined to.
   - `metadata?: { [key: string]: any }`: Optional metadata associated with this specific join configuration.
 
-Back to Index
+[Back to Index](#index)
 
 ### `FilterPrimitive`
 
 Interface defining the structure for an individual filter condition before it's instantiated as a `Filter` object.
 
-- **Generics:**
-  - `Field extends FieldOfSchema<CriteriaSchema>`: The type of valid fields.
-  - `Operator extends FilterOperator`: The specific filter operator.
 - **Properties:**
-  - `field: Field`: The field to apply the filter to.
-  - `operator: Operator`: The filter operator.
+  - `field: FieldOfSchema<...>`: The field to apply the filter to.
+  - `operator: FilterOperator`: The filter operator.
   - `value: FilterValue<Operator>`: The filter value, whose type depends on the `Operator`.
 
-Back to Index
+[Back to Index](#index)
 
 ### `FilterGroupPrimitive`
 
 Interface defining the structure for a group of filters before it's instantiated as a `FilterGroup` object.
 
-- **Generics:**
-  - `Field extends string`: The type of valid fields.
 - **Properties:**
   - `logicalOperator: LogicalOperator`: The logical operator (`AND` or `OR`) joining the `items`.
-  - `items: ReadonlyArray<FilterPrimitive<Field, FilterOperator> | FilterGroupPrimitive<Field>>`: Array of filters or nested filter groups.
+  - `items: ReadonlyArray<FilterPrimitive<...> | FilterGroupPrimitive<...>>`: Array of filters or nested filter groups.
 
-Back to Index
+[Back to Index](#index)
 
 ### `FilterValue`
 
 Generic type representing the value associated with a filter, strongly typed according to the `FilterOperator` used.
 
-- **Definition (conceptual):**
-  - If `Operator` is `LIKE`, `CONTAINS`, etc. => `string`
-  - If `Operator` is `EQUALS`, `GREATER_THAN`, etc. => `PrimitiveFilterValue` (string | number | boolean | Date | null)
-  - If `Operator` is `IN`, `NOT_IN` => `Array<Exclude<PrimitiveFilterValue, null | undefined>>`
-  - If `Operator` is `SET_CONTAINS_ANY`, `SET_CONTAINS_ALL` => `Array<Exclude<PrimitiveFilterValue, null | undefined>>`
-  - If `Operator` is `BETWEEN`, `NOT_BETWEEN` => `[Exclude<PrimitiveFilterValue, null | undefined>, Exclude<PrimitiveFilterValue, null | undefined>]`
-  - If `Operator` is `MATCHES_REGEX`, `ILIKE`, `NOT_ILIKE` => `string`
-  - If `Operator` is `ARRAY_CONTAINS_ELEMENT` => `PrimitiveFilterValue | { [jsonPath: string]: PrimitiveFilterValue }`
-  - If `Operator` is `ARRAY_CONTAINS_ALL_ELEMENTS`, etc. => `Array<...> | { [jsonPath: string]: Array<...> }`
-  - If `Operator` is `IS_NULL`, `IS_NOT_NULL` => `null | undefined`
-  - If `Operator` is `JSON_CONTAINS`, etc. => `{ [jsonPath: string]: PrimitiveFilterValue | Array<any> | Record<string, any> }`
-
-Back to Index
+[Back to Index](#index)
 
 ### `OrderByPrimitive`
 
 Type defining the structure for an ordering rule before it's instantiated as an `Order` object.
 
-- **Generics:**
-  - `T extends string`: The type of valid fields.
 - **Properties:**
   - `direction: OrderDirection`: The ordering direction.
-  - `field: T`: The field to order by.
+  - `field: string`: The field to order by.
 
-Back to Index
+[Back to Index](#index)
 
 ### `PivotJoinInput`
 
 Type representing the input parameters for a `many-to-many` join via a pivot table, as provided by the user to the `.join()` method.
 
-- **Generics:**
-  - `ParentSchema extends CriteriaSchema`
-  - `JoinSchema extends CriteriaSchema`
 - **Properties:**
   - `pivot_source_name: string`: Name of the pivot table.
   - `parent_field: { pivot_field: string; reference: FieldOfSchema<ParentSchema> }`: Configuration of the parent entity's field referencing the pivot table.
   - `join_field: { pivot_field: string; reference: FieldOfSchema<JoinSchema> }`: Configuration of the joined entity's field referencing the pivot table.
 
-Back to Index
+[Back to Index](#index)
 
 ### `SimpleJoinInput`
 
 Type representing the input parameters for a simple join (one-to-one, one-to-many, many-to-one), as provided by the user to the `.join()` method.
 
-- **Generics:**
-  - `ParentSchema extends CriteriaSchema`
-  - `JoinSchema extends CriteriaSchema`
 - **Properties:**
   - `parent_field: FieldOfSchema<ParentSchema>`: Field in the parent entity for the join condition.
   - `join_field: FieldOfSchema<JoinSchema>`: Field in the joined entity for the join condition.
 
-Back to Index
+[Back to Index](#index)
 
 ### `ICriteriaBase`
 
 Base interface defining common functionality for all criteria types.
 
-- **Generics:**
-  - `TSchema extends CriteriaSchema`
-  - `CurrentAlias extends SelectedAliasOf<TSchema>`
-- **Main Methods (see `Criteria` for details):**
-  - `resetSelect()`
-  - `setSelect(...)`
-  - `setTake(...)`
-  - `setSkip(...)`
-  - `orderBy(...)`
-  - `where(...)`
-  - `andWhere(...)`
-  - `orWhere(...)`
-  - `join(...)`
-  - `setCursor(...)`
-- **Properties (getters):** `select`, `selectAll`, `take`, `skip`, `orders`, `joins`, `rootFilterGroup`, `sourceName`, `alias`, `cursor`.
-
-Back to Index
+[Back to Index](#index)
 
 ### `ICriteriaVisitor`
 
 Interface for the Visitor pattern, implemented by `CriteriaTranslator`. Defines the `visit...` methods for each type of `Criteria` node.
 
-- **Generics:**
-  - `TranslationContext`
-  - `TranslationOutput`
-  - `TFilterVisitorOutput`
-- **Methods (see `CriteriaTranslator` for details):**
-  - `visitRoot(...)`
-  - `visitInnerJoin(...)`
-  - `visitLeftJoin(...)`
-  - `visitOuterJoin(...)`
-  - `visitFilter(...)`
-  - `visitAndGroup(...)`
-  - `visitOrGroup(...)`
-
-Back to Index
+- **Methods (return `void` unless specified):**
+  - `visitRoot(...)`: Visits the root node of the Criteria tree to initialize the translation.
+  - `visitInnerJoin(...)`: Visits an Inner Join node to apply its logic.
+  - `visitLeftJoin(...)`: Visits a Left Join node to apply its logic.
+  - `visitOuterJoin(...)`: Visits an Outer Join node to apply its logic.
+  - `visitFilter(...): TFilterVisitorOutput`: Visits a single Filter node and returns an intermediate representation of the condition.
+  - `visitAndGroup(...)`: Visits a group of filters joined by a logical AND.
+  - `visitOrGroup(...)`: Visits a group of filters joined by a logical OR.
+
+[Back to Index](#index)
 
 ### `IFilterExpression`
 
 Interface implemented by `Filter` and `FilterGroup`.
 
 - **Methods:**
-  - `toPrimitive(): FilterPrimitive<...> | FilterGroupPrimitive<...>`: Returns the primitive representation of the filter expression.
+  - `toPrimitive()`: Returns the primitive representation of the filter expression.
 
-Back to Index
+[Back to Index](#index)
 
 ### `StoredJoinDetails`
 
 Interface defining the structure for storing the details of a configured join internally.
 
-- **Generics:**
-  - `ParentSchema extends CriteriaSchema`
 - **Properties:**
   - `parameters: PivotJoin<...> | SimpleJoin<...>`: The resolved join parameters.
   - `criteria: AnyJoinCriteria<...>`: The `Criteria` instance of the joined entity.
 
-Back to Index
+[Back to Index](#index)
 
 ### `AnyJoinCriteria`
 
 Union type representing any type of join `Criteria` (`InnerJoinCriteria`, `LeftJoinCriteria`, `OuterJoinCriteria`).
 
-Back to Index
+[Back to Index](#index)
 
 ### `JoinCriteriaParameterType`
 
-Helper type that determines the type of the `Criteria` object to be passed to the `.join()` method, validating that the joined entity's alias is configured in the parent schema.
+Helper type that determines the type of the `Criteria` object to be passed to the `.join()` method, validating that the joined entity's `source_name` is configured in the parent schema.
 
-Back to Index
+[Back to Index](#index)
 
 ### `JoinParameterType`
 
-Helper type that determines the expected shape of the join parameters object for the `.join()` method, based on the `join_relation_type` defined in the parent schema.
+Helper type that determines the expected shape of the join parameters object for the `.join()` method, based on the `relation_type` defined in the parent schema.
 
-Back to Index
+[Back to Index](#index)
 
 ### `SpecificMatchingJoinConfig`
 
-Helper type that extracts the specific join configuration from a parent schema that matches a given joined entity alias.
+Helper type that extracts the specific join configuration from a parent schema that matches a given `target_source_name`.
 
-Back to Index
+[Back to Index](#index)
 
 ### `PivotJoin`
 
 Type representing the fully resolved parameters for a `many-to-many` join via a pivot table, used internally.
 
-- **Generics:**
-  - `ParentSchema extends CriteriaSchema`
-  - `JoinSchema extends CriteriaSchema`
-  - `TRelationType extends JoinRelationType`
 - **Properties:**
-  - `relation_type: TRelationType`: The type of relationship from the parent to the joined entity.
-  - `parent_source_name: ParentSchema['source_name']`
-  - `parent_alias: ParentSchema['alias'][number]`
+  - `relation_type: 'many_to_many'`
+  - `parent_source_name: string`
+  - `parent_alias: string`
+  - `join_alias: string`
+  - `parent_identifier: string`
   - `pivot_source_name: string`
-  - `parent_field: { pivot_field: string; reference: FieldOfSchema<ParentSchema> }`
-  - `join_field: { pivot_field: string; reference: FieldOfSchema<JoinSchema> }`
-  - `parent_schema_metadata: { [key: string]: any }`: Optional metadata from the parent schema.
-  - `join_metadata: { [key: string]: any }`: Optional metadata from the specific join configuration.
+  - `parent_field: { pivot_field: string; reference: string }`
+  - `join_field: { pivot_field: string; reference: string }`
+  - `parent_schema_metadata: { [key: string]: any }`
+  - `join_metadata: { [key: string]: any }`
 
-Back to Index
+[Back to Index](#index)
 
 ### `SimpleJoin`
 
 Type representing the fully resolved parameters for a simple join (one-to-one, one-to-many, many-to-one), used internally.
 
-- **Generics:**
-  - `ParentSchema extends CriteriaSchema`
-  - `JoinSchema extends CriteriaSchema`
-  - `TRelationType extends JoinRelationType`
 - **Properties:**
-  - `relation_type: TRelationType`: The type of relationship from the parent to the joined entity.
-  - `parent_source_name: ParentSchema['source_name']`
-  - `parent_alias: ParentSchema['alias'][number]`
-  - `parent_field: FieldOfSchema<ParentSchema>`
-  - `join_field: FieldOfSchema<JoinSchema>`
-  - `parent_schema_metadata: { [key: string]: any }`: Optional metadata from the parent schema.
-  - `join_metadata: { [key: string]: any }`: Optional metadata from the specific join configuration.
-
-Back to Index
-
----
+  - `relation_type: 'one_to_one' | 'one_to_many' | 'many_to_one'`
+  - `parent_source_name: string`
+  - `parent_alias: string`
+  - `join_alias: string`
+  - `parent_identifier: string`
+  - `parent_field: string`
+  - `join_field: string`
+  - `parent_schema_metadata: { [key: string]: any }`
+  - `join_metadata: { [key: string]: any }`
+
+[Back to Index](#index)
diff --git a/src/docs/api-reference/es.md b/src/docs/api-reference/es.md
index 87cf6b5..1d17bac 100644
--- a/src/docs/api-reference/es.md
+++ b/src/docs/api-reference/es.md
@@ -25,7 +25,6 @@ Esta sección proporciona una referencia detallada de las clases, interfaces, ti
   - [`CriteriaSchema`](#criteriaschema)
   - [`GetTypedCriteriaSchema`](#gettypedcriteriaschema)
   - [`FieldOfSchema`](#fieldofschema)
-  - [`SelectedAliasOf`](#selectedaliasof)
   - [`JoinRelationType`](#joinrelationtype)
   - [`SchemaJoins`](#schemajoins)
   - [`FilterPrimitive`](#filterprimitive)
@@ -51,47 +50,45 @@ Esta sección proporciona una referencia detallada de las clases, interfaces, ti
 
 ### `CriteriaFactory`
 
-Proporciona métodos estáticos para crear instancias de diferentes tipos de `Criteria`. Simplifica la creación de objetos `Criteria` y asegura que se instancien con la configuración correcta de esquema y alias.
+Proporciona métodos estáticos para crear instancias de diferentes tipos de `Criteria`. Simplifica la creación de objetos `Criteria` y asegura que se instancien con el esquema correcto. El alias ahora se infiere directamente del esquema.
 
 **Métodos Estáticos:**
 
-- **`GetCriteria<CSchema extends CriteriaSchema, Alias extends SelectedAliasOf<CSchema>>(schema: CSchema, alias: Alias): RootCriteria<CSchema, Alias>`**
+- **`GetCriteria<CSchema extends CriteriaSchema>(schema: CSchema): RootCriteria<CSchema>`**
   - Crea una instancia de `RootCriteria`. Es el punto de partida para construir una consulta principal.
   - **Parámetros:**
     - `schema`: Una instancia de `CriteriaSchema` que define la estructura de la entidad raíz.
-    - `alias`: Un alias válido (string) para la entidad raíz, definido dentro del `schema`.
   - **Retorna:** Una instancia de `RootCriteria`.
   - **Ejemplo:**
 
 ```typescript
 import { CriteriaFactory, UserSchema } from '@nulledexp/translatable-criteria';
-const userCriteria = CriteriaFactory.GetCriteria(UserSchema, 'users');
+const userCriteria = CriteriaFactory.GetCriteria(UserSchema);
 ```
 
-- **`GetInnerJoinCriteria<CSchema extends CriteriaSchema, Alias extends SelectedAliasOf<CSchema>>(schema: CSchema, alias: Alias): InnerJoinCriteria<CSchema, Alias>`**
+- **`GetInnerJoinCriteria<CSchema extends CriteriaSchema>(schema: CSchema): InnerJoinCriteria<CSchema>`**
   - Crea una instancia de `InnerJoinCriteria`. Usado para definir un `INNER JOIN` en una consulta.
   - **Parámetros:**
     - `schema`: Una instancia de `CriteriaSchema` para la entidad a unir.
-    - `alias`: Un alias válido para la entidad unida, definido en su `schema`.
   - **Retorna:** Una instancia de `InnerJoinCriteria`.
   - **Ejemplo:**
 
 ```typescript
 import { CriteriaFactory, PostSchema } from '@nulledexp/translatable-criteria';
-const postJoin = CriteriaFactory.GetInnerJoinCriteria(PostSchema, 'posts');
-// userCriteria.join(postJoin, { parent_field: 'id', join_field: 'user_id' });
+const postJoin = CriteriaFactory.GetInnerJoinCriteria(PostSchema);
+// userCriteria.join('posts', postJoin, { parent_field: 'id', join_field: 'userId' });
 ```
 
-- **`GetLeftJoinCriteria<CSchema extends CriteriaSchema, Alias extends SelectedAliasOf<CSchema>>(schema: CSchema, alias: Alias): LeftJoinCriteria<CSchema, Alias>`**
+- **`GetLeftJoinCriteria<CSchema extends CriteriaSchema>(schema: CSchema): LeftJoinCriteria<CSchema>`**
 
   - Crea una instancia de `LeftJoinCriteria`. Usado para definir un `LEFT JOIN`.
   - **Retorna:** Una instancia de `LeftJoinCriteria`.
 
-- **`GetOuterJoinCriteria<CSchema extends CriteriaSchema, Alias extends SelectedAliasOf<CSchema>>(schema: CSchema, alias: Alias): OuterJoinCriteria<CSchema, Alias>`**
+- **`GetOuterJoinCriteria<CSchema extends CriteriaSchema>(schema: CSchema): OuterJoinCriteria<CSchema>`**
   - Crea una instancia de `OuterJoinCriteria`. Usado para definir un `FULL OUTER JOIN`.
   - **Retorna:** Una instancia de `OuterJoinCriteria`.
 
-Volver al Índice
+[Volver al Índice](#índice)
 
 ### `RootCriteria`
 
@@ -101,9 +98,9 @@ Se instancia a través de `CriteriaFactory.GetCriteria()`.
 **Métodos Principales (además de los heredados de `Criteria`):**
 
 - Implementa `accept` para el patrón Visitor, llamando a `visitor.visitRoot()`.
-- `resetCriteria()`: Devuelve una nueva instancia de `RootCriteria` con la misma configuración de esquema y alias, pero con todos los demás estados (filtros, joins, etc.) reiniciados.
+- `resetCriteria()`: Devuelve una nueva instancia de `RootCriteria` con la misma configuración de esquema, pero con todos los demás estados (filtros, joins, etc.) reiniciados.
 
-Volver al Índice
+[Volver al Índice](#índice)
 
 ### `InnerJoinCriteria`
 
@@ -115,7 +112,7 @@ Se instancia a través de `CriteriaFactory.GetInnerJoinCriteria()`.
 - Implementa `accept` para el patrón Visitor, llamando a `visitor.visitInnerJoin()`.
 - `resetCriteria()`: Devuelve una nueva instancia de `InnerJoinCriteria`.
 
-Volver al Índice
+[Volver al Índice](#índice)
 
 ### `LeftJoinCriteria`
 
@@ -127,7 +124,7 @@ Se instancia a través de `CriteriaFactory.GetLeftJoinCriteria()`.
 - Implementa `accept` para el patrón Visitor, llamando a `visitor.visitLeftJoin()`.
 - `resetCriteria()`: Devuelve una nueva instancia de `LeftJoinCriteria`.
 
-Volver al Índice
+[Volver al Índice](#índice)
 
 ### `OuterJoinCriteria`
 
@@ -139,7 +136,7 @@ Se instancia a través de `CriteriaFactory.GetOuterJoinCriteria()`.
 - Implementa `accept` para el patrón Visitor, llamando a `visitor.visitOuterJoin()`.
 - `resetCriteria()`: Devuelve una nueva instancia de `OuterJoinCriteria`.
 
-Volver al Índice
+[Volver al Índice](#índice)
 
 ### `Criteria` (Clase Abstracta Base)
 
@@ -155,8 +152,10 @@ Clase base abstracta para todos los tipos de criterios (`RootCriteria`, `InnerJo
 - `joins: ReadonlyArray<StoredJoinDetails<TSchema>>`: Configuraciones de join.
 - `rootFilterGroup: FilterGroup`: Grupo de filtros raíz.
 - `sourceName: TSchema['source_name']`: Nombre de la fuente del esquema.
-- `alias: CurrentAlias`: Alias actual del criteria.
+- `alias: TSchema['alias']`: El alias canónico del esquema.
 - `cursor: Cursor<...> | undefined`: Configuración del cursor para paginación.
+- `identifierField: FieldOfSchema<TSchema>`: El nombre del campo identificador del esquema.
+- `schemaMetadata: TSchema['metadata']`: El objeto de metadatos del esquema.
 
 **Métodos Principales (encadenables):**
 
@@ -168,10 +167,10 @@ Clase base abstracta para todos los tipos de criterios (`RootCriteria`, `InnerJo
 - **`where<Operator extends FilterOperator>(filterPrimitive: FilterPrimitive<...>): this`**: Inicia el grupo de filtros con una condición.
 - **`andWhere<Operator extends FilterOperator>(filterPrimitive: FilterPrimitive<...>): this`**: Añade una condición AND al grupo de filtros actual.
 - **`orWhere<Operator extends FilterOperator>(filterPrimitive: FilterPrimitive<...>): this`**: Añade una condición OR, creando un nuevo grupo si es necesario.
-- **`join<...>(criteriaToJoin: ..., joinParameter: ...): this`**: Añade una condición de join.
+- **`join(joinAlias: string, criteriaToJoin: JoinCriteria, joinParameter: object): this`**: Añade una condición de join.
 - **`setCursor(cursorFilters: [...], operator: ..., order: ...): this`**: Configura la paginación basada en cursor.
 
-Volver al Índice
+[Volver al Índice](#índice)
 
 ### `Filter`
 
@@ -190,19 +189,14 @@ Representa una condición de filtro individual. Se instancia internamente al usa
 
 **Métodos:**
 
-- `accept(visitor: ICriteriaVisitor<...>, currentAlias: string): TFilterVisitorOutput`: Para el patrón Visitor, llama a `visitor.visitFilter()`.
+- `accept(visitor: ICriteriaVisitor<...>, currentAlias: string, context: ...): TFilterVisitorOutput`: Para el patrón Visitor, llama a `visitor.visitFilter()`.
 - `toPrimitive(): FilterPrimitive<T, Operator>`: Devuelve la representación primitiva del filtro.
 
-Volver al Índice
+[Volver al Índice](#índice)
 
 ### `FilterGroup`
 
-Representa un grupo de filtros (`Filter` o anidados `FilterGroup`) conectados por un `LogicalOperator` (AND/OR). Se instancia y gestiona internamente por `CriteriaFilterManager` al usar los métodos `where`, `andWhere`, `orWhere`.
-
-**Constructor:**
-
-- `constructor(filterGroupPrimitive: FilterGroupPrimitive<T>)`
-  - Normaliza el grupo de filtros primitivo (ej. aplanando grupos AND anidados).
+Representa un grupo de filtros (`Filter` o anidados `FilterGroup`) conectados por un `LogicalOperator` (AND/OR). Se instancia y gestiona internamente por `CriteriaFilterManager`.
 
 **Propiedades (getters):**
 
@@ -211,20 +205,15 @@ Representa un grupo de filtros (`Filter` o anidados `FilterGroup`) conectados po
 
 **Métodos:**
 
-- `accept(visitor: ICriteriaVisitor<...>, currentAlias: string, context: ...): TranslationOutput`: Para el patrón Visitor, llama a `visitor.visitAndGroup()` o `visitor.visitOrGroup()` según el `logicalOperator`.
+- `accept(visitor: ICriteriaVisitor<...>, currentAlias: string, context: ...): void`: Para el patrón Visitor, llama a `visitor.visitAndGroup()` o `visitor.visitOrGroup()` según el `logicalOperator`.
 - `toPrimitive(): FilterGroupPrimitive<T>`: Devuelve la representación primitiva del grupo de filtros.
 
-Volver al Índice
+[Volver al Índice](#índice)
 
 ### `Order`
 
 Representa una regla de ordenamiento. Se instancia internamente al usar el método `orderBy()` de un `Criteria`.
 
-**Constructor:**
-
-- `constructor(direction: OrderDirection, field: T)`
-  - Asigna un `sequenceId` único globalmente para mantener un orden estable.
-
 **Propiedades (getters):**
 
 - `sequenceId: number`: ID de secuencia para ordenamiento estable.
@@ -235,29 +224,19 @@ Representa una regla de ordenamiento. Se instancia internamente al usar el méto
 
 - `toPrimitive(): OrderByPrimitive<T>`: Devuelve la representación primitiva de la regla de orden.
 
-Volver al Índice
+[Volver al Índice](#índice)
 
 ### `Cursor`
 
 Representa la configuración para la paginación basada en cursor. Se instancia internamente al usar el método `setCursor()` de un `Criteria`.
 
-**Constructor:**
-
-- `constructor(filterPrimitive: readonly [Omit<FilterPrimitive<...>, 'operator'>] | readonly [Omit<FilterPrimitive<...>, 'operator'>, Omit<FilterPrimitive<...>, 'operator'>], operator: FilterOperator.GREATER_THAN | FilterOperator.LESS_THAN, order: OrderDirection)`
-  - Valida que los campos y valores del cursor estén definidos y sean válidos.
-  - Soporta 1 o 2 `FilterPrimitive` para cursores simples o compuestos.
-  - @throws {Error} Si algún campo del cursor no está definido.
-  - @throws {Error} Si algún valor del cursor es undefined (se permite null).
-  - @throws {Error} Si se proporcionan dos campos de cursor y son idénticos.
-  - @throws {Error} Si no se proporcionan primitivas de filtro.
-
 **Propiedades (readonly):**
 
-- `filters: [Filter<TFields, Operator>] | [Filter<TFields, Operator>, Filter<TFields, Operator>]`: Los filtros que definen el cursor.
+- `filters: [Filter<...>] | [Filter<...>, Filter<...>]`: Los filtros que definen el cursor.
 - `order: OrderDirection`: La dirección de ordenamiento del cursor.
 - `operator: FilterOperator.GREATER_THAN | FilterOperator.LESS_THAN`: El operador del cursor.
 
-Volver al Índice
+[Volver al Índice](#índice)
 
 ---
 
@@ -269,32 +248,22 @@ Clase abstracta que sirve como base para crear traductores específicos para dif
 
 - **Genéricos:**
 
-  - `TranslationContext`: El tipo del objeto de contexto que se pasa y se modifica durante la traducción (ej. un `SelectQueryBuilder` de TypeORM).
+  - `TranslationContext`: El tipo del objeto de contexto mutable (ej. un constructor de consultas) que se pasa durante el recorrido.
   - `TranslationOutput` (opcional, por defecto es `TranslationContext`): El tipo del resultado final de la traducción.
-  - `TFilterVisitorOutput` (opcional, por defecto es `any`): El tipo de salida específico para los métodos `visitFilter`, `visitAndGroup` y `visitOrGroup`.
-
-- **Método Principal (para el usuario del traductor):**
-
-  - **`translate(criteria: RootCriteria<...>, source: TranslationContext): TranslationOutput`**
-    - Método público principal para iniciar el proceso de traducción.
-    - **Parámetros:**
-      - `criteria`: La instancia de `RootCriteria` a traducir.
-      - `source`: El contexto inicial para la traducción (ej. una instancia de `SelectQueryBuilder`).
-    - **Retorna:** El `TranslationOutput` (ej. el `SelectQueryBuilder` modificado o una cadena SQL).
+  - `TFilterVisitorOutput` (opcional, por defecto es `any`): El tipo de salida específico para el método `visitFilter`.
 
 - **Métodos Abstractos (a implementar por las clases hijas):**
 
-  - `visitRoot(...)`
-  - `visitInnerJoin(...)`
-  - `visitLeftJoin(...)`
-  - `visitOuterJoin(...)`
-  - `visitFilter(...)`
-  - `visitAndGroup(...)`
-  - `visitOrGroup(...)`
-
-  Estos métodos reciben el componente específico del `Criteria` (ej. `RootCriteria`, `Filter`), el alias actual o parámetros de join, y el `TranslationContext`. Deben devolver el `TranslationOutput` o el `TFilterVisitorOutput` según corresponda.
+  - **`translate(criteria: RootCriteria<...>, source: TranslationContext): TranslationOutput`**: El punto de entrada público principal para iniciar el proceso de traducción.
+  - `visitRoot(...): void`: Visita el nodo raíz del árbol de Criteria para inicializar la traducción.
+  - `visitInnerJoin(...): void`: Visita un nodo de Inner Join para aplicar su lógica.
+  - `visitLeftJoin(...): void`: Visita un nodo de Left Join para aplicar su lógica.
+  - `visitOuterJoin(...): void`: Visita un nodo de Outer Join para aplicar su lógica.
+  - `visitFilter(...): TFilterVisitorOutput`: Visita un nodo de Filtro individual y devuelve una representación intermedia de la condición.
+  - `visitAndGroup(...): void`: Visita un grupo de filtros unidos por un AND lógico.
+  - `visitOrGroup(...): void`: Visita un grupo de filtros unidos por un OR lógico.
 
-Volver al Índice
+[Volver al Índice](#índice)
 
 ---
 
@@ -304,40 +273,40 @@ Volver al Índice
 
 Enumeración que define los operadores de comparación disponibles para los filtros.
 
-- **Valores:**
-  - `EQUALS` (`=`): Igual a.
-  - `NOT_EQUALS` (`!=`): No igual a.
-  - `GREATER_THAN` (`>`): Mayor que.
-  - `GREATER_THAN_OR_EQUALS` (`>=`): Mayor o igual que.
-  - `LESS_THAN` (`<`): Menor que.
-  - `LESS_THAN_OR_EQUALS` (`<=`): Menor o igual que.
-  - `LIKE` (`LIKE`): Coincide con un patrón (sensible a mayúsculas/minúsculas según la BD).
-  - `NOT_LIKE` (`NOT LIKE`): No coincide con un patrón.
-  - `IN` (`IN`): El valor está dentro de un conjunto de valores.
-  - `NOT_IN` (`NOT IN`): El valor no está dentro de un conjunto de valores.
-  - `IS_NULL` (`IS NULL`): El valor es NULL.
-  - `IS_NOT_NULL` (`IS NOT NULL`): El valor no es NULL.
-  - `CONTAINS` (`CONTAINS`): Para búsqueda de subcadenas (a menudo insensible a mayúsculas/minúsculas según la BD).
-  - `STARTS_WITH` (`STARTS_WITH`): Comienza con una subcadena específica.
-  - `ENDS_WITH` (`ENDS_WITH`): Termina con una subcadena específica.
-  - `NOT_CONTAINS` (`NOT_CONTAINS`): No contiene una subcadena específica.
-  - `SET_CONTAINS`: Para campos tipo SET o arrays simples, busca si el conjunto contiene un valor.
-  - `SET_NOT_CONTAINS`: Para campos tipo SET o arrays simples, busca si el conjunto NO contiene un valor.
-  - `SET_CONTAINS_ANY` (`SET_CONTAINS_ANY`): Para campos tipo SET o arrays simples, busca si el conjunto contiene AL MENOS UNO de los valores especificados. Espera un array de valores.
-  - `SET_CONTAINS_ALL` (`SET_CONTAINS_ALL`): Para campos tipo SET o arrays simples, busca si el conjunto contiene TODOS los valores especificados. Espera un array de valores.
-  - `BETWEEN` (`BETWEEN`): Comprueba si un valor está dentro de un rango especificado (inclusivo). Espera un array o tupla de dos valores: `[min, max]`.
-  - `NOT_BETWEEN` (`NOT_BETWEEN`): Comprueba si un valor está fuera de un rango especificado (inclusivo). Espera un array o tupla de dos valores: `[min, max]`.
-  - `MATCHES_REGEX` (`MATCHES_REGEX`): Comprueba si un valor de cadena coincide con un patrón de expresión regular. La sintaxis específica de regex puede depender de la base de datos. Espera una cadena que represente la expresión regular.
-  - `ILIKE` (`ILIKE`): Comprueba si un valor de cadena coincide con un patrón (insensible a mayúsculas/minúsculas). Espera una cadena para el patrón.
-  - `NOT_ILIKE` (`NOT_ILIKE`): Comprueba si un valor de cadena no coincide con un patrón (insensible a mayúsculas/minúsculas). Espera una cadena para el patrón.
-  - `JSON_CONTAINS`: Para campos JSON, busca si el JSON contiene una estructura o valor específico en una ruta.
-  - `JSON_NOT_CONTAINS`: Para campos JSON, busca si el JSON NO contiene una estructura o valor específico.
-  - `ARRAY_CONTAINS_ELEMENT`: Para campos Array (nativo o JSON), busca si el array contiene un elemento.
-  - `ARRAY_CONTAINS_ALL_ELEMENTS`: Para campos Array, busca si el array contiene todos los elementos de un array dado.
-  - `ARRAY_CONTAINS_ANY_ELEMENT`: Para campos Array, busca si el array contiene alguno de los elementos de un array dado.
-  - `ARRAY_EQUALS`: Para campos Array, busca si el array es exactamente igual a un array dado (orden y elementos).
-
-Volver al Índice
+- **Values:**
+  - `EQUALS` (`=`): Equal to.
+  - `NOT_EQUALS` (`!=`): Not equal to.
+  - `GREATER_THAN` (`>`): Greater than.
+  - `GREATER_THAN_OR_EQUALS` (`>=`): Greater than or equal to.
+  - `LESS_THAN` (`<`): Less than.
+  - `LESS_THAN_OR_EQUALS` (`<=`): Less than or equal to.
+  - `LIKE` (`LIKE`): Matches a pattern (case sensitivity depends on the DB).
+  - `NOT_LIKE` (`NOT LIKE`): Does not match a pattern.
+  - `IN` (`IN`): The value is within a set of values.
+  - `NOT_IN` (`NOT IN`): The value is not within a set of values.
+  - `IS_NULL` (`IS NULL`): The value is NULL.
+  - `IS_NOT_NULL` (`IS NOT NULL`): The value is not NULL.
+  - `CONTAINS` (`CONTAINS`): For substring search.
+  - `STARTS_WITH` (`STARTS_WITH`): Starts with a specific substring.
+  - `ENDS_WITH` (`ENDS_WITH`): Ends with a specific substring.
+  - `NOT_CONTAINS` (`NOT_CONTAINS`): Does not contain a specific substring.
+  - `SET_CONTAINS`: For SET-type fields or simple arrays, checks if the set contains a value.
+  - `SET_NOT_CONTAINS`: The inverse of `SET_CONTAINS`.
+  - `SET_CONTAINS_ANY`: Checks if the set contains AT LEAST ONE of the specified values.
+  - `SET_CONTAINS_ALL`: Checks if the set contains ALL of the specified values.
+  - `BETWEEN` (`BETWEEN`): Checks if a value is within a specified range (inclusive).
+  - `NOT_BETWEEN` (`NOT_BETWEEN`): Checks if a value is outside a specified range.
+  - `MATCHES_REGEX` (`MATCHES_REGEX`): Checks if a string value matches a regular expression.
+  - `ILIKE` (`ILIKE`): Case-insensitive version of `LIKE`.
+  - `NOT_ILIKE` (`NOT_ILIKE`): Case-insensitive version of `NOT_ILIKE`.
+  - `JSON_CONTAINS`: For JSON fields, checks if the JSON contains a specific structure or value.
+  - `JSON_NOT_CONTAINS`: The inverse of `JSON_CONTAINS`.
+  - `ARRAY_CONTAINS_ELEMENT`: For Array fields, checks if the array contains an element.
+  - `ARRAY_CONTAINS_ALL_ELEMENTS`: Checks if the array contains all elements from a given array.
+  - `ARRAY_CONTAINS_ANY_ELEMENT`: Checks if the array contains any of the elements from a given array.
+  - `ARRAY_EQUALS`: Checks if the array is exactly equal to a given array.
+
+[Volver al Índice](#índice)
 
 ### `LogicalOperator`
 
@@ -347,7 +316,7 @@ Enumeración que define los operadores lógicos para combinar grupos de filtros.
   - `AND` (`AND`): Todas las condiciones deben cumplirse.
   - `OR` (`OR`): Al menos una condición debe cumplirse.
 
-Volver al Índice
+[Volver al Índice](#índice)
 
 ### `OrderDirection`
 
@@ -357,7 +326,7 @@ Enumeración que define la dirección del ordenamiento.
   - `ASC` (`ASC`): Orden ascendente.
   - `DESC` (`DESC`): Orden descendente.
 
-Volver al Índice
+[Volver al Índice](#índice)
 
 ---
 
@@ -369,40 +338,40 @@ Interfaz que define la estructura de un esquema de entidad. Los esquemas son cru
 
 - **Propiedades:**
   - `source_name: string`: El nombre real de la tabla o colección en la base de datos.
-  - `alias: readonly string[]`: Un array de posibles alias para esta entidad. El primero es usualmente el principal.
+  - `alias: string`: Un único alias canónico para esta entidad.
   - `fields: readonly string[]`: Un array de los nombres de los campos consultables de esta entidad.
+  - `identifier_field: string`: **(Obligatorio)** El nombre del campo que identifica unívocamente una entidad de este esquema. Debe ser uno de los nombres en `fields`.
   - `joins: readonly SchemaJoins<string>[]` (opcional): Un array que define las posibles relaciones de unión con otros esquemas.
-    - `SchemaJoins<AliasUnion extends string>`:
-      - `alias: AliasUnion`: El alias de la entidad unida (debe coincidir con un alias en el esquema de la entidad unida).
-      - `relation_type: JoinRelationType`: El tipo de relación (ej. `'one_to_many'`).
-      - `metadata?: { [key: string]: any }`: Metadatos opcionales asociados con esta configuración de join específica.
-  - `metadata?: { [key: string]: any }`: Metadatos opcionales asociados con la definición completa del esquema. Pueden ser usados por los traductores para lógica o pistas personalizadas.
+  - `metadata?: { [key: string]: any }`: Metadatos opcionales asociados con la definición completa del esquema.
 
-Volver al Índice
+[Volver al Índice](#índice)
 
 ### `GetTypedCriteriaSchema`
 
 Función helper para definir esquemas. Preserva los tipos literales de `fields` y `alias`, mejorando el autocompletado y la validación de tipos.
 
-- **Función:** `GetTypedCriteriaSchema<T extends MinimalCriteriaSchema>(schema: T): T`
-  - **Parámetros:**
-    - `schema`: Un objeto que se ajusta a la estructura `MinimalCriteriaSchema` (una versión más laxa de `CriteriaSchema` para la entrada).
-  - **Retorna:** El mismo objeto `schema` de entrada, pero con sus tipos literales preservados.
-  - **Ejemplo:**
+- **Función:** `GetTypedCriteriaSchema<T extends CriteriaSchema>(schema: T): T`
+- **Ejemplo:**
 
 ```typescript
 import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
 
-const MiEsquemaUsuario = GetTypedCriteriaSchema({
-  source_name: 'usuarios_tabla',
-  alias: ['usuario', 'u'],
-  fields: ['id', 'nombre', 'email'],
-  joins: [{ alias: 'pedidos', relation_type: 'one_to_many' }],
+export const UserSchema = GetTypedCriteriaSchema({
+  source_name: 'users',
+  alias: 'u',
+  fields: ['id', 'name', 'email'],
+  identifier_field: 'id',
+  joins: [
+    {
+      alias: 'posts',
+      target_source_name: 'posts',
+      relation_type: 'one_to_many',
+    },
+  ],
 });
-// MiEsquemaUsuario ahora tiene tipos literales para alias y fields.
 ```
 
-Volver al Índice
+[Volver al Índice](#índice)
 
 ### `FieldOfSchema`
 
@@ -410,15 +379,7 @@ Tipo helper que extrae los nombres de los campos válidos de un `CriteriaSchema`
 
 - **Tipo:** `FieldOfSchema<T extends CriteriaSchema> = T['fields'][number];`
 
-Volver al Índice
-
-### `SelectedAliasOf`
-
-Tipo helper que extrae los alias válidos de un `CriteriaSchema` dado.
-
-- **Tipo:** `SelectedAliasOf<T extends CriteriaSchema> = T['alias'][number];`
-
-Volver al Índice
+[Volver al Índice](#índice)
 
 ### `JoinRelationType`
 
@@ -426,225 +387,175 @@ Tipo unión de strings que representa los tipos de relaciones de join posibles.
 
 - **Valores Posibles:** `'one_to_one' | 'one_to_many' | 'many_to_one' | 'many_to_many'`
 
-Volver al Índice
+[Volver al Índice](#índice)
 
 ### `SchemaJoins`
 
 Interfaz que define la estructura de una configuración de join dentro de la propiedad `joins` de un `CriteriaSchema`.
 
 - **Propiedades:**
-  - `alias: AliasUnion`: El alias de la entidad con la que se une.
+  - `alias: string`: El alias para esta relación de unión específica (ej. `'posts'`, `'autor'`).
   - `relation_type: JoinRelationType`: El tipo de relación.
+  - `target_source_name: string`: El `source_name` del esquema al que se une.
   - `metadata?: { [key: string]: any }`: Metadatos opcionales asociados con esta configuración de join específica.
 
-Volver al Índice
+[Volver al Índice](#índice)
 
 ### `FilterPrimitive`
 
 Interfaz que define la estructura para una condición de filtro individual antes de ser instanciada como un objeto `Filter`.
 
-- **Genéricos:**
-  - `Field extends FieldOfSchema<CriteriaSchema>`: El tipo de los campos válidos.
-  - `Operator extends FilterOperator`: El operador de filtro específico.
 - **Propiedades:**
-  - `field: Field`: El campo al que se aplica el filtro.
-  - `operator: Operator`: El operador de filtro.
+  - `field: FieldOfSchema<...>`: El campo al que se aplica el filtro.
+  - `operator: FilterOperator`: El operador de filtro.
   - `value: FilterValue<Operator>`: El valor del filtro, cuyo tipo depende del `Operator`.
 
-Volver al Índice
+[Volver al Índice](#índice)
 
 ### `FilterGroupPrimitive`
 
 Interfaz que define la estructura para un grupo de filtros antes de ser instanciado como un objeto `FilterGroup`.
 
-- **Genéricos:**
-  - `Field extends string`: El tipo de los campos válidos.
 - **Propiedades:**
   - `logicalOperator: LogicalOperator`: El operador lógico (`AND` o `OR`) que une los `items`.
-  - `items: ReadonlyArray<FilterPrimitive<Field, FilterOperator> | FilterGroupPrimitive<Field>>`: Array de filtros o grupos de filtros anidados.
+  - `items: ReadonlyArray<FilterPrimitive<...> | FilterGroupPrimitive<...>>`: Array de filtros o grupos de filtros anidados.
 
-Volver al Índice
+[Volver al Índice](#índice)
 
 ### `FilterValue`
 
 Tipo genérico que representa el valor asociado con un filtro, fuertemente tipado según el `FilterOperator` utilizado.
 
-- **Definición (conceptual):**
-  - Si `Operator` es `LIKE`, `CONTAINS`, etc. => `string`
-  - Si `Operator` es `EQUALS`, `GREATER_THAN`, etc. => `PrimitiveFilterValue` (string | number | boolean | Date | null)
-  - Si `Operator` es `IN`, `NOT_IN` => `Array<Exclude<PrimitiveFilterValue, null | undefined>>`
-  - Si `Operator` es `SET_CONTAINS_ANY`, `SET_CONTAINS_ALL` => `Array<Exclude<PrimitiveFilterValue, null | undefined>>`
-  - Si `Operator` es `BETWEEN`, `NOT_BETWEEN` => `[Exclude<PrimitiveFilterValue, null | undefined>, Exclude<PrimitiveFilterValue, null | undefined>]`
-  - Si `Operator` es `MATCHES_REGEX`, `ILIKE`, `NOT_ILIKE` => `string`
-  - Si `Operator` es `ARRAY_CONTAINS_ELEMENT` => `PrimitiveFilterValue | { [jsonPath: string]: PrimitiveFilterValue }`
-  - Si `Operator` es `ARRAY_CONTAINS_ALL_ELEMENTS`, etc. => `Array<...> | { [jsonPath: string]: Array<...> }`
-  - Si `Operator` es `IS_NULL`, `IS_NOT_NULL` => `null | undefined`
-  - Si `Operator` es `JSON_CONTAINS`, etc. => `{ [jsonPath: string]: PrimitiveFilterValue | Array<any> | Record<string, any> }`
-
-Volver al Índice
+[Volver al Índice](#índice)
 
 ### `OrderByPrimitive`
 
 Tipo que define la estructura para una regla de ordenamiento antes de ser instanciada como un objeto `Order`.
 
-- **Genéricos:**
-  - `T extends string`: El tipo de los campos válidos.
 - **Propiedades:**
   - `direction: OrderDirection`: La dirección del ordenamiento.
-  - `field: T`: El campo por el cual ordenar.
+  - `field: string`: El campo por el cual ordenar.
 
-Volver al Índice
+[Volver al Índice](#índice)
 
 ### `PivotJoinInput`
 
 Tipo que representa los parámetros de entrada para una unión `many-to-many` a través de una tabla pivote, tal como los proporciona el usuario al método `.join()`.
 
-- **Genéricos:**
-  - `ParentSchema extends CriteriaSchema`
-  - `JoinSchema extends CriteriaSchema`
 - **Propiedades:**
   - `pivot_source_name: string`: Nombre de la tabla pivote.
   - `parent_field: { pivot_field: string; reference: FieldOfSchema<ParentSchema> }`: Configuración del campo de la entidad padre que referencia la tabla pivote.
   - `join_field: { pivot_field: string; reference: FieldOfSchema<JoinSchema> }`: Configuración del campo de la entidad unida que referencia la tabla pivote.
 
-Volver al Índice
+[Volver al Índice](#índice)
 
 ### `SimpleJoinInput`
 
 Tipo que representa los parámetros de entrada para una unión simple (one-to-one, one-to-many, many-to-one), tal como los proporciona el usuario al método `.join()`.
 
-- **Genéricos:**
-  - `ParentSchema extends CriteriaSchema`
-  - `JoinSchema extends CriteriaSchema`
 - **Propiedades:**
   - `parent_field: FieldOfSchema<ParentSchema>`: Campo en la entidad padre para la condición de join.
   - `join_field: FieldOfSchema<JoinSchema>`: Campo en la entidad unida para la condición de join.
 
-Volver al Índice
+[Volver al Índice](#índice)
 
 ### `ICriteriaBase`
 
 Interfaz base que define la funcionalidad común para todos los tipos de criterios.
 
-- **Genéricos:**
-  - `TSchema extends CriteriaSchema`
-  - `CurrentAlias extends SelectedAliasOf<TSchema>`
-- **Métodos Principales (ver `Criteria` para detalles):**
-  - `resetSelect()`
-  - `setSelect(...)`
-  - `setTake(...)`
-  - `setSkip(...)`
-  - `orderBy(...)`
-  - `where(...)`
-  - `andWhere(...)`
-  - `orWhere(...)`
-  - `join(...)`
-  - `setCursor(...)`
-- **Propiedades (getters):** `select`, `selectAll`, `take`, `skip`, `orders`, `joins`, `rootFilterGroup`, `sourceName`, `alias`, `cursor`.
-
-Volver al Índice
+[Volver al Índice](#índice)
 
 ### `ICriteriaVisitor`
 
 Interfaz para el patrón Visitor, implementada por `CriteriaTranslator`. Define los métodos `visit...` para cada tipo de nodo del `Criteria`.
 
-- **Genéricos:**
-  - `TranslationContext`
-  - `TranslationOutput`
-  - `TFilterVisitorOutput`
-- **Métodos (ver `CriteriaTranslator` para detalles):**
-  - `visitRoot(...)`
-  - `visitInnerJoin(...)`
-  - `visitLeftJoin(...)`
-  - `visitOuterJoin(...)`
-  - `visitFilter(...)`
-  - `visitAndGroup(...)`
-  - `visitOrGroup(...)`
-
-Volver al Índice
+- **Métodos (retornan `void` a menos que se especifique):**
+  - `visitRoot(...)`: Visita el nodo raíz del árbol de Criteria para inicializar la traducción.
+  - `visitInnerJoin(...)`: Visita un nodo de Inner Join para aplicar su lógica.
+  - `visitLeftJoin(...)`: Visita un nodo de Left Join para aplicar su lógica.
+  - `visitOuterJoin(...)`: Visita un nodo de Outer Join para aplicar su lógica.
+  - `visitFilter(...): TFilterVisitorOutput`: Visita un nodo de Filtro individual y devuelve una representación intermedia de la condición.
+  - `visitAndGroup(...)`: Visita un grupo de filtros unidos por un AND lógico.
+  - `visitOrGroup(...)`: Visita un grupo de filtros unidos por un OR lógico.
+
+[Volver al Índice](#índice)
 
 ### `IFilterExpression`
 
 Interfaz implementada por `Filter` y `FilterGroup`.
 
 - **Métodos:**
-  - `toPrimitive(): FilterPrimitive<...> | FilterGroupPrimitive<...>`: Devuelve la representación primitiva de la expresión de filtro.
+  - `toPrimitive()`: Devuelve la representación primitiva de la expresión de filtro.
 
-Volver al Índice
+[Volver al Índice](#índice)
 
 ### `StoredJoinDetails`
 
 Interfaz que define la estructura para almacenar los detalles de una unión configurada internamente.
 
-- **Genéricos:**
-  - `ParentSchema extends CriteriaSchema`
 - **Propiedades:**
   - `parameters: PivotJoin<...> | SimpleJoin<...>`: Los parámetros resueltos del join.
   - `criteria: AnyJoinCriteria<...>`: La instancia del `Criteria` de la entidad unida.
 
-Volver al Índice
+[Volver al Índice](#índice)
 
 ### `AnyJoinCriteria`
 
 Tipo unión que representa cualquier tipo de `Criteria` de join (`InnerJoinCriteria`, `LeftJoinCriteria`, `OuterJoinCriteria`).
 
-Volver al Índice
+[Volver al Índice](#índice)
 
 ### `JoinCriteriaParameterType`
 
-Tipo helper que determina el tipo del objeto `Criteria` que se debe pasar al método `.join()`, validando que el alias de la entidad unida esté configurado en el esquema padre.
+Tipo helper que determina el tipo del objeto `Criteria` que se debe pasar al método `.join()`, validando que el `source_name` de la entidad unida esté configurado en el esquema padre.
 
-Volver al Índice
+[Volver al Índice](#índice)
 
 ### `JoinParameterType`
 
-Tipo helper que determina la forma esperada del objeto de parámetros de join para el método `.join()`, basándose en el `join_relation_type` definido en el esquema padre.
+Tipo helper que determina la forma esperada del objeto de parámetros de join para el método `.join()`, basándose en el `relation_type` definido en el esquema padre.
 
-Volver al Índice
+[Volver al Índice](#índice)
 
 ### `SpecificMatchingJoinConfig`
 
-Tipo helper que extrae la configuración de join específica de un esquema padre que coincide con un alias de entidad unida dado.
+Tipo helper que extrae la configuración de join específica de un esquema padre que coincide con un `target_source_name` dado.
 
-Volver al Índice
+[Volver al Índice](#índice)
 
 ### `PivotJoin`
 
 Tipo que representa los parámetros completamente resueltos para una unión `many-to-many` a través de una tabla pivote, usado internamente.
 
-- **Genéricos:**
-  - `ParentSchema extends CriteriaSchema`
-  - `JoinSchema extends CriteriaSchema`
-  - `TRelationType extends JoinRelationType`
 - **Propiedades:**
-  - `relation_type: TRelationType`: El tipo de relación desde la entidad padre a la entidad unida.
-  - `parent_source_name: ParentSchema['source_name']`
-  - `parent_alias: ParentSchema['alias'][number]`
+  - `relation_type: 'many_to_many'`
+  - `parent_source_name: string`
+  - `parent_alias: string`
+  - `join_alias: string`
+  - `parent_identifier: string`
   - `pivot_source_name: string`
-  - `parent_field: { pivot_field: string; reference: FieldOfSchema<ParentSchema> }`
-  - `join_field: { pivot_field: string; reference: FieldOfSchema<JoinSchema> }`
-  - `parent_schema_metadata: { [key: string]: any }`: Metadatos opcionales del esquema padre.
-  - `join_metadata: { [key: string]: any }`: Metadatos opcionales de la configuración específica del join.
+  - `parent_field: { pivot_field: string; reference: string }`
+  - `join_field: { pivot_field: string; reference: string }`
+  - `parent_schema_metadata: { [key: string]: any }`
+  - `join_metadata: { [key: string]: any }`
 
-Volver al Índice
+[Volver al Índice](#índice)
 
 ### `SimpleJoin`
 
 Tipo que representa los parámetros completamente resueltos para una unión simple (one-to-one, one-to-many, many-to-one), usado internamente.
 
-- **Genéricos:**
-  - `ParentSchema extends CriteriaSchema`
-  - `JoinSchema extends CriteriaSchema`
-  - `TRelationType extends JoinRelationType`
 - **Propiedades:**
-  - `relation_type: TRelationType`: El tipo de relación desde la entidad padre a la entidad unida.
-  - `parent_source_name: ParentSchema['source_name']`
-  - `parent_alias: ParentSchema['alias'][number]`
-  - `parent_field: FieldOfSchema<ParentSchema>`
-  - `join_field: FieldOfSchema<JoinSchema>`
-  - `parent_schema_metadata: { [key: string]: any }`: Metadatos opcionales del esquema padre.
-  - `join_metadata: { [key: string]: any }`: Metadatos opcionales de la configuración específica del join.
-
-Volver al Índice
+  - `relation_type: 'one_to_one' | 'one_to_many' | 'many_to_one'`
+  - `parent_source_name: string`
+  - `parent_alias: string`
+  - `join_alias: string`
+  - `parent_identifier: string`
+  - `parent_field: string`
+  - `join_field: string`
+  - `parent_schema_metadata: { [key: string]: any }`
+  - `join_metadata: { [key: string]: any }`
+
+[Volver al Índice](#índice)
 
 ---
diff --git a/src/docs/core-concepts/en.md b/src/docs/core-concepts/en.md
index 1023549..11afbbb 100644
--- a/src/docs/core-concepts/en.md
+++ b/src/docs/core-concepts/en.md
@@ -4,18 +4,22 @@ This section delves into the fundamental components that make up the `@nulledexp
 
 ## Index of Core Concepts
 
-- **_[Hierarchy of Criteria](#hierarchy-of-criteria)_**
+- **_[Hierarchy of Criteria](#criteria-hierarchy)_**
 - **_[CriteriaFactory](#criteriafactory)_**
 - **_[Schemas (`CriteriaSchema` and `GetTypedCriteriaSchema`)](#schemas-criteriaschema-and-gettypedcriteriaschema)_**
-- **_[`CriteriaTranslator` (Abstract Class and Visitor Pattern)](#criteriatranslator-abstract-class-and-visitor-pattern)_**
+  - [_Identifier Field (`identifier_field`)_](#identifier-field-identifier_field)
+  - [_Schema and Join Metadata_](#schema-and-join-metadata)
+- **_[`CriteriaTranslator` (Abstract Class)](#criteriatranslator-abstract-class)_**
 - **_[Filters (`Filter`, `FilterGroup`, `FilterOperator`)](#filters-filter-filtergroup-filteroperator)_**
 - **_[Ordering (`Order`, `OrderDirection`)](#ordering-order-orderdirection)_**
 - **_[Pagination](#pagination)_**
+  - [_Offset-based Pagination_](#offset-based-pagination)
+  - [_Cursor-based Pagination_](#cursor-based-pagination)
 - **_[Field Selection (`setSelect`, `resetSelect`)](#field-selection-setselect-resetselect)_**
 
 ---
 
-## Hierarchy of `Criteria`
+## `Criteria` Hierarchy
 
 The abstract `Criteria` class is the base for defining query specifications. It represents a set of conditions, orderings, joins, and pagination configurations for an entity or a set of related entities.
 
@@ -29,7 +33,7 @@ There are several concrete implementations of `Criteria`:
 Each `Criteria` instance encapsulates:
 
 - The schema (`CriteriaSchema`) of the entity it applies to.
-- A unique alias to reference this entity in the query.
+- A unique, canonical alias to reference this entity in the query.
 - Internal managers for filters, joins, ordering, and field selection.
 
 [Back to Index](#index-of-core-concepts)
@@ -38,16 +42,24 @@ Each `Criteria` instance encapsulates:
 
 ## `CriteriaFactory`
 
-`CriteriaFactory` is a utility class that provides static methods for creating instances of the different types of `Criteria` (`RootCriteria`, `InnerJoinCriteria`, etc.).
+`CriteriaFactory` is a utility class that provides static methods for creating instances of the different types of `Criteria`.
 
 **Purpose:**
 
 - **Simplify Creation:** Abstracts the complexity of direct instantiation.
-- **Ensure Correct Initialization:** Guarantees that criteria are created with the necessary parameters and initial validations.
+- **Ensure Correct Initialization:** Guarantees that criteria are created with the necessary schema and validations.
 - **Improve Readability:** Makes criteria building code clearer and more concise.
 
 **Recommended Usage:**
-It is strongly recommended to use `CriteriaFactory` instead of instantiating `Criteria` classes directly.
+It is strongly recommended to use `CriteriaFactory` instead of instantiating `Criteria` classes directly. The factory methods no longer require an alias parameter, as the canonical alias is now taken directly from the schema.
+
+```typescript
+import { CriteriaFactory } from '@nulledexp/translatable-criteria';
+import { UserSchema, PostSchema } from './path/to/your/schemas';
+
+const userCriteria = CriteriaFactory.GetCriteria(UserSchema);
+const postJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(PostSchema);
+```
 
 [Back to Index](#index-of-core-concepts)
 
@@ -55,48 +67,114 @@ It is strongly recommended to use `CriteriaFactory` instead of instantiating `Cr
 
 ## Schemas (`CriteriaSchema` and `GetTypedCriteriaSchema`)
 
-Schemas are fundamental for type safety and validation in `@nulledexp/translatable-criteria`. A `CriteriaSchema` defines the "shape" of your data entities as the library understands them.
+Schemas are fundamental for type safety and validation. A `CriteriaSchema` defines the "shape" of your data entities as the library understands them. For a complete guide, see **Defining Schemas**.
 
 **What Defines a Schema?**
 
 - `source_name`: The actual name of the table or collection in the database.
-- `alias`: An array of possible aliases that can be used to refer to this entity in queries.
-- `fields`: An array with the names of the available fields for this entity.
-- `joins`: An array that defines possible join relationships with other schemas, including the `alias` of the join and the `join_relation_type` (e.g., `one_to_many`, `many_to_one`, `many_to_many`).
+- `alias`: A **single, canonical alias** for the entity.
+- `fields`: An array with the names of the available fields.
+- `identifier_field`: A **mandatory** field that uniquely identifies an entity.
+- `joins`: An array defining possible join relationships, each with its own `alias` and `target_source_name`.
+- `metadata`: (Optional) An object to store arbitrary, translator-specific information or configuration relevant to the entire entity this schema represents.
 
 **`GetTypedCriteriaSchema`:**
-This is a helper function used to define schemas. Its main advantage is that it preserves the literal types of the `fields` and `alias`, which allows for more robust autocompletion and type validation when building criteria. This avoids the need to use type assertions (like as const) in the schema definition, while also ensuring the schema structure is valid.
+This is a helper function used to define schemas. Its main advantage is that it preserves the literal types of the `fields`, `alias`, and `identifier_field`, which allows for more robust autocompletion and type validation when building criteria. This avoids the need to use type assertions (like `as const`) in the schema definition, while also ensuring the schema structure (including `identifier_field` validity) is correct.
+
 Schemas are provided to the `CriteriaFactory` when creating `Criteria` instances, allowing the library to validate that the fields, aliases, and joins used are correct.
 
+### Identifier Field (`identifier_field`)
+
+The `identifier_field` is a **mandatory** property in your `CriteriaSchema`. It specifies which field in your `fields` array serves as the unique identifier (primary key) for that entity.
+
+**Purpose:**
+
+- **Unique Identification:** Clearly designates the primary key field.
+- **Enhanced Validation:** The library validates at compile-time (and runtime) that the `identifier_field` you specify is indeed one of the `fields` defined in the schema.
+- **Automatic Selection:** When using `setSelect()` to choose specific fields, the `identifier_field` of the entity is **always implicitly included** in the selection, ensuring that the entity can always be uniquely identified.
+- **Context for Translators:** The identifier of a parent entity is passed to the translator during join operations (`parent_identifier`), which can be used for more advanced relationship inference.
+
+```typescript
+import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
+
+export const UserSchema = GetTypedCriteriaSchema({
+  source_name: 'users',
+  alias: 'u',
+  fields: ['id', 'username', 'email', 'age', 'isActive', 'createdAt', 'tags'],
+  identifier_field: 'id',
+  joins: [
+    {
+      alias: 'posts',
+      target_source_name: 'posts',
+      relation_type: 'one_to_many',
+    },
+  ],
+});
+```
+
+### Schema and Join Metadata
+
+Both the root of a `CriteriaSchema` and the individual join configurations within the `joins` array can have an optional `metadata` property.
+
+- **`CriteriaSchema.metadata`**: For information relevant to the entire entity.
+- **`SchemaJoins.metadata`**: For information specific to a particular join relationship.
+
+**Purpose for the User:**
+This `metadata` field is a flexible, open object (`{ [key: string]: any }`) designed to hold arbitrary information that might be needed by a specific `CriteriaTranslator` you are using.
+
+**How to Use:**
+You can add any key-value pairs to the `metadata` object. The specific keys and values that are meaningful depend entirely on the `CriteriaTranslator` you are using. Consult the documentation of your translator to understand what, if any, `metadata` it recognizes and utilizes.
+
+```typescript
+import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
+
+export const PostSchema = GetTypedCriteriaSchema({
+  source_name: 'posts',
+  alias: 'p',
+  fields: [
+    'id',
+    'title',
+    'content',
+    'userId',
+    'createdAt',
+    'categories',
+    'metadata',
+  ],
+  identifier_field: 'id',
+  metadata: {
+    custom_handler: 'specialPostHandler',
+    versioning_enabled: true,
+  },
+  joins: [
+    {
+      alias: 'user',
+      target_source_name: 'users',
+      relation_type: 'many_to_one',
+      metadata: {
+        typeorm_lazy_load: false,
+        custom_on_clause_template: 'user.id = post.userId_custom_fk',
+      },
+    },
+  ],
+});
+```
+
 [Back to Index](#index-of-core-concepts)
 
 ---
 
-## `CriteriaTranslator` (Abstract Class and Visitor Pattern)
+## `CriteriaTranslator` (Abstract Class)
 
-The `CriteriaTranslator` is the heart of the translation mechanism. It is an abstract class designed to be extended by concrete implementations that will convert a `Criteria` object (data source agnostic) into a specific query for a particular database or search engine (e.g., SQL, a TypeORM query, a MongoDB query, etc.).
+The `CriteriaTranslator` is the component responsible for converting a `Criteria` object (which is data-source agnostic) into a specific query for a particular database or search engine (e.g., SQL, a TypeORM query, a MongoDB query, etc.).
 
 **Main Role:**
 
 - Process a `Criteria` object (typically starting with a `RootCriteria`).
-- "Visit" each part of the `Criteria` (filters, joins, ordering, etc.).
+- Interpret the filters, joins, ordering, pagination, and selection defined in the `Criteria`.
 - Generate the corresponding native query syntax.
 
-**Visitor Pattern:**
-The library uses the Visitor design pattern.
-
-- Each `Criteria` class (and its components like `FilterGroup`, `Filter`) has an `accept(visitor, ...args)` method.
-- The `CriteriaTranslator` implements the `ICriteriaVisitor` interface, which defines `visit...` methods for each type of element it can encounter (e.g., `visitRootCriteria`, `visitInnerJoinCriteria`, `visitFilter`, `visitAndGroup`).
-
-When `criteria.accept(translator, ...)` is called:
-
-1.  The `criteria` invokes the appropriate `visit...` method on the `translator`, passing itself as an argument.
-2.  The `translator` executes the specific logic to translate that type of `criteria` or component.
-
 This allows for a clean and extensible architecture: the logic for building `Criteria` is separated from the translation logic. To support a new database, you only need to create a new translator that extends `CriteriaTranslator`.
 
-Concrete translators (like `@nulledexp/typeorm-mysql-translator`) are provided as separate packages.
-
 [Back to Index](#index-of-core-concepts)
 
 ---
@@ -105,32 +183,16 @@ Concrete translators (like `@nulledexp/typeorm-mysql-translator`) are provided a
 
 Filters allow you to specify the conditions that data must meet to be selected.
 
-- **`Filter`**: Represents a single filter condition. It consists of:
-
-  - `field`: The field the filter is applied to. This field is strongly typed with the valid fields defined in the schema of each Criteria.
-  - `operator`: The comparison operator (see `FilterOperator`).
-  - `value`: The value the field is compared against. The type of this value is strictly typed based on the `operator` used.
-
-- **`FilterOperator`**: This is an enumeration that defines the various comparison operators available, such as:
-
-  - Equality: `EQUALS`, `NOT_EQUALS`
-  - Comparison: `GREATER_THAN`, `LESS_THAN`, `GREATER_THAN_OR_EQUALS`, `LESS_THAN_OR_EQUALS`
-  - Patterns: `LIKE`, `NOT_LIKE`, `CONTAINS`, `NOT_CONTAINS`, `STARTS_WITH`, `ENDS_WITH`
-  - Membership: `IN`, `NOT_IN`
-  - Nullability: `IS_NULL`, `IS_NOT_NULL`
-  - For ranges: `BETWEEN`, `NOT_BETWEEN`
-  - For regular expressions: `MATCHES_REGEX`
-  - For case-insensitive pattern matching: `ILIKE`, `NOT_ILIKE`
-  - For SET-like fields (or equivalents): `SET_CONTAINS`, `SET_NOT_CONTAINS`
-  - For SET-like fields (or equivalents) with multiple values: `SET_CONTAINS_ANY`, `SET_CONTAINS_ALL`
-  - For JSON fields: `JSON_CONTAINS`, `JSON_NOT_CONTAINS`
-  - For Array fields: `ARRAY_CONTAINS_ELEMENT`, `ARRAY_CONTAINS_ALL_ELEMENTS`, `ARRAY_CONTAINS_ANY_ELEMENT`, `ARRAY_EQUALS`
+- **`Filter`**: Represents a single filter condition (`field`, `operator`, `value`).
+- **`FilterGroup`**: Allows grouping multiple `Filter` or even other `FilterGroup` instances using logical operators (`AND` or `OR`).
+- **`FilterOperator`**: An enumeration that defines the various comparison operators available, which can be broadly categorized:
+- **Equality & Comparison:** `EQUALS`, `NOT_EQUALS`, `GREATER_THAN`, `LESS_THAN`, etc.
+- **Pattern Matching:** `LIKE`, `CONTAINS`, `STARTS_WITH`, `ILIKE` (case-insensitive version of LIKE).
+- **Membership & Nullability:** `IN`, `NOT_IN`, `IS_NULL`, `IS_NOT_NULL`.
+- **Ranges & Regex:** `BETWEEN`, `NOT_BETWEEN`, `MATCHES_REGEX`.
+- **Complex Types:** A rich set of operators for `JSON`, `ARRAY`, and `SET` data types (e.g., `JSON_CONTAINS`, `ARRAY_CONTAINS_ANY_ELEMENT`).
 
-- **`FilterGroup`**: Allows grouping multiple `Filter` or even other `FilterGroup` instances using logical operators:
-  - `LogicalOperator.AND`: All conditions within the group must be met.
-  - `LogicalOperator.OR`: At least one condition within the group must be met.
-
-Filters are added to a `Criteria` using the `where()`, `andWhere()`, and `orWhere()` methods. The library automatically normalizes the structure of `FilterGroup` instances to maintain consistency.
+Filters are added to a `Criteria` using the `where()`, `andWhere()`, and `orWhere()` methods. The library automatically normalizes the `FilterGroup` structure to maintain consistency.
 
 [Back to Index](#index-of-core-concepts)
 
@@ -141,15 +203,15 @@ Filters are added to a `Criteria` using the `where()`, `andWhere()`, and `orWher
 Ordering defines how the query results should be sorted.
 
 - **`Order`**: Represents a single ordering rule. It consists of:
+- `field`: The field by which the results will be ordered. This field is strongly typed with the valid fields defined in the schema of each Criteria.
+- `direction`: The ordering direction (see `OrderDirection`).
+- `sequenceId`: (Internal) A unique, globally incrementing ID.
 
-  - `field`: The field by which the results will be ordered. This field is strongly typed with the valid fields defined in the schema of each Criteria.
-  - `direction`: The ordering direction (see `OrderDirection`).
-
-- **`OrderDirection`**: This is an enumeration with two possible values:
-  - `ASC`: Ascending order.
-  - `DESC`: Descending order.
+- **`OrderDirection`**: An enumeration with two possible values:
+- `ASC`: Ascending order.
+- `DESC`: Descending order.
 
-Multiple ordering rules can be added to a `Criteria` using the `orderBy()` method. The order in which they are added is significant, as it defines the sorting priority. Each `Order` also has an internal `sequenceId` that translators can use to maintain a stable order if necessary.
+Multiple ordering rules can be added to a `Criteria` using the `orderBy()` method.
 
 [Back to Index](#index-of-core-concepts)
 
@@ -157,42 +219,47 @@ Multiple ordering rules can be added to a `Criteria` using the `orderBy()` metho
 
 ## Pagination
 
-Pagination allows retrieving subsets of results, which is crucial for handling large amounts of data. The library supports two types of pagination:
+Pagination allows retrieving subsets of results, which is crucial for handling large amounts of data.
+
+### Offset-based Pagination
+
+This is the traditional way of paginating results.
+
+- **`setTake(count)`**: Specifies the maximum number of records to return (equivalent to SQL `LIMIT`).
+- **`setSkip(count)`**: Specifies the number of records to skip before starting to return results (equivalent to SQL `OFFSET`).
 
-- **Offset-based Pagination:**
+### Cursor-based Pagination
 
-  - `setTake(count)`: Specifies the maximum number of records to return (equivalent to `LIMIT`).
-  - `setSkip(count)`: Specifies the number of records to skip before starting to return results (equivalent to `OFFSET`).
+This method is generally more efficient and stable for large datasets, especially those that change frequently.
 
-- **Cursor-based Pagination:**
-  - `setCursor(cursorFilters, operator, order)`: Allows for more efficient and stable pagination, especially with frequently changing datasets.
-    - `cursorFilters`: An array of one or two `FilterPrimitive` objects (without the `operator`) that define the cursor values (e.g., the `created_at` and `uuid` of the last item from the previous page).
-    - `operator`: Must be `FilterOperator.GREATER_THAN` or `FilterOperator.LESS_THAN`, depending on the pagination direction.
-    - `order`: The direction (`OrderDirection`) in which the data is being ordered, which must match the main ordering of the `Criteria`.
-  - For cursor-based pagination to work correctly, the translator is responsible for
-    processing the cursor information (cursorFilters, operator, and order) and ensuring that the
-    necessary orderBy clauses are applied to the final query with appropriate priority, using the
-    fields defined in the cursor.
+- **`setCursor(cursorFilters, operator, order)`**: Configures cursor-based pagination.
+- `cursorFilters`: An array of one or two `FilterPrimitive` objects (without the `operator` property). These define the field(s) and value(s) of the last item from the previous page, which serve as the "cursor".
+- A single `FilterPrimitive` is used for simple cursor pagination (e.g., based on `created_at`).
+- Two `FilterPrimitive`s are used for composite cursor pagination (e.g., based on `created_at` and `uuid` as a tie-breaker).
+- `operator`: Must be `FilterOperator.GREATER_THAN` (for "next page" when ordering ASC) or `FilterOperator.LESS_THAN` (for "next page" when ordering DESC, or "previous page" when ordering ASC).
+- `order`: The `OrderDirection` that matches the primary sort order of the query.
 
 [Back to Index](#index-of-core-concepts)
 
 ---
 
-## Field Selection (setSelect, resetSelect)
+## Field Selection (`setSelect`, `resetSelect`)
 
-By default, when a `Criteria` is created (whether `RootCriteria` or a `JoinCriteria`), all fields defined in its associated schema will be selected. This behavior can be modified:
+By default, when a `Criteria` is created (whether `RootCriteria` or a `JoinCriteria`), all fields defined in its associated schema will be selected (`selectAll` is `true`). This behavior can be modified:
 
-- **`setSelect(fields: FieldOfSchema<TSchema>[])`**: Allows explicitly specifying an array
-  of fields to be selected, typed with the valid fields of that `Criteria` instance's schema. If `setSelect()` is called, only the provided fields will be selected.
+- **`setSelect(fields: FieldOfSchema<TSchema>[])`**:
+- Allows you to explicitly specify an array of fields to be selected. These fields must be valid according to the `Criteria`'s schema.
+- When `setSelect()` is called, `selectAll` becomes `false`.
+- **Important:** The `identifier_field` of the entity is **always implicitly included** in the selection if it's not already specified in the `fields` array. This ensures that the entity can always be uniquely identified. If an empty array `[]` is passed to `setSelect`, only the `identifier_field` will be selected.
 
-  - It is important to note that if `orderBy()` or `setCursor()` is used on fields not included in `setSelect()`, some translators (like the TypeORM translator) might automatically add those fields to the selection to ensure correct database functionality.
+- **`resetSelect()`**:
+- Reverts the selection behavior to the default: all fields from the schema for that `Criteria` instance will be selected (`selectAll` becomes `true`).
 
-- **`resetSelect()`**: Reverts to the default behavior of selecting all fields from the schema for that `Criteria` instance. This is useful if `setSelect()` was previously used and you want to select everything again.
+**Behavior in Joins:**
 
-- **Behavior in Joins:**
-  - If a `JoinCriteria` does not have `setSelect()` explicitly called, all its fields will be included in the main `SELECT` clause of the query, prefixed with the join's alias.
-  - If `setSelect()` is called on a `JoinCriteria`, only those selected fields from the join will be included.
+- If a `JoinCriteria` does not have `setSelect()` explicitly called, all its fields (as defined in its schema) will be included in the main `SELECT` clause of the query, typically prefixed with the join's alias.
+- If `setSelect()` is called on a `JoinCriteria`, only those selected fields (plus its `identifier_field`) from the joined entity will be included.
 
-This flexibility allows optimizing queries to retrieve only the necessary data.
+This flexibility allows optimizing queries to retrieve only the necessary data, reducing data transfer and processing overhead.
 
 [Back to Index](#index-of-core-concepts)
diff --git a/src/docs/core-concepts/es.md b/src/docs/core-concepts/es.md
index c506038..76244d0 100644
--- a/src/docs/core-concepts/es.md
+++ b/src/docs/core-concepts/es.md
@@ -1,41 +1,39 @@
 # Conceptos Clave de @nulledexp/translatable-criteria
 
-Esta sección profundiza en los componentes fundamentales que conforman la librería
-`@nulledexp/translatable-criteria`. Comprender estos conceptos es esencial para utilizar
-eficazmente la librería y extender su funcionalidad.
+Esta sección profundiza en los componentes fundamentales que conforman la librería `@nulledexp/translatable-criteria`. Comprender estos conceptos es esencial para utilizar eficazmente la librería y extender su funcionalidad.
 
 ## Índice de Conceptos Clave
 
 - **_[Jerarquía de Criteria](#jerarquía-de-criteria)_**
 - **_[CriteriaFactory](#criteriafactory)_**
 - **_[Esquemas `CriteriaSchema` y `GetTypedCriteriaSchema`](#esquemas-criteriaschema-y-gettypedcriteriaschema)_**
-- **_[CriteriaTranslator (`Clase Abstracta` y `Patrón Visitor`)](#criteriatranslator-clase-abstracta-y-patrón-visitor)_**
+  - [_Campo Identificador (`identifier_field`)_](#campo-identificador-identifier_field)
+  - [_Metadatos de Esquema y Join_](#metadatos-de-esquema-y-join)
+- **_[CriteriaTranslator (`Clase Abstracta`)](#criteriatranslator-clase-abstracta)_**
 - **_[Filtros (`Filter`, `FilterGroup`, `FilterOperator`)](#filtros-filter-filtergroup-filteroperator)_**
 - **_[Ordenamiento (`Order`, `OrderDirection`)](#ordenamiento-order-orderdirection)_**
 - **_[Paginación](#paginación)_**
+  - [_Paginación Basada en Offset_](#paginación-basada-en-offset)
+  - [_Paginación Basada en Cursor_](#paginación-basada-en-cursor)
 - **_[Selección de Campos (`setSelect`, `resetSelect`)](#selección-de-campos-setselect-resetselect)_**
 
 ---
 
 ## Jerarquía de `Criteria`
 
-La clase abstracta `Criteria` es la base para definir las especificaciones de una consulta.
-Representa un conjunto de condiciones, ordenamientos, uniones y configuraciones de paginación
-para una entidad o un conjunto de entidades relacionadas.
+La clase abstracta `Criteria` es la base para definir las especificaciones de una consulta. Representa un conjunto de condiciones, ordenamientos, uniones y configuraciones de paginación para una entidad o un conjunto de entidades relacionadas.
 
 Existen varias implementaciones concretas de `Criteria`:
 
-- **`RootCriteria`**: Representa el punto de partida de una consulta, dirigido a una entidad
-  principal.
+- **`RootCriteria`**: Representa el punto de partida de una consulta, dirigido a una entidad principal.
 - **`InnerJoinCriteria`**: Define una unión interna (INNER JOIN) con otra entidad.
 - **`LeftJoinCriteria`**: Define una unión externa izquierda (LEFT JOIN) con otra entidad.
-- **`OuterJoinCriteria`**: Define una unión externa completa (FULL OUTER JOIN) con otra
-  entidad (su disponibilidad puede depender del traductor específico).
+- **`OuterJoinCriteria`**: Define una unión externa completa (FULL OUTER JOIN) con otra entidad (su disponibilidad puede depender del traductor específico).
 
 Cada instancia de `Criteria` encapsula:
 
 - El esquema (`CriteriaSchema`) de la entidad a la que se aplica.
-- Un alias único para referenciar esta entidad en la consulta.
+- Un alias único y canónico para referenciar esta entidad en la consulta.
 - Gestores internos para filtros, uniones, ordenamiento y selección de campos.
 
 [Volver al Índice](#índice-de-conceptos-clave)
@@ -44,20 +42,24 @@ Cada instancia de `Criteria` encapsula:
 
 ## `CriteriaFactory`
 
-`CriteriaFactory` es una clase de utilidad que proporciona métodos estáticos para crear
-instancias de los diferentes tipos de `Criteria` (`RootCriteria`, `InnerJoinCriteria`, etc.).
+`CriteriaFactory` es una clase de utilidad que proporciona métodos estáticos para crear instancias de los diferentes tipos de `Criteria`.
 
 **Propósito:**
 
 - **Simplificar la creación:** Abstrae la complejidad de la instanciación directa.
-- **Asegurar la correcta inicialización:** Garantiza que los criterios se creen con los
-  parámetros necesarios y las validaciones iniciales.
-- **Mejorar la legibilidad:** Hace que el código de construcción de criterios sea más claro y
-  conciso.
+- **Asegurar la correcta inicialización:** Garantiza que los criterios se creen con los parámetros necesarios y las validaciones iniciales.
+- **Mejorar la legibilidad:** Hace que el código de construcción de criterios sea más claro y conciso.
 
 **Uso recomendado:**
-Se recomienda utilizar `CriteriaFactory` en lugar de instanciar las clases de
-`Criteria` directamente.
+Se recomienda encarecidamente utilizar `CriteriaFactory` en lugar de instanciar las clases de `Criteria` directamente. Los métodos de fábrica ya no requieren un parámetro de alias, ya que el alias canónico ahora se toma directamente del esquema.
+
+```typescript
+import { CriteriaFactory } from '@nulledexp/translatable-criteria';
+import { UserSchema, PostSchema } from './path/to/your/schemas';
+
+const userCriteria = CriteriaFactory.GetCriteria(UserSchema);
+const postJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(PostSchema);
+```
 
 [Volver al Índice](#índice-de-conceptos-clave)
 
@@ -65,62 +67,113 @@ Se recomienda utilizar `CriteriaFactory` en lugar de instanciar las clases de
 
 ## Esquemas (`CriteriaSchema` y `GetTypedCriteriaSchema`)
 
-Los esquemas son fundamentales para la seguridad de tipos y la validación en  
-`@nulledexp/translatable-criteria`. Un `CriteriaSchema` define la "forma" de tus entidades de datos tal como la librería las entiende.
+Los esquemas son fundamentales para la seguridad de tipos y la validación. Un `CriteriaSchema` define la "forma" de tus entidades de datos tal como la librería las entiende. Para una guía completa, consulta **Definición de Esquemas**.
 
 **¿Qué define un Esquema?**
 
 - `source_name`: El nombre real de la tabla o colección en la base de datos.
-- `alias`: Un array de posibles alias que se pueden usar para referirse a esta entidad en las
-  consultas.
-- `fields`: Un array con los nombres de los campos disponibles para esta entidad.
-- `joins`: Un array que define las posibles relaciones de unión con otros esquemas, incluyendo
-  el `alias` del join y el `join_relation_type` (ej. `one_to_many`, `many_to_one`,
-  `many_to_many`).
+- `alias`: Un **único alias canónico** para la entidad.
+- `fields`: Un array con los nombres de los campos disponibles.
+- `identifier_field`: Un campo **obligatorio** que identifica unívocamente una entidad.
+- `joins`: Un array que define las posibles relaciones de unión, cada una con su propio `alias` y `target_source_name`.
+- `metadata`: (Opcional) Un objeto para almacenar información arbitraria, específica del traductor o configuración relevante para toda la entidad que este esquema representa.
 
 **`GetTypedCriteriaSchema`:**
-Es una función helper que se utiliza para definir esquemas. Su principal ventaja es que preserva los
-tipos literales de los `fields` y `alias`, lo que permite un autocompletado y una validación de
-tipos más robusta al construir los criterios. Esto evita la necesidad de usar aserciones de tipo
-(como as const) en la definición del esquema, al tiempo que asegura que la estructura del esquema sea válida.
-Los esquemas se proporcionan al `CriteriaFactory` al crear instancias de `Criteria`, permitiendo
-que la librería valide que los campos, alias y uniones utilizados sean correctos.
+Es una función helper que se utiliza para definir esquemas. Su principal ventaja es que preserva los tipos literales de los `fields`, `alias` e `identifier_field`, lo que permite un autocompletado y una validación de tipos más robusta al construir los criterios. Esto evita la necesidad de usar aserciones de tipo (como `as const`) en la definición del esquema, al tiempo que asegura que la estructura del esquema (incluyendo la validez de `identifier_field`) sea correcta.
 
-[Volver al Índice](#índice-de-conceptos-clave)
+Los esquemas se proporcionan al `CriteriaFactory` al crear instancias de `Criteria`, permitiendo que la librería valide que los campos, alias y uniones utilizados sean correctos.
 
----
+### Campo Identificador (`identifier_field`)
 
-## `CriteriaTranslator` (Clase Abstracta y Patrón Visitor)
+El `identifier_field` es una propiedad **obligatoria** en tu `CriteriaSchema`. Especifica qué campo de tu array `fields` sirve como identificador único (clave primaria) para esa entidad.
 
-El `CriteriaTranslator` es el corazón del mecanismo de traducción. Es una clase abstracta
-diseñada para ser extendida por implementaciones concretas que convertirán un objeto `Criteria`
-(agnóstico a la fuente de datos) en una consulta específica para una base de datos o motor de  
-búsqueda particular (ej. SQL, una query de TypeORM, una consulta de MongoDB, etc.).
+**Propósito:**
 
-**Rol Principal:**
+- **Identificación Única:** Designa claramente el campo de clave primaria.
+- **Validación Mejorada:** La librería valida en tiempo de compilación (y ejecución) que el `identifier_field` que especificas es realmente uno de los `fields` definidos en el esquema.
+- **Selección Automática:** Al usar `setSelect()` para elegir campos específicos, el `identifier_field` de la entidad **siempre se incluye implícitamente** en la selección, asegurando que la entidad siempre pueda ser identificada unívocamente.
+- **Contexto para Traductores:** El identificador de una entidad padre se pasa al traductor durante las operaciones de unión (`parent_identifier`), lo que puede usarse para una inferencia de relaciones más avanzada.
+
+```typescript
+import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
+
+export const UserSchema = GetTypedCriteriaSchema({
+  source_name: 'users',
+  alias: 'u',
+  fields: ['id', 'username', 'email', 'age', 'isActive', 'createdAt', 'tags'],
+  identifier_field: 'id',
+  joins: [
+    {
+      alias: 'posts',
+      target_source_name: 'posts',
+      relation_type: 'one_to_many',
+    },
+  ],
+});
+```
+
+### Metadatos de Esquema y Join
+
+Tanto la raíz de un `CriteriaSchema` como las configuraciones individuales de join dentro del array `joins` pueden tener una propiedad `metadata` opcional.
+
+- **`CriteriaSchema.metadata`**: Para información relevante para toda la entidad.
+- **`SchemaJoins.metadata`**: Para información específica de una relación de join particular.
+
+**Propósito para el Usuario:**
+Este campo `metadata` es un objeto flexible y abierto (`{ [key: string]: any }`) diseñado para contener información arbitraria que podría ser necesaria para un `CriteriaTranslator` específico que estés utilizando.
+
+**Cómo Usar:**
+Puedes añadir cualquier par clave-valor al objeto `metadata`. Las claves y valores específicos que son significativos dependen enteramente del `CriteriaTranslator` que estés usando. Consulta la documentación de tu traductor para entender qué `metadata` (si alguna) reconoce y utiliza.
+
+```typescript
+import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
+
+export const PostSchema = GetTypedCriteriaSchema({
+  source_name: 'posts',
+  alias: 'p',
+  fields: [
+    'id',
+    'title',
+    'content',
+    'userId',
+    'createdAt',
+    'categories',
+    'metadata',
+  ],
+  identifier_field: 'id',
+  metadata: {
+    custom_handler: 'specialPostHandler',
+    versioning_enabled: true,
+  },
+  joins: [
+    {
+      alias: 'user',
+      target_source_name: 'users',
+      relation_type: 'many_to_one',
+      metadata: {
+        typeorm_lazy_load: false,
+        custom_on_clause_template: 'user.id = post.userId_custom_fk',
+      },
+    },
+  ],
+});
+```
 
-- Procesar un objeto `Criteria` (comenzando típicamente por un `RootCriteria`).
-- "Visitar" cada parte del `Criteria` (filtros, joins, ordenamiento, etc.).
-- Generar la sintaxis de consulta nativa correspondiente.
+[Volver al Índice](#índice-de-conceptos-clave)
 
-**Patrón Visitor:**
-La librería utiliza el patrón de diseño Visitor.
+---
 
-- Cada clase de `Criteria` (y sus componentes como `FilterGroup`, `Filter`) tiene un método `accept(visitor, ...args)`.
-- El `CriteriaTranslator` implementa la interfaz `ICriteriaVisitor`, que define métodos `visit...
-` para cada tipo de elemento que puede encontrar (ej. `visitRootCriteria`, `visitInnerJoinCriteria`, `visitFilter`, `visitAndGroup`).
+## `CriteriaTranslator` (Clase Abstracta)
 
-Cuando se llama a `criteria.accept(translator, ...)`:
+El `CriteriaTranslator` es el componente responsable de convertir un objeto `Criteria` (agnóstico a la fuente de datos) en una consulta específica para una base de datos o motor de búsqueda particular (ej. SQL, una query de TypeORM, una consulta de MongoDB, etc.).
 
-1.  El `criteria` invoca el método `visit...` apropiado en el `translator`, pasándose a sí mismo como argumento.
-2.  El `translator` ejecuta la lógica específica para traducir ese tipo de `criteria` o componente.
+**Rol Principal:**
 
-Esto permite una arquitectura limpia y extensible: la lógica de construcción de `Criteria` está
-separada de la lógica de traducción. Para soportar una nueva base de datos, solo necesitas crear
-un nuevo traductor que extienda `CriteriaTranslator`.
+- Procesar un objeto `Criteria` (comenzando típicamente por un `RootCriteria`).
+- Interpretar los filtros, uniones, ordenamiento, paginación y selección definidos en el `Criteria`.
+- Generar la sintaxis de consulta nativa correspondiente.
 
-Los traductores concretos (como `@nulledexp/typeorm-mysql-translator`) se proporcionan como
-paquetes separados.
+Esto permite una arquitectura limpia y extensible: la lógica de construcción de `Criteria` está separada de la lógica de traducción. Para soportar una nueva base de datos, solo necesitas crear un nuevo traductor que extienda `CriteriaTranslator`.
 
 [Volver al Índice](#índice-de-conceptos-clave)
 
@@ -130,31 +183,14 @@ paquetes separados.
 
 Los filtros permiten especificar las condiciones que deben cumplir los datos para ser seleccionados.
 
-- **`Filter`**: Representa una condición de filtro individual. Se compone de:
-
-  - `field`: El campo sobre el que se aplica el filtro. Este campo está fuertemente tipado con
-    los campos válidos definidos en el esquema de cada Criteria.
-  - `operator`: El operador de comparación (ver `FilterOperator`).
-  - `value`: El valor con el que se compara el campo. El tipo de este valor está estrictamente tipado según el `operator` utilizado.
-
-- **`FilterOperator`**: Es una enumeración que define los diversos operadores de comparación disponibles, tales como:
-
-  - Igualdad: `EQUALS`, `NOT_EQUALS`
-  - Comparación: `GREATER_THAN`, `LESS_THAN`, `GREATER_THAN_OR_EQUALS`, `LESS_THAN_OR_EQUALS`
-  - Patrones: `LIKE`, `NOT_LIKE`, `CONTAINS`, `NOT_CONTAINS`, `STARTS_WITH`, `ENDS_WITH`
-  - Pertenencia: `IN`, `NOT_IN`
-  - Nulidad: `IS_NULL`, `IS_NOT_NULL`
-  - Para rangos: `BETWEEN`, `NOT_BETWEEN`
-  - Para expresiones regulares: `MATCHES_REGEX`
-  - Para patrones insensibles a mayúsculas/minúsculas: `ILIKE`, `NOT_ILIKE`
-  - Para campos tipo SET (o equivalentes): `SET_CONTAINS`, `SET_NOT_CONTAINS`
-  - Para campos tipo SET (o equivalentes) con múltiples valores: `SET_CONTAINS_ANY`, `SET_CONTAINS_ALL`
-  - Para campos JSON: `JSON_CONTAINS`, `JSON_NOT_CONTAINS`
-  - Para campos Array: `ARRAY_CONTAINS_ELEMENT`, `ARRAY_CONTAINS_ALL_ELEMENTS`, `ARRAY_CONTAINS_ANY_ELEMENT`, `ARRAY_EQUALS`
-
-- **`FilterGroup`**: Permite agrupar múltiples `Filter` o incluso otros `FilterGroup` utilizando operadores lógicos:
-  - `LogicalOperator.AND`: Todas las condiciones dentro del grupo deben cumplirse.
-  - `LogicalOperator.OR`: Al menos una de las condiciones dentro del grupo debe cumplirse.
+- **`Filter`**: Representa una condición de filtro individual (`field`, `operator`, `value`).
+- **`FilterGroup`**: Permite agrupar múltiples `Filter` o incluso otros `FilterGroup` utilizando operadores lógicos (`AND` u `OR`).
+- **`FilterOperator`**: Es una enumeración que define los diversos operadores de comparación disponibles, que se pueden clasificar a grandes rasgos:
+- **Igualdad y Comparación:** `EQUALS`, `NOT_EQUALS`, `GREATER_THAN`, `LESS_THAN`, etc.
+- **Coincidencia de Patrones:** `LIKE`, `CONTAINS`, `STARTS_WITH`, `ILIKE` (versión de LIKE insensible a mayúsculas/minúsculas).
+- **Pertenencia y Nulidad:** `IN`, `NOT_IN`, `IS_NULL`, `IS_NOT_NULL`.
+- **Rangos y Regex:** `BETWEEN`, `NOT_BETWEEN`, `MATCHES_REGEX`.
+- **Tipos Complejos:** Un amplio conjunto de operadores para tipos de datos `JSON`, `ARRAY` y `SET` (ej. `JSON_CONTAINS`, `ARRAY_CONTAINS_ANY_ELEMENT`).
 
 Los filtros se añaden a un `Criteria` usando los métodos `where()`, `andWhere()`, y `orWhere()`. La librería normaliza automáticamente la estructura de los `FilterGroup` para mantener la consistencia.
 
@@ -167,16 +203,15 @@ Los filtros se añaden a un `Criteria` usando los métodos `where()`, `andWhere(
 El ordenamiento define cómo se deben clasificar los resultados de la consulta.
 
 - **`Order`**: Representa una regla de ordenamiento individual. Se compone de:
-
-  - `field`: El campo por el cual se ordenarán los resultados. Este campo está fuertemente
-    tipado con los campos válidos definidos en el esquema de cada Criteria.
-  - `direction`: La dirección del ordenamiento (ver `OrderDirection`).
+- `field`: El campo por el cual se ordenarán los resultados. Este campo está fuertemente tipado con los campos válidos definidos en el esquema de cada Criteria.
+- `direction`: La dirección del ordenamiento (ver `OrderDirection`).
+- `sequenceId`: (Interno) Un ID único e incremental globalmente.
 
 - **`OrderDirection`**: Es una enumeración con dos posibles valores:
-  - `ASC`: Orden ascendente.
-  - `DESC`: Orden descendente.
+- `ASC`: Orden ascendente.
+- `DESC`: Orden descendente.
 
-Se pueden añadir múltiples reglas de ordenamiento a un `Criteria` usando el método `orderBy()`. El orden en que se añaden es significativo, ya que define la prioridad del ordenamiento. Cada `Order` también tiene un `sequenceId` interno que los traductores pueden usar para mantener un orden estable si es necesario.
+Se pueden añadir múltiples reglas de ordenamiento a un `Criteria` usando el método `orderBy()`.
 
 [Volver al Índice](#índice-de-conceptos-clave)
 
@@ -184,44 +219,47 @@ Se pueden añadir múltiples reglas de ordenamiento a un `Criteria` usando el m
 
 ## Paginación
 
-La paginación permite recuperar subconjuntos de resultados, lo cual es crucial para manejar grandes cantidades de datos. La librería soporta dos tipos de paginación:
+La paginación permite recuperar subconjuntos de resultados, lo cual es crucial para manejar grandes cantidades de datos.
+
+### Paginación Basada en Offset
+
+Esta es la forma tradicional de paginar resultados.
+
+- **`setTake(count)`**: Especifica el número máximo de registros a devolver (equivalente a SQL `LIMIT`).
+- **`setSkip(count)`**: Especifica el número de registros a omitir antes de empezar a devolver resultados (equivalente a SQL `OFFSET`).
 
-- **Paginación basada en Offset:**
+### Paginación Basada en Cursor
 
-  - `setTake(count)`: Especifica el número máximo de registros a devolver (equivalente a `LIMIT`).
-  - `setSkip(count)`: Especifica el número de registros a omitir antes de empezar a devolver resultados (equivalente a `OFFSET`).
+Este método es generalmente más eficiente y estable para grandes conjuntos de datos, especialmente aquellos que cambian frecuentemente.
 
-- **Paginación basada en Cursor:**
-  - `setCursor(cursorFilters, operator, order)`: Permite una paginación más eficiente y estable, especialmente con conjuntos de datos que cambian frecuentemente.
-    - `cursorFilters`: Un array de uno o dos objetos `FilterPrimitive` (sin el `operator`) que definen los valores del cursor (ej. el `created_at` y el `uuid` del último ítem de la página anterior).
-    - `operator`: Debe ser `FilterOperator.GREATER_THAN` o `FilterOperator.LESS_THAN`, dependiendo de la dirección de paginación.
-    - `order`: La dirección (`OrderDirection`) en la que se está ordenando, que debe coincidir con el ordenamiento principal del `Criteria`.
-  - Para que la paginación por cursor funcione correctamente, el traductor es responsable de
-    procesar la información del cursor (cursorFilters, operator y order) y asegurar que los
-    orderBy necesarios se apliquen a la consulta final con la prioridad adecuada, utilizando los
-    campos definidos en el cursor.
+- **`setCursor(cursorFilters, operator, order)`**: Configura la paginación basada en cursor.
+- `cursorFilters`: Un array de uno o dos objetos `FilterPrimitive` (sin la propiedad `operator`). Estos definen el/los campo(s) y valor(es) del último ítem de la página anterior, que sirven como "cursor".
+- Un solo `FilterPrimitive` se usa para paginación por cursor simple (ej., basada en `created_at`).
+- Dos `FilterPrimitive` se usan para paginación por cursor compuesta (ej., basada en `created_at` y `uuid` como desempate).
+- `operator`: Debe ser `FilterOperator.GREATER_THAN` (para "página siguiente" al ordenar ASC) o `FilterOperator.LESS_THAN` (para "página siguiente" al ordenar DESC, o "página anterior" al ordenar ASC).
+- `order`: La `OrderDirection` que coincide con el orden de clasificación principal de la consulta.
 
 [Volver al Índice](#índice-de-conceptos-clave)
 
 ---
 
-## Selección de Campos (setSelect, resetSelect)
+## Selección de Campos (`setSelect`, `resetSelect`)
 
-Por defecto, cuando se crea un `Criteria` (ya sea `RootCriteria` o un `JoinCriteria`), se seleccionarán todos los campos definidos en su esquema asociado. Este comportamiento se puede modificar:
+Por defecto, cuando se crea un `Criteria` (ya sea `RootCriteria` o un `JoinCriteria`), se seleccionarán todos los campos definidos en su esquema asociado (`selectAll` es `true`). Este comportamiento se puede modificar:
 
-- **`setSelect(fields: FieldOfSchema<TSchema>[])`**: Permite especificar explícitamente un array
-  de campos que se deben seleccionar tipado con los field
-  validos del esquema de esa instancia de `Criteria`. Si se llama a `setSelect()`, solo se seleccionarán los campos
-  proporcionados.
+- **`setSelect(fields: FieldOfSchema<TSchema>[])`**:
+- Permite especificar explícitamente un array de campos que se deben seleccionar. Estos campos deben ser válidos según el esquema del `Criteria`.
+- Cuando se llama a `setSelect()`, `selectAll` se vuelve `false`.
+- **Importante:** El `identifier_field` de la entidad **siempre se incluye implícitamente** en la selección si no está ya especificado en el array `fields`. Esto asegura que la entidad siempre pueda ser identificada unívocamente. Si se pasa un array vacío `[]` a `setSelect`, solo se seleccionará el `identifier_field`.
 
-  - Es importante notar que si se utiliza `orderBy()` o `setCursor()` sobre campos que no están incluidos en `setSelect()`, algunos traductores (como el de TypeORM) podrían añadir automáticamente esos campos a la selección para asegurar el correcto funcionamiento de la base de datos.
+- **`resetSelect()`**:
+- Revierte el comportamiento de selección al predeterminado: se seleccionarán todos los campos del esquema para esa instancia de `Criteria` (`selectAll` se vuelve `true`).
 
-- **`resetSelect()`**: Revierte al comportamiento por defecto de seleccionar todos los campos del esquema para esa instancia de `Criteria`. Esto es útil si previamente se usó `setSelect()` y se desea volver a seleccionar todo.
+**Comportamiento en Joins:**
 
-- **Comportamiento en Joins:**
-  - Si un `JoinCriteria` no tiene `setSelect()` llamado explícitamente, todos sus campos se incluirán en la cláusula `SELECT` principal de la consulta, prefijados con el alias del join.
-  - Si se llama a `setSelect()` en un `JoinCriteria`, solo esos campos seleccionados del join se incluirán.
+- Si un `JoinCriteria` no tiene `setSelect()` llamado explícitamente, todos sus campos (definidos en su esquema) se incluirán en la cláusula `SELECT` principal de la consulta, típicamente prefijados con el alias del join.
+- Si se llama a `setSelect()` en un `JoinCriteria`, solo esos campos seleccionados (más su `identifier_field`) de la entidad unida se incluirán.
 
-Esta flexibilidad permite optimizar las consultas para recuperar solo los datos necesarios.
+Esta flexibilidad permite optimizar las consultas para recuperar solo los datos necesarios, reduciendo la transferencia de datos y la sobrecarga de procesamiento.
 
 [Volver al Índice](#índice-de-conceptos-clave)
diff --git a/src/docs/guides/building-criteria/en.md b/src/docs/guides/building-criteria/en.md
index a099fac..572231f 100644
--- a/src/docs/guides/building-criteria/en.md
+++ b/src/docs/guides/building-criteria/en.md
@@ -12,11 +12,12 @@ This guide will show you how to use `CriteriaFactory` and the fluent methods of
   - [Logical Grouping (AND/OR)](#logical-grouping-andor)
   - [Advanced Filters (JSON, Array, Set)](#advanced-filters-json-array-set)
     - [Filtering JSON Fields (`JSON_CONTAINS`, `JSON_NOT_CONTAINS`)](#filtering-json-fields-json_contains-json_not_contains)
-    - [Filtering Array Fields (`ARRAY_CONTAINS_ELEMENT`, etc.)](#filtering-array-fields-array_contains_element-array_contains_all_elements-array_contains_any_element-array_equals)
+    - [Filtering Array Fields (`ARRAY_CONTAINS_ELEMENT`, etc.)](#filtering-array-fields-array_contains_element-etc)
     - [Filtering SET Fields (`SET_CONTAINS`, `SET_NOT_CONTAINS`, `SET_CONTAINS_ANY`, `SET_CONTAINS_ALL`)](#filtering-set-fields-set_contains-set_not_contains-set_contains_any-set_contains_all)
     - [Filtering by Ranges (`BETWEEN`, `NOT_BETWEEN`)](#filtering-by-ranges-between-not_between)
     - [Filtering with Regular Expressions (`MATCHES_REGEX`)](#filtering-with-regular-expressions-matches_regex)
     - [Case-Insensitive Pattern Matching (`ILIKE`, `NOT_ILIKE`)](#case-insensitive-pattern-matching-ilike-not_ilike)
+  - [Filter Operator Reference](#filter-operator-reference)
 - 3. [Adding Joins](#3-adding-joins)
   - [Simple Joins (one-to-many, many-to-one, one-to-one)](#simple-joins-one-to-many-many-to-one-one-to-one)
   - [Joins with Pivot Table (many-to-many)](#joins-with-pivot-table-many-to-many)
@@ -36,23 +37,86 @@ This guide will show you how to use `CriteriaFactory` and the fluent methods of
 
 ---
 
+## Example Schemas
+
+To make the examples in this guide self-contained, we will use the following simplified schemas:
+
+```typescript
+import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
+
+export const UserSchema = GetTypedCriteriaSchema({
+  source_name: 'users',
+  alias: 'u',
+  fields: ['id', 'username', 'email', 'age', 'isActive', 'createdAt', 'tags'],
+  identifier_field: 'id',
+  joins: [
+    {
+      alias: 'posts',
+      target_source_name: 'posts',
+      relation_type: 'one_to_many',
+    },
+    {
+      alias: 'roles',
+      target_source_name: 'roles',
+      relation_type: 'many_to_many',
+    },
+  ],
+});
+
+export const PostSchema = GetTypedCriteriaSchema({
+  source_name: 'posts',
+  alias: 'p',
+  fields: [
+    'id',
+    'title',
+    'content',
+    'userId',
+    'createdAt',
+    'categories',
+    'metadata',
+  ],
+  identifier_field: 'id',
+  joins: [
+    {
+      alias: 'user',
+      target_source_name: 'users',
+      relation_type: 'many_to_one',
+    },
+  ],
+});
+
+export const RoleSchema = GetTypedCriteriaSchema({
+  source_name: 'roles',
+  alias: 'r',
+  fields: ['id', 'name'],
+  identifier_field: 'id',
+  joins: [],
+});
+
+export const ProductSchema = GetTypedCriteriaSchema({
+  source_name: 'products',
+  alias: 'prod',
+  fields: ['id', 'name', 'price', 'createdAt'],
+  identifier_field: 'id',
+  joins: [],
+});
+```
+
+---
+
 ## 1. Creating a `RootCriteria`
 
-Every query starts with a `RootCriteria`, which represents the main entity from which the query will begin. It is created using `CriteriaFactory.GetCriteria()`:
+Every query starts with a `RootCriteria`, which represents the main entity from which the query will begin. It is created using `CriteriaFactory.GetCriteria()`. The alias is now taken directly from the `alias` property of the provided schema.
 
 ```typescript
 import { CriteriaFactory } from '@nulledexp/translatable-criteria';
-import { UserSchema, PostSchema } from './path/to/your/schemas'; // Ensure the path is correct
-
-// Create Criteria for the User entity, using the 'users' alias
-const userCriteria = CriteriaFactory.GetCriteria(UserSchema, 'users');
+import { UserSchema, PostSchema } from './path/to/your/schemas';
 
-// Create Criteria for the Post entity, using the 'posts' alias
-const postCriteria = CriteriaFactory.GetCriteria(PostSchema, 'posts');
+const userCriteria = CriteriaFactory.GetCriteria(UserSchema);
+const postCriteria = CriteriaFactory.GetCriteria(PostSchema);
 ```
 
-- The first argument is the entity's schema (`UserSchema`, `PostSchema`).
-- The second argument is one of the aliases defined in the `alias` array of that schema. Using the correct alias is crucial for proper interpretation by translators.
+---
 
 ## 2. Applying Filters
 
@@ -61,25 +125,26 @@ Filters are added using the `where()`, `andWhere()`, and `orWhere()` methods. Th
 ### Basic Filters
 
 ```typescript
-import { FilterOperator } from '@nulledexp/translatable-criteria';
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { UserSchema, PostSchema } from './path/to/your/schemas';
 
-// Find users with a specific email
-userCriteria.where({
-  field: 'email', // Field from UserSchema
+const userEmailCriteria = CriteriaFactory.GetCriteria(UserSchema).where({
+  field: 'email',
   operator: FilterOperator.EQUALS,
   value: 'test@example.com',
 });
 
-// Find posts whose title contains "TypeScript"
-postCriteria.where({
-  field: 'title', // Field from PostSchema
-  operator: FilterOperator.CONTAINS, // or FilterOperator.LIKE with '%'
-  value: '%TypeScript%',
+const postTitleCriteria = CriteriaFactory.GetCriteria(PostSchema).where({
+  field: 'title',
+  operator: FilterOperator.CONTAINS,
+  value: 'TypeScript',
 });
 
-// Find posts created after a specific date
-postCriteria.where({
-  field: 'created_at',
+const postDateCriteria = CriteriaFactory.GetCriteria(PostSchema).where({
+  field: 'createdAt',
   operator: FilterOperator.GREATER_THAN,
   value: new Date('2023-01-01'),
 });
@@ -91,8 +156,13 @@ postCriteria.where({
 - `orWhere()`: Adds a condition that, if met, makes the filter group true, even if previous conditions (grouped by AND) are not (logical OR). The library normalizes this to maintain a structure of `OR ( (cond1 AND cond2), (cond3) )`.
 
 ```typescript
-// Users whose username is 'admin' AND their email contains '@example.com'
-userCriteria
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { UserSchema, PostSchema } from './path/to/your/schemas';
+
+const adminUserCriteria = CriteriaFactory.GetCriteria(UserSchema)
   .where({ field: 'username', operator: FilterOperator.EQUALS, value: 'admin' })
   .andWhere({
     field: 'email',
@@ -100,22 +170,19 @@ userCriteria
     value: '@example.com',
   });
 
-// Posts that contain "Tutorial" in the title OR in the post body
-postCriteria
+const tutorialPostCriteria = CriteriaFactory.GetCriteria(PostSchema)
   .where({
     field: 'title',
     operator: FilterOperator.CONTAINS,
     value: 'Tutorial',
   })
   .orWhere({
-    field: 'body',
+    field: 'content',
     operator: FilterOperator.CONTAINS,
     value: 'Tutorial',
   });
 
-// More complex combination:
-// (username = 'editor' AND email LIKE '%@editor.com%') OR (username = 'guest')
-userCriteria
+const editorOrGuestCriteria = CriteriaFactory.GetCriteria(UserSchema)
   .where({
     field: 'username',
     operator: FilterOperator.EQUALS,
@@ -123,8 +190,8 @@ userCriteria
   })
   .andWhere({
     field: 'email',
-    operator: FilterOperator.LIKE,
-    value: '%@editor.com%',
+    operator: FilterOperator.CONTAINS,
+    value: '@editor.com',
   })
   .orWhere({
     field: 'username',
@@ -135,38 +202,31 @@ userCriteria
 
 ### Advanced Filters (JSON, Array, Set)
 
-The library supports operators for more complex data types like JSON, arrays, and SET-type fields.
+The library supports a wide range of operators for complex data types. For a full list, see the Core Concepts guide. Here are a few examples:
 
 #### Filtering JSON Fields (`JSON_CONTAINS`, `JSON_NOT_CONTAINS`)
 
 The value for these operators is an object where keys are JSON paths (the translator will determine if it needs `$.` at the beginning) and values are what is being searched for in that path.
 
 ```typescript
-// Assuming PostSchema has a 'metadata' field of JSON type
-// with a structure like: { tags: ["tech", "code"], views: 100 }
-
-// Find posts where metadata.tags contains "tech" AND metadata.views is 100
-postCriteria.where({
-  field: 'metadata', // The JSON field
-  operator: FilterOperator.JSON_CONTAINS,
-  value: {
-    tags: 'tech', // Searches for "tech" within the metadata.tags array
-    views: 100, // Searches for metadata.views to be 100
-    // "extra.source": "import" // You can also nest paths
-  },
-});
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema } from './path/to/your/schemas';
 
-// Find posts where metadata.extra.quality IS NOT "low"
-postCriteria.where({
+const jsonCriteria = CriteriaFactory.GetCriteria(PostSchema).where({
   field: 'metadata',
-  operator: FilterOperator.JSON_NOT_CONTAINS,
+  operator: FilterOperator.JSON_CONTAINS,
   value: {
-    'extra.quality': 'low',
+    tags: 'tech',
+    views: 100,
+    'extra.source': 'import',
   },
 });
 ```
 
-#### Filtering Array Fields (`ARRAY_CONTAINS_ELEMENT`, `ARRAY_CONTAINS_ALL_ELEMENTS`, `ARRAY_CONTAINS_ANY_ELEMENT`, `ARRAY_EQUALS`)
+#### Filtering Array Fields (`ARRAY_CONTAINS_ELEMENT`, etc.)
 
 These operators can be used for fields that are native arrays or arrays within JSON.
 
@@ -174,39 +234,16 @@ These operators can be used for fields that are native arrays or arrays within J
 - **For arrays within JSON:** The `value` is an object with a single key (the JSON path to the array) and the value is the element or array of elements.
 
 ```typescript
-// 1. Native Array Column: Find posts that have the "TypeScript" category
-postCriteria.where({
-  field: 'categories',
-  operator: FilterOperator.ARRAY_CONTAINS_ELEMENT,
-  value: 'TypeScript',
-});
-
-// 2. Array within JSON: Find posts where metadata.tags contains "typeorm"
-postCriteria.where({
-  field: 'metadata', // Main JSON field
-  operator: FilterOperator.ARRAY_CONTAINS_ELEMENT,
-  value: { tags: 'typeorm' }, // { "path.to.array": element }
-});
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema } from './path/to/your/schemas';
 
-// 3. Native Array Column: Find posts that have ALL categories ["nestjs", "api"]
-postCriteria.where({
+const arrayCriteria = CriteriaFactory.GetCriteria(PostSchema).where({
   field: 'categories',
-  operator: FilterOperator.ARRAY_CONTAINS_ALL_ELEMENTS,
-  value: ['nestjs', 'api'],
-});
-
-// 4. Array within JSON: Find posts where metadata.ratings contains AT LEAST ONE of [4, 5]
-postCriteria.where({
-  field: 'metadata',
   operator: FilterOperator.ARRAY_CONTAINS_ANY_ELEMENT,
-  value: { ratings: [4, 5] },
-});
-
-// 5. Native Array Column: Find posts whose categories are EXACTLY ["news", "updates"] (order matters)
-postCriteria.where({
-  field: 'categories',
-  operator: FilterOperator.ARRAY_EQUALS,
-  value: ['news', 'updates'],
+  value: ['nestjs', 'api'],
 });
 ```
 
@@ -215,28 +252,16 @@ postCriteria.where({
 Similar to `CONTAINS` but conceptually for fields representing a set of values (like MySQL's `SET` type or a delimited string).
 
 ```typescript
-// Assuming a 'flags' field in UserSchema which is a SET('active', 'verified', 'beta_tester')
-// or a text field 'tags' like "typescript,javascript,nodejs"
-
-// Find users who have the 'verified' flag
-userCriteria.where({
-  field: 'flags',
-  operator: FilterOperator.SET_CONTAINS,
-  value: 'verified',
-});
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { UserSchema } from './path/to/your/schemas';
 
-// Find users who have AT LEAST ONE of the tags "typescript" or "javascript"
-userCriteria.where({
+const setCriteria = CriteriaFactory.GetCriteria(UserSchema).where({
   field: 'tags',
   operator: FilterOperator.SET_CONTAINS_ANY,
-  value: ['typescript', 'javascript'], // Expects an array of values
-});
-
-// Find users who have ALL the flags "active" AND "beta_tester"
-userCriteria.where({
-  field: 'flags',
-  operator: FilterOperator.SET_CONTAINS_ALL,
-  value: ['active', 'beta_tester'], // Expects an array of values
+  value: ['typescript', 'javascript'],
 });
 ```
 
@@ -245,15 +270,21 @@ userCriteria.where({
 These operators allow you to check if a numeric or date value falls within or outside a specific range.
 
 ```typescript
-// Find posts created between two dates
-postCriteria.where({
-  field: 'created_at',
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema, ProductSchema } from './path/to/your/schemas';
+
+const betweenDatesCriteria = CriteriaFactory.GetCriteria(PostSchema).where({
+  field: 'createdAt',
   operator: FilterOperator.BETWEEN,
-  value: [new Date('2023-01-01'), new Date('2023-03-31')], // [min, max]
+  value: [new Date('2023-01-01'), new Date('2023-03-31')],
 });
 
-// Find products whose price IS NOT between 100 and 200
-productCriteria.where({
+const notBetweenPriceCriteria = CriteriaFactory.GetCriteria(
+  ProductSchema,
+).where({
   field: 'price',
   operator: FilterOperator.NOT_BETWEEN,
   value: [100, 200],
@@ -265,12 +296,16 @@ productCriteria.where({
 Allows for more powerful pattern matching using regular expressions. The specific syntax of the regular expression may depend on the underlying database.
 
 ```typescript
-// Find users whose username starts with "admin" followed by numbers
-// (conceptual example, REGEX syntax varies)
-userCriteria.where({
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { UserSchema } from './path/to/your/schemas';
+
+const regexCriteria = CriteriaFactory.GetCriteria(UserSchema).where({
   field: 'username',
   operator: FilterOperator.MATCHES_REGEX,
-  value: '^admin[0-9]+', // The regular expression as a string
+  value: '^admin[0-9]+',
 });
 ```
 
@@ -279,109 +314,162 @@ userCriteria.where({
 Similar to `LIKE` and `NOT_LIKE`, but they ensure that pattern comparison is case-insensitive, regardless of the database's default collation.
 
 ```typescript
-// Find posts whose title contains "typescript" (case-insensitive)
-postCriteria.where({
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema } from './path/to/your/schemas';
+
+const ilikeCriteria = CriteriaFactory.GetCriteria(PostSchema).where({
   field: 'title',
   operator: FilterOperator.ILIKE,
   value: '%typescript%',
 });
-
-// Find users whose email DOES NOT start with "test" (case-insensitive)
-userCriteria.where({
-  field: 'email',
-  operator: FilterOperator.NOT_ILIKE,
-  value: 'test%',
-});
 ```
 
+### Filter Operator Reference
+
+Here is a detailed list of the available `FilterOperator` values and the type of `value` they expect.
+
+#### Equality & Comparison
+
+- `EQUALS`: Checks for exact equality. Expects a primitive value (`string`, `number`, `boolean`, `Date`, `null`).
+- `NOT_EQUALS`: Checks for inequality. Expects a primitive value.
+- `GREATER_THAN`: Checks if a value is greater than the provided one. Expects a `number` or `Date`.
+- `GREATER_THAN_OR_EQUALS`: Checks if a value is greater than or equal to the provided one. Expects a `number` or `Date`.
+- `LESS_THAN`: Checks if a value is less than the provided one. Expects a `number` or `Date`.
+- `LESS_THAN_OR_EQUALS`: Checks if a value is less than or equal to the provided one. Expects a `number` or `Date`.
+
+#### Pattern Matching
+
+- `LIKE`: Matches a pattern (case-sensitivity depends on the database). Expects a `string`. The translator is responsible for handling wildcards (`%`, `_`).
+- `NOT_LIKE`: Checks if a value does not match a pattern. Expects a `string`.
+- `CONTAINS`: Checks if a string contains a substring. Expects a `string`. The translator will typically wrap the value with wildcards (e.g., `'%value%'`).
+- `NOT_CONTAINS`: Checks if a string does not contain a substring. Expects a `string`.
+- `STARTS_WITH`: Checks if a string starts with a specific substring. Expects a `string`. The translator will typically append a wildcard (e.g., `'value%'`).
+- `ENDS_WITH`: Checks if a string ends with a specific substring. Expects a `string`. The translator will typically prepend a wildcard (e.g., `'%value'`).
+- `ILIKE`: Case-insensitive version of `LIKE`. Expects a `string`.
+- `NOT_ILIKE`: Case-insensitive version of `NOT_LIKE`. Expects a `string`.
+
+#### Membership & Nullability
+
+- `IN`: Checks if a value is within a given array. Expects an `Array<string | number | boolean | Date>`.
+- `NOT_IN`: Checks if a value is not within a given array. Expects an `Array<string | number | boolean | Date>`.
+- `IS_NULL`: Checks if a value is `NULL`. The `value` property should be `null` or `undefined`.
+- `IS_NOT_NULL`: Checks if a value is not `NULL`. The `value` property should be `null` or `undefined`.
+
+#### Ranges & Regex
+
+- `BETWEEN`: Checks if a value is within a specified range (inclusive). Expects a tuple of two values: `[min, max]`.
+- `NOT_BETWEEN`: Checks if a value is outside a specified range. Expects a tuple of two values: `[min, max]`.
+- `MATCHES_REGEX`: Checks if a string value matches a regular expression. Expects a `string` representing the regex pattern.
+
+#### Complex Types (JSON, Array, SET)
+
+- **JSON Operators**
+- `JSON_CONTAINS`: Checks if a JSON document contains a specific structure or value at a given path. Expects an object where keys are JSON paths and values are the data to find (e.g., `{ "tags": "tech", "views": 100 }`).
+- `JSON_NOT_CONTAINS`: The inverse of `JSON_CONTAINS`.
+- **Array Operators**
+- `ARRAY_CONTAINS_ELEMENT`: Checks if an array contains a specific element. For native array columns, expects a primitive value. For JSON arrays, expects an object like `{ "path.to.array": elementValue }`.
+- `ARRAY_CONTAINS_ALL_ELEMENTS`: Checks if an array contains all elements from a given array. Expects an `Array<primitive>` or `{ "path.to.array": [elements] }`.
+- `ARRAY_CONTAINS_ANY_ELEMENT`: Checks if an array contains at least one element from a given array. Expects an `Array<primitive>` or `{ "path.to.array": [elements] }`.
+- `ARRAY_EQUALS`: Checks if an array is exactly equal to a given array (order and elements). Expects an `Array<primitive>` or `{ "path.to.array": [elements] }`.
+- **SET Operators** (Conceptually for sets, often used on string or array fields)
+- `SET_CONTAINS`: Checks if a set contains a specific value. Expects a `string`.
+- `SET_NOT_CONTAINS`: The inverse of `SET_CONTAINS`.
+- `SET_CONTAINS_ANY`: Checks if a set contains at least one of the specified values. Expects an `Array<string>`.
+- `SET_CONTAINS_ALL`: Checks if a set contains all of the specified values. Expects an `Array<string>`.
+
+---
+
 ## 3. Adding Joins
 
-Joins are added with the `join()` method. This method takes two arguments:
+Joins are added with the `join()` method. This method's signature has been updated for clarity and type safety:
+
+`criteria.join(joinAlias, criteriaToJoin, joinParameters)`
 
-1. An instance of a join `Criteria` (`InnerJoinCriteria`, `LeftJoinCriteria`, `OuterJoinCriteria`), also created with `CriteriaFactory`.
-2. A join parameters object that defines how the entities are related.
+- **`joinAlias` (string):** This is the **alias of the relationship** as defined in the `joins` array within the _parent schema_. It acts as a unique identifier for that specific relationship configuration. The library uses this `joinAlias` along with the `source_name` of the `criteriaToJoin` (the schema of the entity being joined) to find the exact relationship definition in the parent schema.
+- **`criteriaToJoin` (JoinCriteria):** An instance of a join `Criteria` (`InnerJoinCriteria`, `LeftJoinCriteria`, etc.), created with `CriteriaFactory`.
+- **`joinParameters` (object):** An object that defines how the entities are related (`parent_field`, `join_field`, etc.).
 
 ### Simple Joins (one-to-many, many-to-one, one-to-one)
 
 For these relationships, the join parameters are `parent_field` and `join_field`.
 
 ```typescript
-// Get posts and their author (publisher)
-// PostSchema defines a 'publisher' join (many-to-one) with UserSchema
-const postsWithAuthorCriteria = CriteriaFactory.GetCriteria(
-  PostSchema,
-  'posts',
-).join(
-  CriteriaFactory.GetInnerJoinCriteria(UserSchema, 'publisher'), // 'publisher' is an alias in UserSchema
+import { CriteriaFactory } from '@nulledexp/translatable-criteria';
+import { UserSchema, PostSchema } from './path/to/your/schemas';
+
+const postsWithAuthorCriteria = CriteriaFactory.GetCriteria(PostSchema).join(
+  'user',
+  CriteriaFactory.GetInnerJoinCriteria(UserSchema),
   {
-    parent_field: 'user_uuid', // FK field in PostSchema
-    join_field: 'uuid', // PK field in UserSchema (the 'publisher')
+    parent_field: 'userId',
+    join_field: 'id',
   },
 );
 
-// Get users and their posts
-// UserSchema defines a 'posts' join (one-to-many) with PostSchema
-const usersWithPostsCriteria = CriteriaFactory.GetCriteria(
-  UserSchema,
-  'users',
-).join(
-  CriteriaFactory.GetLeftJoinCriteria(PostSchema, 'posts'), // 'posts' is an alias in PostSchema
+const usersWithPostsCriteria = CriteriaFactory.GetCriteria(UserSchema).join(
+  'posts',
+  CriteriaFactory.GetLeftJoinCriteria(PostSchema),
   {
-    parent_field: 'uuid', // PK field in UserSchema
-    join_field: 'user_uuid', // FK field in PostSchema
+    parent_field: 'id',
+    join_field: 'userId',
   },
 );
 ```
 
-**Note:** The `alias` used in `GetInnerJoinCriteria` (e.g., `'publisher'`) must be one of the `alias` defined in the schema of the entity being joined (in this case, `UserSchema`). The library validates this.
-
 ### Joins with Pivot Table (many-to-many)
 
-For `many_to_many` relationships, the join parameters require a more detailed object that includes `pivot_source_name` and objects for `parent_field` and `join_field` specifying both the field in the entity and the field in the pivot table.
+For `many_to_many` relationships, the join parameters require a more detailed object that includes `pivot_source_name` and objects for `parent_field` and `join_field`.
 
 ```typescript
-// Get users and their permissions
-// UserSchema defines a 'permissions' join (many-to-many) with PermissionSchema
-const usersWithPermissionsCriteria = CriteriaFactory.GetCriteria(
-  UserSchema,
-  'users',
-).join(CriteriaFactory.GetInnerJoinCriteria(PermissionSchema, 'permissions'), {
-  pivot_source_name: 'user_permission_pivot', // Name of your pivot table
-  parent_field: {
-    pivot_field: 'user_id_in_pivot', // FK of User in the pivot table
-    reference: 'uuid', // PK of User
-  },
-  join_field: {
-    pivot_field: 'permission_id_in_pivot', // FK of Permission in the pivot table
-    reference: 'uuid', // PK of Permission
+import { CriteriaFactory } from '@nulledexp/translatable-criteria';
+import { UserSchema, RoleSchema } from './path/to/your/schemas';
+
+const usersWithRolesCriteria = CriteriaFactory.GetCriteria(UserSchema).join(
+  'roles',
+  CriteriaFactory.GetInnerJoinCriteria(RoleSchema),
+  {
+    pivot_source_name: 'user_roles',
+    parent_field: { pivot_field: 'user_id', reference: 'id' },
+    join_field: { pivot_field: 'role_id', reference: 'id' },
   },
-});
+);
 ```
 
 ### Filtering on Joined Entities
 
-You can apply filters directly to the join `Criteria`:
+You can apply filters directly to the `JoinCriteria` instance before passing it to the `.join()` method.
 
 ```typescript
-// Get posts and only comments that DO NOT contain "spam"
-const postsWithFilteredComments = CriteriaFactory.GetCriteria(
-  PostSchema,
-  'posts',
-).join(
-  CriteriaFactory.GetLeftJoinCriteria(PostCommentSchema, 'comments').where({
-    // Filter applied to the JoinCriteria (comments)
-    field: 'comment_text',
-    operator: FilterOperator.NOT_CONTAINS,
-    value: 'spam',
-  }),
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema, UserSchema } from './path/to/your/schemas';
+
+const activeUserJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(
+  UserSchema,
+).where({
+  field: 'isActive',
+  operator: FilterOperator.EQUALS,
+  value: true,
+});
+
+const postsFromActiveUsers = CriteriaFactory.GetCriteria(PostSchema).join(
+  'user',
+  activeUserJoinCriteria,
   {
-    parent_field: 'uuid',
-    join_field: 'post_uuid',
+    parent_field: 'userId',
+    join_field: 'id',
   },
 );
 ```
 
-These filters on the `JoinCriteria` typically translate to conditions in the `ON` clause of the JOIN (or `AND` after the `ON` for some translators/databases).
+These filters on the `JoinCriteria` typically translate to conditions in the `ON` clause of the JOIN.
+
+---
 
 ## 4. Ordering Results
 
@@ -390,12 +478,14 @@ Ordering is applied with the `orderBy()` method, which takes the field name and
 ### Ordering by Root Entity Fields
 
 ```typescript
-// Get users ordered by email ascending
-userCriteria.orderBy('email', OrderDirection.ASC);
-
-// Get posts ordered by creation date descending, then by title ascending
-postCriteria
-  .orderBy('created_at', OrderDirection.DESC)
+import {
+  CriteriaFactory,
+  OrderDirection,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema } from './path/to/your/schemas';
+
+const postOrderCriteria = CriteriaFactory.GetCriteria(PostSchema)
+  .orderBy('createdAt', OrderDirection.DESC)
   .orderBy('title', OrderDirection.ASC);
 ```
 
@@ -404,23 +494,27 @@ postCriteria
 To order by a field from a joined entity, call `orderBy()` on the corresponding `JoinCriteria` instance.
 
 ```typescript
-// Get posts, ordered by the author's (publisher) username
-const postsOrderedByAuthorUsername = CriteriaFactory.GetCriteria(
-  PostSchema,
-  'posts',
-).join(
-  CriteriaFactory.GetInnerJoinCriteria(UserSchema, 'publisher').orderBy(
-    'username',
-    OrderDirection.ASC,
-  ), // Ordering on the JoinCriteria
-  { parent_field: 'user_uuid', join_field: 'uuid' },
+import {
+  CriteriaFactory,
+  OrderDirection,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema, UserSchema } from './path/to/your/schemas';
+
+const userJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(
+  UserSchema,
+).orderBy('username', OrderDirection.ASC);
+
+const postsOrderedByAuthor = CriteriaFactory.GetCriteria(PostSchema).join(
+  'user',
+  userJoinCriteria,
+  { parent_field: 'userId', join_field: 'id' },
 );
 
-// You can also combine orderings from the root and joins.
-// The translator will handle applying the global order based on the internal `sequenceId` of each `Order`.
-postsOrderedByAuthorUsername.orderBy('created_at', OrderDirection.DESC);
+postsOrderedByAuthor.orderBy('createdAt', OrderDirection.DESC);
 ```
 
+---
+
 ## 5. Pagination
 
 The library supports offset-based and cursor-based pagination.
@@ -431,167 +525,170 @@ The library supports offset-based and cursor-based pagination.
 - `setSkip(count)`: Skips a number of results (SQL `OFFSET`).
 
 ```typescript
-// Get the first 10 posts
-postCriteria.setTake(10);
+import { CriteriaFactory } from '@nulledexp/translatable-criteria';
+import { PostSchema } from './path/to/your/schemas';
+
+const firstPageCriteria = CriteriaFactory.GetCriteria(PostSchema).setTake(10);
 
-// Get posts from page 3 (assuming 10 per page)
-postCriteria.setTake(10).setSkip(20); // (3-1) * 10
+const thirdPageCriteria = CriteriaFactory.GetCriteria(PostSchema)
+  .setTake(10)
+  .setSkip(20);
 ```
 
 ### Cursor-Based Pagination
 
-This is more efficient for large and frequently changing datasets. Use `setCursor()`.
+This is more efficient for large datasets. Use `setCursor()`.
 
-Requires:
-
-1. `cursorFilters`: An array with one or two `FilterPrimitive` objects (without the `operator`). These define the values of the last item from the previous page. The `value` for these filters can be `null` if the field itself is null, but it cannot be `undefined`.
-
-- If it's a single object, it's used for simple pagination over a unique field (usually an ordered and unique field, or a timestamp).
-- If there are two objects, it's used for composite pagination (keyset pagination), typically over a primary sort field (e.g., `created_at`) and a unique tie-breaker field (e.g., `uuid`).
-
-2. `operator`: `FilterOperator.GREATER_THAN` (for next page) or `FilterOperator.LESS_THAN` (for previous page, if order is inverted).
-3. `order`: The main `OrderDirection` in which pagination is occurring.
-
-**Important:** For cursor-based pagination to work, the `Criteria` (root and/or relevant joins) **must** have `orderBy()` defined for the same fields used in `cursorFilters` and in the same order. The translator will use this information.
+**Important:** For cursor-based pagination to work, the `Criteria` **must** have `orderBy()` defined for the same fields used in `setCursor()` and in the same order.
 
 ```typescript
-// Simple cursor pagination (e.g., on 'created_at')
-// Assume the last seen post had created_at = '2023-05-10T10:00:00.000Z'
-// And we are ordering by created_at ASC
-postCriteria
+import {
+  CriteriaFactory,
+  FilterOperator,
+  OrderDirection,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema } from './path/to/your/schemas';
+
+const simpleCursorCriteria = CriteriaFactory.GetCriteria(PostSchema)
   .setCursor(
-    [{ field: 'created_at', value: '2023-05-10T10:00:00.000Z' }], // Single filter for simple cursor
+    [{ field: 'createdAt', value: '2023-05-10T10:00:00.000Z' }],
     FilterOperator.GREATER_THAN,
     OrderDirection.ASC,
   )
-  .orderBy('created_at', OrderDirection.ASC) // orderBy must match
+  .orderBy('createdAt', OrderDirection.ASC)
   .setTake(10);
 
-// Composite cursor pagination (e.g., on 'created_at' and 'uuid')
-// Assume the last seen post had:
-// created_at = '2023-05-10T10:00:00.000Z'
-// uuid = 'some-last-uuid'
-// And we are ordering by created_at ASC, then uuid ASC
-postCriteria
+const compositeCursorCriteria = CriteriaFactory.GetCriteria(PostSchema)
   .setCursor(
     [
-      // Two filters for composite cursor
-      { field: 'created_at', value: '2023-05-10T10:00:00.000Z' },
-      { field: 'uuid', value: 'some-last-uuid' },
+      { field: 'createdAt', value: '2023-05-10T10:00:00.000Z' },
+      { field: 'id', value: 'some-last-id' },
     ],
     FilterOperator.GREATER_THAN,
     OrderDirection.ASC,
   )
-  .orderBy('created_at', OrderDirection.ASC) // Orderings must match
-  .orderBy('uuid', OrderDirection.ASC)
+  .orderBy('createdAt', OrderDirection.ASC)
+  .orderBy('id', OrderDirection.ASC)
   .setTake(10);
 ```
 
+---
+
 ## 6. Field Selection
 
-By default, a `Criteria` (root or join) will select all fields defined in its schema. You can modify this with `setSelect()` and `resetSelect()`.
+By default, a `Criteria` will select all fields defined in its schema. You can modify this with `setSelect()` and `resetSelect()`.
 
 ### Selection on the Root Entity
 
 ```typescript
-// Select only uuid and email from the user
-userCriteria.setSelect(['uuid', 'email']);
+import { CriteriaFactory } from '@nulledexp/translatable-criteria';
+import { UserSchema } from './path/to/your/schemas';
+
+const userSelectCriteria = CriteriaFactory.GetCriteria(UserSchema).setSelect([
+  'id',
+  'email',
+]);
 ```
 
+**Note:** When `setSelect` is used, the `identifier_field` of the entity is always implicitly included.
+
 ### Selection on Joined Entities
 
 Call `setSelect()` on the `JoinCriteria` instance.
 
 ```typescript
-// Get posts and only the username of their author
+import { CriteriaFactory } from '@nulledexp/translatable-criteria';
+import { PostSchema, UserSchema } from './path/to/your/schemas';
+
+const userJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(
+  UserSchema,
+).setSelect(['username']);
+
 const postsWithAuthorUsernameOnly = CriteriaFactory.GetCriteria(
   PostSchema,
-  'posts',
-).join(
-  CriteriaFactory.GetInnerJoinCriteria(UserSchema, 'publisher').setSelect([
-    'username',
-  ]), // Select only 'username' from the publisher
-  { parent_field: 'user_uuid', join_field: 'uuid' },
-);
+).join('user', userJoinCriteria, { parent_field: 'userId', join_field: 'id' });
 ```
 
 ### Reverting to Select All Fields (`resetSelect`)
 
-If you previously used `setSelect()` and want to revert to the default behavior of selecting all fields from the schema for that `Criteria` instance (root or join):
+If you previously used `setSelect()` and want to revert to the default behavior:
 
 ```typescript
-userCriteria.setSelect(['uuid']); // Selects only uuid
-// ... other operations ...
-userCriteria.resetSelect(); // Now selects all fields from UserSchema again
+import { CriteriaFactory } from '@nulledexp/translatable-criteria';
+import { UserSchema } from './path/to/your/schemas';
+
+const userCriteria = CriteriaFactory.GetCriteria(UserSchema);
+userCriteria.setSelect(['id']);
+userCriteria.resetSelect();
 ```
 
-**Important Note:** If you use `orderBy()` or `setCursor()` on fields that are _not_ included in your `setSelect()`, some translators (like TypeORM's) might automatically add those fields to the selection to ensure correct database operation.
+---
 
 ## 7. Combining Everything
 
-You can chain all these methods to build complex queries:
+You can chain all these methods to build complex queries. The following example demonstrates how to combine multiple features, including nested joins, filtering on both root and joined entities, field selection, and cursor-based pagination, to construct a sophisticated query specification.
 
 ```typescript
-// Complex example:
-// Get the 5 most recent posts (ordered by created_at DESC)
-// that contain "TypeORM" in the title or body,
-// including their author's (publisher) username and only the text of their comments (if any),
-// and the author (publisher) has the email "author@example.com".
-// Also, paginate using cursor if 'lastPostCreatedAt' and 'lastPostUuid' are defined.
-
-let lastPostCreatedAt: string | undefined = undefined; // '2023-10-26T12:00:00.000Z';
-let lastPostUuid: string | undefined = undefined; // 'a1b2c3d4-e5f6-7890-1234-567890abcdef';
-
-const complexPostCriteria = CriteriaFactory.GetCriteria(PostSchema, 'posts')
-  .setSelect(['uuid', 'title', 'created_at']) // Select specific post fields
+import {
+  CriteriaFactory,
+  FilterOperator,
+  OrderDirection,
+} from '@nulledexp/translatable-criteria';
+import { UserSchema, PostSchema, RoleSchema } from './path/to/your/schemas';
+
+let lastPostCreatedAt: string | undefined = undefined;
+let lastPostUuid: string | undefined = undefined;
+
+// 1. Define the criteria for the innermost join (Roles)
+const roleJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(RoleSchema).where(
+  {
+    field: 'name',
+    operator: FilterOperator.EQUALS,
+    value: 'admin',
+  },
+);
+
+// 2. Define the criteria for the intermediate join (Users) and add the nested join to it
+const userWithRolesJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(
+  UserSchema,
+).join('roles', roleJoinCriteria, {
+  pivot_source_name: 'user_roles',
+  parent_field: { pivot_field: 'user_id', reference: 'id' },
+  join_field: { pivot_field: 'role_id', reference: 'id' },
+});
+
+// 3. Build the main criteria (Posts)
+const complexPostCriteria = CriteriaFactory.GetCriteria(PostSchema)
+  .setSelect(['id', 'title', 'createdAt'])
   .where({
     field: 'title',
     operator: FilterOperator.CONTAINS,
     value: 'TypeORM',
   })
-  .orWhere({
-    field: 'body',
-    operator: FilterOperator.CONTAINS,
-    value: 'TypeORM',
+  // 4. Add the pre-configured user join to the main criteria
+  .join('user', userWithRolesJoinCriteria, {
+    parent_field: 'userId',
+    join_field: 'id',
   })
-  .join(
-    CriteriaFactory.GetInnerJoinCriteria(UserSchema, 'publisher')
-      .setSelect(['username']) // Only the author's username
-      .where({
-        field: 'email',
-        operator: FilterOperator.EQUALS,
-        value: 'author@example.com',
-      }),
-    { parent_field: 'user_uuid', join_field: 'uuid' },
-  )
-  .join(
-    CriteriaFactory.GetLeftJoinCriteria(
-      PostCommentSchema,
-      'comments',
-    ).setSelect(['comment_text']), // Only the comment text
-    { parent_field: 'uuid', join_field: 'post_uuid' },
-  )
-  .orderBy('created_at', OrderDirection.DESC) // Main order for cursor pagination
-  .orderBy('uuid', OrderDirection.DESC); // Tie-breaker for cursor pagination
+  .orderBy('createdAt', OrderDirection.DESC)
+  .orderBy('id', OrderDirection.DESC);
 
 if (lastPostCreatedAt && lastPostUuid) {
   complexPostCriteria.setCursor(
     [
-      { field: 'created_at', value: lastPostCreatedAt },
-      { field: 'uuid', value: lastPostUuid },
+      { field: 'createdAt', value: lastPostCreatedAt },
+      { field: 'id', value: lastPostUuid },
     ],
-    FilterOperator.LESS_THAN, // Because we order DESC for "most recent"
+    FilterOperator.LESS_THAN,
     OrderDirection.DESC,
   );
 }
 
 complexPostCriteria.setTake(5);
-
-// 'complexPostCriteria' is now ready to be passed to a translator.
 ```
 
 ## Next Steps
 
-With the criteria built, the next step is to use a `CriteriaTranslator` to convert these
-`Criteria` objects into a native query for your database. Refer to the guide on Developing
-Custom Translators or use an existing translator if available for your stack.
+With the criteria built, the next step is to use a [`CriteriaTranslator`](../developing-translators/en.md) to convert these
+`Criteria` objects into a native query for your database. [Refer to the guide on Developing
+Custom Translators](../developing-translators/en.md) or use an existing translator if available for your stack.
diff --git a/src/docs/guides/building-criteria/es.md b/src/docs/guides/building-criteria/es.md
index 0b53368..8d31362 100644
--- a/src/docs/guides/building-criteria/es.md
+++ b/src/docs/guides/building-criteria/es.md
@@ -12,11 +12,12 @@ Esta guía te mostrará cómo utilizar `CriteriaFactory` y los métodos fluidos
   - [Agrupación Lógica (AND/OR)](#agrupación-lógica-andor)
   - [Filtros Avanzados (JSON, Array, Set)](#filtros-avanzados-json-array-set)
     - [Filtrando Campos JSON (`JSON_CONTAINS`, `JSON_NOT_CONTAINS`)](#filtrando-campos-json-json_contains-json_not_contains)
-    - [Filtrando Campos Array (`ARRAY_CONTAINS_ELEMENT`, etc.)](#filtrando-campos-array-array_contains_element-array_contains_all_elements-array_contains_any_element-array_equals)
+    - [Filtrando Campos Array (`ARRAY_CONTAINS_ELEMENT`, etc.)](#filtrando-campos-array-array_contains_element-etc)
     - [Filtrando Campos SET (`SET_CONTAINS`, `SET_NOT_CONTAINS`, `SET_CONTAINS_ANY`, `SET_CONTAINS_ALL`)](#filtrando-campos-set-set_contains-set_not_contains-set_contains_any-set_contains_all)
     - [Filtrando por Rangos (`BETWEEN`, `NOT_BETWEEN`)](#filtrando-por-rangos-between-not_between)
     - [Filtrando con Expresiones Regulares (`MATCHES_REGEX`)](#filtrando-con-expresiones-regulares-matches_regex)
     - [Coincidencia de Patrones Insensible a Mayúsculas/Minúsculas (`ILIKE`, `NOT_ILIKE`)](#coincidencia-de-patrones-insensible-a-mayúsculasminúsculas-ilike-not_ilike)
+  - [Referencia de Operadores de Filtro](#referencia-de-operadores-de-filtro)
 - 3. [Añadiendo Uniones (Joins)](#3-añadiendo-uniones-joins)
   - [Uniones Simples (one-to-many, many-to-one, one-to-one)](#uniones-simples-one-to-many-many-to-one-one-to-one)
   - [Uniones con Tabla Pivote (many-to-many)](#uniones-con-tabla-pivote-many-to-many)
@@ -36,23 +37,86 @@ Esta guía te mostrará cómo utilizar `CriteriaFactory` y los métodos fluidos
 
 ---
 
+## Esquemas de Ejemplo
+
+Para hacer los ejemplos de esta guía autocontenidos, utilizaremos los siguientes esquemas simplificados:
+
+```typescript
+import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
+
+export const UserSchema = GetTypedCriteriaSchema({
+  source_name: 'users',
+  alias: 'u',
+  fields: ['id', 'username', 'email', 'age', 'isActive', 'createdAt', 'tags'],
+  identifier_field: 'id',
+  joins: [
+    {
+      alias: 'posts',
+      target_source_name: 'posts',
+      relation_type: 'one_to_many',
+    },
+    {
+      alias: 'roles',
+      target_source_name: 'roles',
+      relation_type: 'many_to_many',
+    },
+  ],
+});
+
+export const PostSchema = GetTypedCriteriaSchema({
+  source_name: 'posts',
+  alias: 'p',
+  fields: [
+    'id',
+    'title',
+    'content',
+    'userId',
+    'createdAt',
+    'categories',
+    'metadata',
+  ],
+  identifier_field: 'id',
+  joins: [
+    {
+      alias: 'user',
+      target_source_name: 'users',
+      relation_type: 'many_to_one',
+    },
+  ],
+});
+
+export const RoleSchema = GetTypedCriteriaSchema({
+  source_name: 'roles',
+  alias: 'r',
+  fields: ['id', 'name'],
+  identifier_field: 'id',
+  joins: [],
+});
+
+export const ProductSchema = GetTypedCriteriaSchema({
+  source_name: 'products',
+  alias: 'prod',
+  fields: ['id', 'name', 'price', 'createdAt'],
+  identifier_field: 'id',
+  joins: [],
+});
+```
+
+---
+
 ## 1. Creando un `RootCriteria`
 
-Toda consulta comienza con un `RootCriteria`, que representa la entidad principal desde la cual se iniciará la consulta. Se crea utilizando `CriteriaFactory.GetCriteria()`:
+Toda consulta comienza con un `RootCriteria`, que representa la entidad principal desde la cual se iniciará la consulta. Se crea utilizando `CriteriaFactory.GetCriteria()`. El alias ahora se toma directamente de la propiedad `alias` del esquema proporcionado.
 
 ```typescript
 import { CriteriaFactory } from '@nulledexp/translatable-criteria';
-import { UserSchema, PostSchema } from './path/to/your/schemas'; // Asegúrate de que la ruta sea correcta
-
-// Crear un Criteria para la entidad User, usando el alias 'users'
-const userCriteria = CriteriaFactory.GetCriteria(UserSchema, 'users');
+import { UserSchema, PostSchema } from './path/to/your/schemas';
 
-// Crear un Criteria para la entidad Post, usando el alias 'posts'
-const postCriteria = CriteriaFactory.GetCriteria(PostSchema, 'posts');
+const userCriteria = CriteriaFactory.GetCriteria(UserSchema);
+const postCriteria = CriteriaFactory.GetCriteria(PostSchema);
 ```
 
-- El primer argumento es el esquema de la entidad (`UserSchema`, `PostSchema`).
-- El segundo argumento es uno de los alias definidos en el `alias` array de ese esquema. Usar el alias correcto es crucial para la correcta interpretación por parte de los traductores.
+---
 
 ## 2. Aplicando Filtros
 
@@ -61,25 +125,26 @@ Los filtros se añaden usando los métodos `where()`, `andWhere()`, y `orWhere()
 ### Filtros Básicos
 
 ```typescript
-import { FilterOperator } from '@nulledexp/translatable-criteria';
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { UserSchema, PostSchema } from './path/to/your/schemas';
 
-// Encontrar usuarios con un email específico
-userCriteria.where({
-  field: 'email', // Campo del UserSchema
+const userEmailCriteria = CriteriaFactory.GetCriteria(UserSchema).where({
+  field: 'email',
   operator: FilterOperator.EQUALS,
   value: 'test@example.com',
 });
 
-// Encontrar posts cuyo título contenga "TypeScript"
-postCriteria.where({
-  field: 'title', // Campo del PostSchema
-  operator: FilterOperator.CONTAINS, // o FilterOperator.LIKE con '%'
-  value: '%TypeScript%',
+const postTitleCriteria = CriteriaFactory.GetCriteria(PostSchema).where({
+  field: 'title',
+  operator: FilterOperator.CONTAINS,
+  value: 'TypeScript',
 });
 
-// Encontrar posts creados después de una fecha específica
-postCriteria.where({
-  field: 'created_at',
+const postDateCriteria = CriteriaFactory.GetCriteria(PostSchema).where({
+  field: 'createdAt',
   operator: FilterOperator.GREATER_THAN,
   value: new Date('2023-01-01'),
 });
@@ -91,8 +156,13 @@ postCriteria.where({
 - `orWhere()`: Añade una condición que, si se cumple, hace que el grupo de filtros sea verdadero, incluso si las condiciones previas (agrupadas por AND) no lo son (OR lógico). La librería normaliza esto para mantener una estructura de `OR ( (cond1 AND cond2), (cond3) )`.
 
 ```typescript
-// Usuarios cuyo username es 'admin' Y su email contiene '@example.com'
-userCriteria
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { UserSchema, PostSchema } from './path/to/your/schemas';
+
+const adminUserCriteria = CriteriaFactory.GetCriteria(UserSchema)
   .where({ field: 'username', operator: FilterOperator.EQUALS, value: 'admin' })
   .andWhere({
     field: 'email',
@@ -100,22 +170,19 @@ userCriteria
     value: '@example.com',
   });
 
-// Posts que contienen "Tutorial" en el título O en el cuerpo del post
-postCriteria
+const tutorialPostCriteria = CriteriaFactory.GetCriteria(PostSchema)
   .where({
     field: 'title',
     operator: FilterOperator.CONTAINS,
     value: 'Tutorial',
   })
   .orWhere({
-    field: 'body',
+    field: 'content',
     operator: FilterOperator.CONTAINS,
     value: 'Tutorial',
   });
 
-// Combinación más compleja:
-// (username = 'editor' AND email LIKE '%@editor.com%') OR (username = 'guest')
-userCriteria
+const editorOrGuestCriteria = CriteriaFactory.GetCriteria(UserSchema)
   .where({
     field: 'username',
     operator: FilterOperator.EQUALS,
@@ -123,8 +190,8 @@ userCriteria
   })
   .andWhere({
     field: 'email',
-    operator: FilterOperator.LIKE,
-    value: '%@editor.com%',
+    operator: FilterOperator.CONTAINS,
+    value: '@editor.com',
   })
   .orWhere({
     field: 'username',
@@ -135,38 +202,31 @@ userCriteria
 
 ### Filtros Avanzados (JSON, Array, Set)
 
-La librería soporta operadores para tipos de datos más complejos como JSON, arrays y campos tipo SET.
+La librería soporta una amplia gama de operadores para tipos de datos complejos. Para una lista completa, consulta la guía de Conceptos Clave. Aquí tienes algunos ejemplos:
 
 #### Filtrando Campos JSON (`JSON_CONTAINS`, `JSON_NOT_CONTAINS`)
 
 El valor para estos operadores es un objeto donde las claves son rutas JSON (el traductor determinará si necesita `$.` al inicio) y los valores son lo que se busca en esa ruta.
 
 ```typescript
-// Suponiendo que PostSchema tiene un campo 'metadata' de tipo JSON
-// con una estructura como: { tags: ["tech", "code"], views: 100 }
-
-// Encontrar posts donde metadata.tags contenga "tech" Y metadata.views sea 100
-postCriteria.where({
-  field: 'metadata', // El campo JSON
-  operator: FilterOperator.JSON_CONTAINS,
-  value: {
-    tags: 'tech', // Busca "tech" dentro del array metadata.tags
-    views: 100, // Busca que metadata.views sea 100
-    // "extra.source": "import" // También puedes anidar rutas
-  },
-});
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema } from './path/to/your/schemas';
 
-// Encontrar posts donde metadata.extra.quality NO sea "low"
-postCriteria.where({
+const jsonCriteria = CriteriaFactory.GetCriteria(PostSchema).where({
   field: 'metadata',
-  operator: FilterOperator.JSON_NOT_CONTAINS,
+  operator: FilterOperator.JSON_CONTAINS,
   value: {
-    'extra.quality': 'low',
+    tags: 'tech',
+    views: 100,
+    'extra.source': 'import',
   },
 });
 ```
 
-#### Filtrando Campos Array (`ARRAY_CONTAINS_ELEMENT`, `ARRAY_CONTAINS_ALL_ELEMENTS`, `ARRAY_CONTAINS_ANY_ELEMENT`, `ARRAY_EQUALS`)
+#### Filtrando Campos Array (`ARRAY_CONTAINS_ELEMENT`, etc.)
 
 Estos operadores pueden usarse para campos que son arrays nativos o arrays dentro de JSON.
 
@@ -174,39 +234,16 @@ Estos operadores pueden usarse para campos que son arrays nativos o arrays dentr
 - **Para arrays dentro de JSON:** El `value` es un objeto con una única clave (la ruta JSON al array) y el valor es el elemento o array de elementos.
 
 ```typescript
-// 1. Columna de Array Nativo: Encontrar posts que tengan la categoría "TypeScript"
-postCriteria.where({
-  field: 'categories',
-  operator: FilterOperator.ARRAY_CONTAINS_ELEMENT,
-  value: 'TypeScript',
-});
-
-// 2. Array dentro de JSON: Encontrar posts donde metadata.tags contenga "typeorm"
-postCriteria.where({
-  field: 'metadata', // Campo JSON principal
-  operator: FilterOperator.ARRAY_CONTAINS_ELEMENT,
-  value: { tags: 'typeorm' }, // { "ruta.al.array": elemento }
-});
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema } from './path/to/your/schemas';
 
-// 3. Columna de Array Nativo: Encontrar posts que tengan TODAS las categorías ["nestjs", "api"]
-postCriteria.where({
+const arrayCriteria = CriteriaFactory.GetCriteria(PostSchema).where({
   field: 'categories',
-  operator: FilterOperator.ARRAY_CONTAINS_ALL_ELEMENTS,
-  value: ['nestjs', 'api'],
-});
-
-// 4. Array dentro de JSON: Encontrar posts donde metadata.ratings contenga AL MENOS UNO de [4, 5]
-postCriteria.where({
-  field: 'metadata',
   operator: FilterOperator.ARRAY_CONTAINS_ANY_ELEMENT,
-  value: { ratings: [4, 5] },
-});
-
-// 5. Columna de Array Nativo: Encontrar posts cuyas categorías sean EXACTAMENTE ["news", "updates"] (orden importa)
-postCriteria.where({
-  field: 'categories',
-  operator: FilterOperator.ARRAY_EQUALS,
-  value: ['news', 'updates'],
+  value: ['nestjs', 'api'],
 });
 ```
 
@@ -215,28 +252,16 @@ postCriteria.where({
 Similar a `CONTAINS` pero conceptualmente para campos que representan un conjunto de valores (como el tipo `SET` de MySQL o un string delimitado).
 
 ```typescript
-// Suponiendo un campo 'flags' en UserSchema que es un SET('active', 'verified', 'beta_tester')
-// o un campo de texto 'tags' como "typescript,javascript,nodejs"
-
-// Busca usuarios que tengan el flag 'verified'
-userCriteria.where({
-  field: 'flags',
-  operator: FilterOperator.SET_CONTAINS,
-  value: 'verified',
-});
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { UserSchema } from './path/to/your/schemas';
 
-// Busca usuarios que tengan AL MENOS UNO de los tags "typescript" o "javascript"
-userCriteria.where({
+const setCriteria = CriteriaFactory.GetCriteria(UserSchema).where({
   field: 'tags',
   operator: FilterOperator.SET_CONTAINS_ANY,
-  value: ['typescript', 'javascript'], // Espera un array de valores
-});
-
-// Busca usuarios que tengan TODOS los flags "active" Y "beta_tester"
-userCriteria.where({
-  field: 'flags',
-  operator: FilterOperator.SET_CONTAINS_ALL,
-  value: ['active', 'beta_tester'], // Espera un array de valores
+  value: ['typescript', 'javascript'],
 });
 ```
 
@@ -245,15 +270,21 @@ userCriteria.where({
 Estos operadores permiten verificar si un valor numérico o de fecha se encuentra dentro o fuera de un rango específico.
 
 ```typescript
-// Encontrar posts creados entre dos fechas
-postCriteria.where({
-  field: 'created_at',
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema, ProductSchema } from './path/to/your/schemas';
+
+const betweenDatesCriteria = CriteriaFactory.GetCriteria(PostSchema).where({
+  field: 'createdAt',
   operator: FilterOperator.BETWEEN,
-  value: [new Date('2023-01-01'), new Date('2023-03-31')], // [min, max]
+  value: [new Date('2023-01-01'), new Date('2023-03-31')],
 });
 
-// Encontrar productos cuyo precio NO esté entre 100 y 200
-productCriteria.where({
+const notBetweenPriceCriteria = CriteriaFactory.GetCriteria(
+  ProductSchema,
+).where({
   field: 'price',
   operator: FilterOperator.NOT_BETWEEN,
   value: [100, 200],
@@ -265,12 +296,16 @@ productCriteria.where({
 Permite realizar búsquedas de patrones más potentes utilizando expresiones regulares. La sintaxis específica de la expresión regular puede depender de la base de datos subyacente.
 
 ```typescript
-// Encontrar usuarios cuyo username comience con "admin" seguido de números
-// (ejemplo conceptual, la sintaxis REGEX varía)
-userCriteria.where({
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { UserSchema } from './path/to/your/schemas';
+
+const regexCriteria = CriteriaFactory.GetCriteria(UserSchema).where({
   field: 'username',
   operator: FilterOperator.MATCHES_REGEX,
-  value: '^admin[0-9]+', // La expresión regular como string
+  value: '^admin[0-9]+',
 });
 ```
 
@@ -279,109 +314,162 @@ userCriteria.where({
 Similares a `LIKE` y `NOT_LIKE`, pero garantizan que la comparación de patrones sea insensible a mayúsculas y minúsculas, independientemente de la configuración por defecto de la base de datos.
 
 ```typescript
-// Encontrar posts cuyo título contenga "typescript" (sin importar mayúsculas/minúsculas)
-postCriteria.where({
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema } from './path/to/your/schemas';
+
+const ilikeCriteria = CriteriaFactory.GetCriteria(PostSchema).where({
   field: 'title',
   operator: FilterOperator.ILIKE,
   value: '%typescript%',
 });
-
-// Encontrar usuarios cuyo email NO comience con "test" (insensible a mayúsculas/minúsculas)
-userCriteria.where({
-  field: 'email',
-  operator: FilterOperator.NOT_ILIKE,
-  value: 'test%',
-});
 ```
 
+### Referencia de Operadores de Filtro
+
+Aquí tienes una lista detallada de los valores de `FilterOperator` disponibles y el tipo de `value` que esperan.
+
+#### Igualdad y Comparación
+
+- `EQUALS`: Comprueba la igualdad exacta. Espera un valor primitivo (`string`, `number`, `boolean`, `Date`, `null`).
+- `NOT_EQUALS`: Comprueba la desigualdad. Espera un valor primitivo.
+- `GREATER_THAN`: Comprueba si un valor es mayor que el proporcionado. Espera un `number` o `Date`.
+- `GREATER_THAN_OR_EQUALS`: Comprueba si un valor es mayor o igual que el proporcionado. Espera un `number` o `Date`.
+- `LESS_THAN`: Comprueba si un valor es menor que el proporcionado. Espera un `number` o `Date`.
+- `LESS_THAN_OR_EQUALS`: Comprueba si un valor es menor o igual que el proporcionado. Espera un `number` o `Date`.
+
+#### Coincidencia de Patrones
+
+- `LIKE`: Coincide con un patrón (la sensibilidad a mayúsculas/minúsculas depende de la base de datos). Espera un `string`. El traductor es responsable de manejar los comodines (`%`, `_`).
+- `NOT_LIKE`: Comprueba si un valor no coincide con un patrón. Espera un `string`.
+- `CONTAINS`: Comprueba si una cadena contiene una subcadena. Espera un `string`. El traductor típicamente envolverá el valor con comodines (ej. `'%valor%'`).
+- `NOT_CONTAINS`: Comprueba si una cadena no contiene una subcadena. Espera un `string`.
+- `STARTS_WITH`: Comprueba si una cadena comienza con una subcadena específica. Espera un `string`. El traductor típicamente añadirá un comodín al final (ej. `'valor%'`).
+- `ENDS_WITH`: Comprueba si una cadena termina con una subcadena específica. Espera un `string`. El traductor típicamente añadirá un comodín al principio (ej. `'%valor'`).
+- `ILIKE`: Versión de `LIKE` insensible a mayúsculas/minúsculas. Espera un `string`.
+- `NOT_ILIKE`: Versión de `NOT_LIKE` insensible a mayúsculas/minúsculas. Espera un `string`.
+
+#### Pertenencia y Nulidad
+
+- `IN`: Comprueba si un valor está dentro de un array dado. Espera un `Array<string | number | boolean | Date>`.
+- `NOT_IN`: Comprueba si un valor no está dentro de un array dado. Espera un `Array<string | number | boolean | Date>`.
+- `IS_NULL`: Comprueba si un valor es `NULL`. La propiedad `value` debe ser `null` o `undefined`.
+- `IS_NOT_NULL`: Comprueba si un valor no es `NULL`. La propiedad `value` debe ser `null` o `undefined`.
+
+#### Rangos y Regex
+
+- `BETWEEN`: Comprueba si un valor está dentro de un rango especificado (inclusivo). Espera una tupla de dos valores: `[min, max]`.
+- `NOT_BETWEEN`: Comprueba si un valor está fuera de un rango especificado. Espera una tupla de dos valores: `[min, max]`.
+- `MATCHES_REGEX`: Comprueba si un valor de tipo string coincide con una expresión regular. Espera un `string` que representa el patrón de la regex.
+
+#### Tipos Complejos (JSON, Array, SET)
+
+- **Operadores JSON**
+- `JSON_CONTAINS`: Comprueba si un documento JSON contiene una estructura o valor específico en una ruta dada. Espera un objeto donde las claves son rutas JSON y los valores son los datos a encontrar (ej. `{ "tags": "tech", "views": 100 }`).
+- `JSON_NOT_CONTAINS`: La inversa de `JSON_CONTAINS`.
+- **Operadores de Array**
+- `ARRAY_CONTAINS_ELEMENT`: Comprueba si un array contiene un elemento específico. Para columnas de array nativo, espera un valor primitivo. Para arrays en JSON, espera un objeto como `{ "ruta.al.array": valorElemento }`.
+- `ARRAY_CONTAINS_ALL_ELEMENTS`: Comprueba si un array contiene todos los elementos de un array dado. Espera un `Array<primitivo>` o `{ "ruta.al.array": [elementos] }`.
+- `ARRAY_CONTAINS_ANY_ELEMENT`: Comprueba si un array contiene al menos un elemento de un array dado. Espera un `Array<primitivo>` o `{ "ruta.al.array": [elementos] }`.
+- `ARRAY_EQUALS`: Comprueba si un array es exactamente igual a un array dado (orden y elementos). Espera un `Array<primitivo>` o `{ "ruta.al.array": [elementos] }`.
+- **Operadores SET** (Conceptualmente para conjuntos, a menudo usados en campos de string o array)
+- `SET_CONTAINS`: Comprueba si un conjunto contiene un valor específico. Espera un `string`.
+- `SET_NOT_CONTAINS`: La inversa de `SET_CONTAINS`.
+- `SET_CONTAINS_ANY`: Comprueba si un conjunto contiene al menos uno de los valores especificados. Espera un `Array<string>`.
+- `SET_CONTAINS_ALL`: Comprueba si un conjunto contiene todos los valores especificados. Espera un `Array<string>`.
+
+---
+
 ## 3. Añadiendo Uniones (Joins)
 
-Las uniones se añaden con el método `join()`. Este método toma dos argumentos:
+Las uniones se añaden con el método `join()`. La firma de este método se ha actualizado para mayor claridad y seguridad de tipos:
+
+`criteria.join(joinAlias, criteriaToJoin, joinParameters)`
 
-1.  Una instancia de un `Criteria` de join (`InnerJoinCriteria`, `LeftJoinCriteria`, `OuterJoinCriteria`), creada también con `CriteriaFactory`.
-2.  Un objeto de parámetros de join que define cómo se relacionan las entidades.
+- **`joinAlias` (string):** Es el **alias de la relación** tal como se define en el array `joins` dentro del _esquema padre_. Actúa como un identificador único para esa configuración de relación específica. La librería utiliza este `joinAlias` junto con el `source_name` de `criteriaToJoin` (el esquema de la entidad que se está uniendo) para encontrar la definición exacta de la relación en el esquema padre.
+- **`criteriaToJoin` (JoinCriteria):** Una instancia de un `Criteria` de join (`InnerJoinCriteria`, `LeftJoinCriteria`, etc.), creada con `CriteriaFactory`.
+- **`joinParameters` (object):** Un objeto que define cómo se relacionan las entidades (`parent_field`, `join_field`, etc.).
 
 ### Uniones Simples (one-to-many, many-to-one, one-to-one)
 
 Para estas relaciones, los parámetros de join son `parent_field` y `join_field`.
 
 ```typescript
-// Obtener posts y su autor (publisher)
-// PostSchema define un join 'publisher' (many-to-one) con UserSchema
-const postsWithAuthorCriteria = CriteriaFactory.GetCriteria(
-  PostSchema,
-  'posts',
-).join(
-  CriteriaFactory.GetInnerJoinCriteria(UserSchema, 'publisher'), // 'publisher' es un alias en UserSchema
+import { CriteriaFactory } from '@nulledexp/translatable-criteria';
+import { UserSchema, PostSchema } from './path/to/your/schemas';
+
+const postsWithAuthorCriteria = CriteriaFactory.GetCriteria(PostSchema).join(
+  'user',
+  CriteriaFactory.GetInnerJoinCriteria(UserSchema),
   {
-    parent_field: 'user_uuid', // Campo FK en PostSchema
-    join_field: 'uuid', // Campo PK en UserSchema (el 'publisher')
+    parent_field: 'userId',
+    join_field: 'id',
   },
 );
 
-// Obtener usuarios y sus posts
-// UserSchema define un join 'posts' (one-to-many) con PostSchema
-const usersWithPostsCriteria = CriteriaFactory.GetCriteria(
-  UserSchema,
-  'users',
-).join(
-  CriteriaFactory.GetLeftJoinCriteria(PostSchema, 'posts'), // 'posts' es un alias en PostSchema
+const usersWithPostsCriteria = CriteriaFactory.GetCriteria(UserSchema).join(
+  'posts',
+  CriteriaFactory.GetLeftJoinCriteria(PostSchema),
   {
-    parent_field: 'uuid', // Campo PK en UserSchema
-    join_field: 'user_uuid', // Campo FK en PostSchema
+    parent_field: 'id',
+    join_field: 'userId',
   },
 );
 ```
 
-**Nota:** El `alias` usado en `GetInnerJoinCriteria` (ej. `'publisher'`) debe ser uno de los `alias` definidos en el esquema de la entidad a la que se une (en este caso, `UserSchema`). La librería valida esto.
-
 ### Uniones con Tabla Pivote (many-to-many)
 
-Para relaciones `many_to_many`, los parámetros de join requieren un objeto más detallado que incluye `pivot_source_name` y objetos para `parent_field` y `join_field` que especifican tanto el campo en la entidad como el campo en la tabla pivote.
+Para relaciones `many_to_many`, los parámetros de join requieren un objeto más detallado que incluye `pivot_source_name` y objetos para `parent_field` y `join_field`.
 
 ```typescript
-// Obtener usuarios y sus permisos
-// UserSchema define un join 'permissions' (many-to-many) con PermissionSchema
-const usersWithPermissionsCriteria = CriteriaFactory.GetCriteria(
-  UserSchema,
-  'users',
-).join(CriteriaFactory.GetInnerJoinCriteria(PermissionSchema, 'permissions'), {
-  pivot_source_name: 'user_permission_pivot', // Nombre de tu tabla pivote
-  parent_field: {
-    pivot_field: 'user_id_in_pivot', // FK del User en la tabla pivote
-    reference: 'uuid', // PK del User
-  },
-  join_field: {
-    pivot_field: 'permission_id_in_pivot', // FK del Permission en la tabla pivote
-    reference: 'uuid', // PK del Permission
+import { CriteriaFactory } from '@nulledexp/translatable-criteria';
+import { UserSchema, RoleSchema } from './path/to/your/schemas';
+
+const usersWithRolesCriteria = CriteriaFactory.GetCriteria(UserSchema).join(
+  'roles',
+  CriteriaFactory.GetInnerJoinCriteria(RoleSchema),
+  {
+    pivot_source_name: 'user_roles',
+    parent_field: { pivot_field: 'user_id', reference: 'id' },
+    join_field: { pivot_field: 'role_id', reference: 'id' },
   },
-});
+);
 ```
 
 ### Filtrando en Entidades Unidas
 
-Puedes aplicar filtros directamente al `Criteria` de join:
+Puedes aplicar filtros directamente a la instancia del `JoinCriteria` antes de pasarla al método `.join()`.
 
 ```typescript
-// Obtener posts y solo los comentarios que NO contengan "spam"
-const postsWithFilteredComments = CriteriaFactory.GetCriteria(
-  PostSchema,
-  'posts',
-).join(
-  CriteriaFactory.GetLeftJoinCriteria(PostCommentSchema, 'comments').where({
-    // Filtro aplicado al JoinCriteria (comments)
-    field: 'comment_text',
-    operator: FilterOperator.NOT_CONTAINS,
-    value: 'spam',
-  }),
+import {
+  CriteriaFactory,
+  FilterOperator,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema, UserSchema } from './path/to/your/schemas';
+
+const activeUserJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(
+  UserSchema,
+).where({
+  field: 'isActive',
+  operator: FilterOperator.EQUALS,
+  value: true,
+});
+
+const postsFromActiveUsers = CriteriaFactory.GetCriteria(PostSchema).join(
+  'user',
+  activeUserJoinCriteria,
   {
-    parent_field: 'uuid',
-    join_field: 'post_uuid',
+    parent_field: 'userId',
+    join_field: 'id',
   },
 );
 ```
 
-Estos filtros en el `JoinCriteria` típicamente se traducen a condiciones en la cláusula `ON` del JOIN (o `AND` después del `ON` para algunos traductores/bases de datos).
+Estos filtros en el `JoinCriteria` típicamente se traducen a condiciones en la cláusula `ON` del JOIN.
+
+---
 
 ## 4. Ordenando Resultados
 
@@ -390,12 +478,14 @@ El ordenamiento se aplica con el método `orderBy()`, que toma el nombre del cam
 ### Ordenando por Campos de la Entidad Raíz
 
 ```typescript
-// Obtener usuarios ordenados por email ascendente
-userCriteria.orderBy('email', OrderDirection.ASC);
-
-// Obtener posts ordenados por fecha de creación descendente, luego por título ascendente
-postCriteria
-  .orderBy('created_at', OrderDirection.DESC)
+import {
+  CriteriaFactory,
+  OrderDirection,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema } from './path/to/your/schemas';
+
+const postOrderCriteria = CriteriaFactory.GetCriteria(PostSchema)
+  .orderBy('createdAt', OrderDirection.DESC)
   .orderBy('title', OrderDirection.ASC);
 ```
 
@@ -404,23 +494,27 @@ postCriteria
 Para ordenar por un campo de una entidad unida, llama a `orderBy()` en la instancia del `JoinCriteria` correspondiente.
 
 ```typescript
-// Obtener posts, ordenados por el username del autor (publisher)
-const postsOrderedByAuthorUsername = CriteriaFactory.GetCriteria(
-  PostSchema,
-  'posts',
-).join(
-  CriteriaFactory.GetInnerJoinCriteria(UserSchema, 'publisher').orderBy(
-    'username',
-    OrderDirection.ASC,
-  ), // Ordenamiento en el JoinCriteria
-  { parent_field: 'user_uuid', join_field: 'uuid' },
+import {
+  CriteriaFactory,
+  OrderDirection,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema, UserSchema } from './path/to/your/schemas';
+
+const userJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(
+  UserSchema,
+).orderBy('username', OrderDirection.ASC);
+
+const postsOrderedByAuthor = CriteriaFactory.GetCriteria(PostSchema).join(
+  'user',
+  userJoinCriteria,
+  { parent_field: 'userId', join_field: 'id' },
 );
 
-// También puedes combinar ordenamientos de la raíz y de los joins.
-// El traductor se encargará de aplicar el orden global según el `sequenceId` interno de cada `Order`.
-postsOrderedByAuthorUsername.orderBy('created_at', OrderDirection.DESC);
+postsOrderedByAuthor.orderBy('createdAt', OrderDirection.DESC);
 ```
 
+---
+
 ## 5. Paginación
 
 La librería soporta paginación basada en offset y basada en cursor.
@@ -431,165 +525,168 @@ La librería soporta paginación basada en offset y basada en cursor.
 - `setSkip(count)`: Omite un número de resultados (SQL `OFFSET`).
 
 ```typescript
-// Obtener los primeros 10 posts
-postCriteria.setTake(10);
+import { CriteriaFactory } from '@nulledexp/translatable-criteria';
+import { PostSchema } from './path/to/your/schemas';
+
+const firstPageCriteria = CriteriaFactory.GetCriteria(PostSchema).setTake(10);
 
-// Obtener posts de la página 3 (asumiendo 10 por página)
-postCriteria.setTake(10).setSkip(20); // (3-1) * 10
+const thirdPageCriteria = CriteriaFactory.GetCriteria(PostSchema)
+  .setTake(10)
+  .setSkip(20);
 ```
 
 ### Paginación Basada en Cursor
 
-Es más eficiente para conjuntos de datos grandes y que cambian frecuentemente. Se usa `setCursor()`.
+Es más eficiente para grandes conjuntos de datos. Se usa `setCursor()`.
 
-Requiere:
-
-1.  `cursorFilters`: Un array con uno o dos objetos `FilterPrimitive` (sin el `operator`). Estos definen los valores del último ítem de la página anterior. El `value` para estos filtros puede ser `null` si el campo en sí es nulo, pero no puede ser `undefined`.
-
-- Si es un solo objeto, se usa para paginación simple sobre un campo único (generalmente un campo ordenado y único, o un timestamp).
-- Si son dos objetos, se usa para paginación compuesta (keyset pagination), típicamente sobre un campo de ordenamiento primario (ej. `created_at`) y un campo de desempate único (ej. `uuid`).
-
-2.  `operator`: `FilterOperator.GREATER_THAN` (para página siguiente) o `FilterOperator.LESS_THAN` (para página anterior, si se invierte el orden).
-3.  `order`: La `OrderDirection` principal en la que se está paginando.
-
-**Importante:** Para que la paginación por cursor funcione, el `Criteria` (raíz y/o joins relevantes) **debe** tener `orderBy()` definidos para los mismos campos que se usan en `cursorFilters` y en el mismo orden. El traductor utilizará esta información.
+**Importante:** Para que la paginación por cursor funcione, el `Criteria` **debe** tener `orderBy()` definidos para los mismos campos que se usan en `setCursor()` y en el mismo orden.
 
 ```typescript
-// Paginación por cursor simple (ej. sobre 'created_at')
-// Asumimos que el último post visto tenía created_at = '2023-05-10T10:00:00.000Z'
-// Y estamos ordenando por created_at ASC
-postCriteria
+import {
+  CriteriaFactory,
+  FilterOperator,
+  OrderDirection,
+} from '@nulledexp/translatable-criteria';
+import { PostSchema } from './path/to/your/schemas';
+
+const simpleCursorCriteria = CriteriaFactory.GetCriteria(PostSchema)
   .setCursor(
-    [{ field: 'created_at', value: '2023-05-10T10:00:00.000Z' }], // Un solo filtro para cursor simple
+    [{ field: 'createdAt', value: '2023-05-10T10:00:00.000Z' }],
     FilterOperator.GREATER_THAN,
     OrderDirection.ASC,
   )
-  .orderBy('created_at', OrderDirection.ASC) // El orderBy debe coincidir
+  .orderBy('createdAt', OrderDirection.ASC)
   .setTake(10);
 
-// Paginación por cursor compuesta (ej. sobre 'created_at' y 'uuid')
-// Asumimos que el último post visto tenía:
-// created_at = '2023-05-10T10:00:00.000Z'
-// uuid = 'some-last-uuid'
-// Y estamos ordenando por created_at ASC, luego uuid ASC
-postCriteria
+const compositeCursorCriteria = CriteriaFactory.GetCriteria(PostSchema)
   .setCursor(
     [
-      // Dos filtros para cursor compuesto
-      { field: 'created_at', value: '2023-05-10T10:00:00.000Z' },
-      { field: 'uuid', value: 'some-last-uuid' },
+      { field: 'createdAt', value: '2023-05-10T10:00:00.000Z' },
+      { field: 'id', value: 'some-last-id' },
     ],
     FilterOperator.GREATER_THAN,
     OrderDirection.ASC,
   )
-  .orderBy('created_at', OrderDirection.ASC) // Ordenamientos deben coincidir
-  .orderBy('uuid', OrderDirection.ASC)
+  .orderBy('createdAt', OrderDirection.ASC)
+  .orderBy('id', OrderDirection.ASC)
   .setTake(10);
 ```
 
+---
+
 ## 6. Selección de Campos
 
-Por defecto, un `Criteria` (raíz o join) seleccionará todos los campos definidos en su esquema. Puedes modificar esto con `setSelect()` y `resetSelect()`.
+Por defecto, un `Criteria` seleccionará todos los campos definidos en su esquema. Puedes modificar esto con `setSelect()` y `resetSelect()`.
 
 ### Selección en la Entidad Raíz
 
 ```typescript
-// Seleccionar solo uuid y email del usuario
-userCriteria.setSelect(['uuid', 'email']);
+import { CriteriaFactory } from '@nulledexp/translatable-criteria';
+import { UserSchema } from './path/to/your/schemas';
+
+const userSelectCriteria = CriteriaFactory.GetCriteria(UserSchema).setSelect([
+  'id',
+  'email',
+]);
 ```
 
+**Nota:** Cuando se usa `setSelect`, el `identifier_field` de la entidad siempre se incluye implícitamente.
+
 ### Selección en Entidades Unidas
 
 Llama a `setSelect()` en la instancia del `JoinCriteria`.
 
 ```typescript
-// Obtener posts y solo el username de su autor
+import { CriteriaFactory } from '@nulledexp/translatable-criteria';
+import { PostSchema, UserSchema } from './path/to/your/schemas';
+
+const userJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(
+  UserSchema,
+).setSelect(['username']);
+
 const postsWithAuthorUsernameOnly = CriteriaFactory.GetCriteria(
   PostSchema,
-  'posts',
-).join(
-  CriteriaFactory.GetInnerJoinCriteria(UserSchema, 'publisher').setSelect([
-    'username',
-  ]), // Seleccionar solo 'username' del publisher
-  { parent_field: 'user_uuid', join_field: 'uuid' },
-);
+).join('user', userJoinCriteria, { parent_field: 'userId', join_field: 'id' });
 ```
 
 ### Volver a Seleccionar Todos los Campos (`resetSelect`)
 
-Si previamente usaste `setSelect()` y quieres volver al comportamiento por defecto de seleccionar todos los campos del esquema para esa instancia de `Criteria` (raíz o join):
+Si previamente usaste `setSelect()` y quieres volver al comportamiento por defecto:
 
 ```typescript
-userCriteria.setSelect(['uuid']); // Selecciona solo uuid
-// ... otras operaciones ...
-userCriteria.resetSelect(); // Ahora seleccionará todos los campos de UserSchema de nuevo
+import { CriteriaFactory } from '@nulledexp/translatable-criteria';
+import { UserSchema } from './path/to/your/schemas';
+
+const userCriteria = CriteriaFactory.GetCriteria(UserSchema);
+userCriteria.setSelect(['id']);
+userCriteria.resetSelect();
 ```
 
-**Nota Importante:** Si usas `orderBy()` o `setCursor()` sobre campos que _no_ están incluidos en tu `setSelect()`, algunos traductores (como el de TypeORM) podrían añadir automáticamente esos campos a la selección para asegurar el correcto funcionamiento de la base de datos.
+---
 
 ## 7. Combinando Todo
 
-Puedes encadenar todos estos métodos para construir consultas complejas:
+Puedes encadenar todos estos métodos para construir consultas complejas. El siguiente ejemplo demuestra cómo combinar múltiples características, incluyendo uniones anidadas, filtrado en entidades raíz y unidas, selección de campos y paginación basada en cursor, para construir una especificación de consulta sofisticada.
 
 ```typescript
-// Ejemplo complejo:
-// Obtener los 5 posts más recientes (ordenados por created_at DESC)
-// que contengan "TypeORM" en el título o en el cuerpo,
-// incluyendo el username de su autor (publisher) y solo el texto de sus comentarios (si los tienen),
-// y que el autor (publisher) tenga el email "author@example.com".
-// Además, paginar usando cursor si 'lastPostCreatedAt' y 'lastPostUuid' están definidos.
-
-let lastPostCreatedAt: string | undefined = undefined; // '2023-10-26T12:00:00.000Z';
-let lastPostUuid: string | undefined = undefined; // 'a1b2c3d4-e5f6-7890-1234-567890abcdef';
-
-const complexPostCriteria = CriteriaFactory.GetCriteria(PostSchema, 'posts')
-  .setSelect(['uuid', 'title', 'created_at']) // Seleccionar campos específicos del post
+import {
+  CriteriaFactory,
+  FilterOperator,
+  OrderDirection,
+} from '@nulledexp/translatable-criteria';
+import { UserSchema, PostSchema, RoleSchema } from './path/to/your/schemas';
+
+let lastPostCreatedAt: string | undefined = undefined;
+let lastPostUuid: string | undefined = undefined;
+
+// 1. Define el criteria para el join más interno (Roles)
+const roleJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(RoleSchema).where(
+  {
+    field: 'name',
+    operator: FilterOperator.EQUALS,
+    value: 'admin',
+  },
+);
+
+// 2. Define el criteria para el join intermedio (Users) y añádele el join anidado
+const userWithRolesJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(
+  UserSchema,
+).join('roles', roleJoinCriteria, {
+  pivot_source_name: 'user_roles',
+  parent_field: { pivot_field: 'user_id', reference: 'id' },
+  join_field: { pivot_field: 'role_id', reference: 'id' },
+});
+
+// 3. Construye el criteria principal (Posts)
+const complexPostCriteria = CriteriaFactory.GetCriteria(PostSchema)
+  .setSelect(['id', 'title', 'createdAt'])
   .where({
     field: 'title',
     operator: FilterOperator.CONTAINS,
     value: 'TypeORM',
   })
-  .orWhere({
-    field: 'body',
-    operator: FilterOperator.CONTAINS,
-    value: 'TypeORM',
+  // 4. Añade el join de usuario pre-configurado al criteria principal
+  .join('user', userWithRolesJoinCriteria, {
+    parent_field: 'userId',
+    join_field: 'id',
   })
-  .join(
-    CriteriaFactory.GetInnerJoinCriteria(UserSchema, 'publisher')
-      .setSelect(['username']) // Solo el username del autor
-      .where({
-        field: 'email',
-        operator: FilterOperator.EQUALS,
-        value: 'author@example.com',
-      }),
-    { parent_field: 'user_uuid', join_field: 'uuid' },
-  )
-  .join(
-    CriteriaFactory.GetLeftJoinCriteria(
-      PostCommentSchema,
-      'comments',
-    ).setSelect(['comment_text']), // Solo el texto del comentario
-    { parent_field: 'uuid', join_field: 'post_uuid' },
-  )
-  .orderBy('created_at', OrderDirection.DESC) // Orden principal para paginación por cursor
-  .orderBy('uuid', OrderDirection.DESC); // Campo de desempate para paginación por cursor
+  .orderBy('createdAt', OrderDirection.DESC)
+  .orderBy('id', OrderDirection.DESC);
 
 if (lastPostCreatedAt && lastPostUuid) {
   complexPostCriteria.setCursor(
     [
-      { field: 'created_at', value: lastPostCreatedAt },
-      { field: 'uuid', value: lastPostUuid },
+      { field: 'createdAt', value: lastPostCreatedAt },
+      { field: 'id', value: lastPostUuid },
     ],
-    FilterOperator.LESS_THAN, // Porque ordenamos DESC para "más recientes"
+    FilterOperator.LESS_THAN,
     OrderDirection.DESC,
   );
 }
 
 complexPostCriteria.setTake(5);
-
-// Ahora 'complexPostCriteria' está listo para ser pasado a un traductor.
 ```
 
 ## Próximos Pasos
 
-Con los criterios construidos, el siguiente paso es utilizar un `CriteriaTranslator` para convertir estos objetos `Criteria` en una consulta nativa para tu base de datos. Consulta la guía sobre Desarrollo de Traductores Personalizados o utiliza un traductor existente si está disponible para tu stack.
+Con los criterios construidos, el siguiente paso es utilizar un [`CriteriaTranslator`](../developing-translators/es.md) para convertir estos objetos `Criteria` en una consulta nativa para tu base de datos. [Consulta la guía sobre Desarrollo de Traductores Personalizados](../developing-translators/es.md) o utiliza un traductor existente si está disponible para tu stack.
diff --git a/src/docs/guides/developing-translators/en.md b/src/docs/guides/developing-translators/en.md
index fb8334f..410217e 100644
--- a/src/docs/guides/developing-translators/en.md
+++ b/src/docs/guides/developing-translators/en.md
@@ -14,12 +14,10 @@ This guide will show you the key steps and concepts for developing your own `Cri
   - 3.3. [`visitFilter`](#33-visitfilter)
   - 3.4. [`visitAndGroup`, `visitOrGroup`](#34-visitandgroup-visitorgroup)
 - 4.  [Handling Ordering, Pagination, and Selection](#4-handling-ordering-pagination-and-selection)
-  - 4.1. [Ordering (`orderBy`)](#41-ordering-orderby)
-  - 4.2. [Offset Pagination (`setTake`, `setSkip`)](#42-offset-pagination-settake-setskip)
-  - 4.3. [Cursor Pagination (`setCursor`)](#43-cursor-pagination-setcursor)
-  - 4.4. [Field Selection (`setSelect`)](#44-field-selection-setselect)
 - 5.  [State and Parameter Management](#5-state-and-parameter-management)
-- 6.  [Simplified Example: Pseudo-SQL Translator](#6-simplified-example-pseudo-sql-translator)
+- 6.  [Complete Example: Pseudo-SQL Translator](#6-complete-example-pseudo-sql-translator)
+  - 6.1. [Translator Implementation](#61-translator-implementation)
+  - 6.2. [Translator Usage](#62-translator-usage)
 - 7.  [Additional Considerations](#7-additional-considerations)
 - [Next Steps](#next-steps)
 
@@ -27,17 +25,17 @@ This guide will show you the key steps and concepts for developing your own `Cri
 
 ## 1. Understanding `CriteriaTranslator` and `ICriteriaVisitor`
 
-As mentioned in the Key Concepts, the library uses the Visitor design pattern.
+The library uses the Visitor design pattern.
 
 - **`CriteriaTranslator<TranslationContext, TranslationOutput, TFilterVisitorOutput>`**: This is an abstract class that you must extend.
 
-  - `TranslationContext`: The type of the context object passed during the traversal of the `Criteria` (e.g., a query builder like TypeORM's `SelectQueryBuilder`, or an object where you accumulate parts of a MongoDB query).
-  - `TranslationOutput`: The type of the final translation result (e.g., the modified `SelectQueryBuilder`, an SQL string, a MongoDB query object).
-  - `TFilterVisitorOutput`: The specific output type for the `visitFilter`, `visitAndGroup`, and `visitOrGroup` methods. This allows filters to be processed differently if necessary (e.g., generating a condition string, or a filter object).
+  - `TranslationContext`: The type of the mutable context object passed during the traversal of the `Criteria` object graph (e.g., a query builder instance, or an object where you accumulate parts of a query). This object is modified directly by the `visit...` methods.
+  - `TranslationOutput` (optional, defaults to `TranslationContext`): The type of the final result returned by the `translate()` method. This is typically the `TranslationContext` itself, but can be a different type if your translator needs to return a processed version of the context (e.g., a final SQL string from a query builder).
+  - `TFilterVisitorOutput` (optional, defaults to `any`): The specific output type for the `visitFilter` method. This allows filters to return an intermediate representation (e.g., a condition string and its parameters) that can then be integrated into the main `TranslationContext`. The `visitAndGroup` and `visitOrGroup` methods, however, return `void` and directly modify the `TranslationContext`.
 
 - **`ICriteriaVisitor`**: The interface that `CriteriaTranslator` implements. It defines all the `visit...` methods that your translator will need to override to handle each type of node in the `Criteria` tree (filters, filter groups, joins, etc.).
 
-The translation process generally begins by calling the `translate()` method of your translator, which internally calls `criteria.accept(this, initialContext)`.
+The translation process is initiated by calling the `translate()` method, which is an **abstract method that you must implement**. Inside your `translate` implementation, you are responsible for starting the visitor traversal by calling `criteria.accept(this, initialContext)`. The `accept` method of each `Criteria` component will then call the appropriate `visit...` method on your translator, passing the component itself and the `TranslationContext`. For instance, a `RootCriteria`'s `accept` method will call `visitor.visitRoot(...)`, while a `Filter`'s `accept` method will call `visitor.visitFilter(...)`. This "double dispatch" mechanism is the core of the Visitor pattern.
 
 ---
 
@@ -45,1084 +43,508 @@ The translation process generally begins by calling the `translate()` method of
 
 The first step is to create a new class that extends `CriteriaTranslator`. You will need to define the generic types according to what your translator will produce and require.
 
-```typescript
-import {
-  CriteriaTranslator,
-  RootCriteria,
-  InnerJoinCriteria,
-  // ... other necessary imports
-  FilterOperator,
-  type CriteriaSchema,
-  type SelectedAliasOf,
-  type PivotJoin,
-  type SimpleJoin,
-  type JoinRelationType,
-  type Filter,
-  type FilterGroup,
-} from '@nulledexp/translatable-criteria';
+For the conceptual examples in this guide, we will use the following types for `TranslationContext` and `TFilterVisitorOutput`, which align with the [`PseudoSqlTranslator`](../../../criteria/translator/example/pseudo-sql.translator.ts) example:
 
-// Define your types for the context and output
-// For example, if translating to an SQL query builder:
-// type MyQueryBuilder = SomeSQLQueryBuilder;
-// type MyFilterConditionOutput = string; // or a condition object
+Here is the basic structure of your custom translator class, showing only the public method signatures you'll need to implement:
 
-// For this example, we'll use simple types
-type MyQueryBuilder = {
-  selectFields: string[];
-  fromTable?: string;
+```typescript
+type PseudoSqlParts = {
+  select: string[];
+  from: string;
   joins: string[];
-  conditions: string[];
+  where: string[];
   orderBy: string[];
   limit?: number;
   offset?: number;
   params: any[];
 };
 
-type MyFilterConditionOutput = {
+type PseudoSqlFilterOutput = {
   condition: string;
   params: any[];
 };
 
 export class MyCustomTranslator extends CriteriaTranslator<
-  MyQueryBuilder, // TranslationContext: The object modified during translation
-  MyQueryBuilder, // TranslationOutput: The final result of translate()
-  MyFilterConditionOutput // TFilterVisitorOutput: The result of visiting filters/groups
+  PseudoSqlParts,
+  { query: string; params: any[] },
+  PseudoSqlFilterOutput
 > {
-  private paramCounter = 0;
-
-  private generateParamPlaceholder(): string {
-    // Internal logic can vary based on the type of placeholder you need:
-    // If using named placeholders like :p0, :p1 (common in TypeORM, for example)
-    // return `:p${this.paramCounter++}`;
-    // If using positional placeholders like ? (common in native MySQL, SQLite)
-    this.paramCounter++; // Only to count if necessary, placeholder is fixed
-    return `?`;
-    // Or the specific placeholder for your DB/ORM.
+  public override translate<RootCriteriaSchema extends CriteriaSchema>(
+    criteria: RootCriteria<RootCriteriaSchema>,
+    source: PseudoSqlParts,
+  ): { query: string; params: any[] } {
+    return { query: '', params: [] };
   }
 
-  // Implementation of visit... methods
-  // ... (see following sections)
-}
-```
-
-In this example:
-
-- `MyQueryBuilder`: Would be your class or interface for building the native query.
-- `MyFilterConditionOutput`: The output type of the `visitFilter` and `visit...Group` methods, assuming they generate objects containing condition strings and their parameters.
+  public override visitRoot<RootCSchema extends CriteriaSchema>(
+    criteria: RootCriteria<RootCSchema>,
+    context: PseudoSqlParts,
+  ): void {}
 
----
+  public override visitInnerJoin<
+    ParentCSchema extends CriteriaSchema,
+    JoinCSchema extends CriteriaSchema,
+  >(
+    criteria: InnerJoinCriteria<JoinCSchema>,
+    parameters:
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
+    context: PseudoSqlParts,
+  ): void {}
 
-## 3. Implementing `visit...` Methods
+  public override visitLeftJoin<
+    ParentCSchema extends CriteriaSchema,
+    JoinCSchema extends CriteriaSchema,
+  >(
+    criteria: LeftJoinCriteria<JoinCSchema>,
+    parameters:
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
+    context: PseudoSqlParts,
+  ): void {}
 
-Now, you must implement the abstract `visit...` methods from `CriteriaTranslator`.
+  public override visitOuterJoin<
+    ParentCSchema extends CriteriaSchema,
+    JoinCSchema extends CriteriaSchema,
+  >(
+    criteria: OuterJoinCriteria<JoinCSchema>,
+    parameters:
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
+    context: PseudoSqlParts,
+  ): void {}
 
-### 3.1. `visitRoot`
+  public override visitFilter<FieldType extends string>(
+    filter: Filter<FieldType, FilterOperator>,
+    currentAlias: string,
+    context: PseudoSqlParts,
+  ): PseudoSqlFilterOutput {
+    return { condition: '', params: [] };
+  }
 
-This is the main entry point for translating a `RootCriteria`. This is where you will typically initialize your query, process the main filters, joins, ordering, and pagination of the `RootCriteria`.
+  public override visitAndGroup<FieldType extends string>(
+    group: FilterGroup<FieldType>,
+    currentAlias: string,
+    context: PseudoSqlParts,
+  ): void {}
 
-```typescript
-  visitRoot<
-    RootCriteriaSchema extends CriteriaSchema,
-    RootAlias extends SelectedAliasOf<RootCriteriaSchema>,
-  >(
-    criteria: RootCriteria<RootCriteriaSchema, RootAlias>,
-    queryBuilder: MyQueryBuilder, // The initial context
-  ): MyQueryBuilder {
-    this.paramCounter = 0; // Reset parameter counter for each main translation
-
-    // 1. FROM clause
-    queryBuilder.fromTable = `${criteria.sourceName} AS ${criteria.alias}`;
-
-    // 2. SELECT clause
-    queryBuilder.selectFields = criteria.select.map(
-      (field) => `${criteria.alias}.${String(field)}`,
-    );
-    if (criteria.selectAll && queryBuilder.selectFields.length === 0) {
-        queryBuilder.selectFields.push(`${criteria.alias}.*`);
-    }
+  public override visitOrGroup<FieldType extends string>(
+    group: FilterGroup<FieldType>,
+    currentAlias: string,
+    context: PseudoSqlParts,
+  ): void {}
+}
+```
 
-    // 3. JOINs
-    for (const joinDetail of criteria.joins) {
-      // The context (queryBuilder) is passed and modified by the visitJoin methods
-      joinDetail.criteria.accept(this, joinDetail.parameters, queryBuilder);
-    }
+In this example:
 
-    // 4. WHERE clause for RootCriteria
-    if (criteria.rootFilterGroup.items.length > 0) {
-      const rootFilterResult = criteria.rootFilterGroup.accept(
-        this,
-        criteria.alias,
-        queryBuilder, // Context here might be different if filters don't directly modify QB
-      );
-      if (rootFilterResult.condition) {
-        queryBuilder.conditions.push(rootFilterResult.condition);
-        queryBuilder.params.push(...rootFilterResult.params);
-      }
-    }
+- `PseudoSqlParts`: Is our `TranslationContext`, representing the accumulating parts of the SQL query.
+- `{ query: string; params: any[] }`: Is our `TranslationOutput`, the final result returned by the `translate()` method.
+- `PseudoSqlFilterOutput`: Is our `TFilterVisitorOutput`, the result of visiting individual filters.
 
-    // 5. Cursor condition (if it exists, add to WHERE)
-    if (criteria.cursor) {
-        const cursorFilters = criteria.cursor.filters;
-        const op = criteria.cursor.operator === FilterOperator.GREATER_THAN ? '>' : '<';
-        // const orderDir = criteria.cursor.order; // Not used directly in this simple SQL example
-
-        const primaryCursorFilter = cursorFilters[0]!;
-        const primaryParamName = this.generateParamPlaceholder(); // Use a unique parameter name
-        queryBuilder.params.push(primaryCursorFilter.value);
-        let cursorCondition = `(${criteria.alias}.${String(primaryCursorFilter.field)} ${op} :${primaryParamName}`;
-
-        if (cursorFilters.length === 2) {
-            const secondaryCursorFilter = cursorFilters[1]!;
-            const secondaryParamName = this.generateParamPlaceholder(); // Use a unique parameter name
-            queryBuilder.params.push(secondaryCursorFilter.value);
-            cursorCondition += ` OR (${criteria.alias}.${String(primaryCursorFilter.field)} = :${primaryParamName} AND ${criteria.alias}.${String(secondaryCursorFilter.field)} ${op} :${secondaryParamName}))`;
-        } else {
-            cursorCondition += `)`;
-        }
-        queryBuilder.conditions.push(cursorCondition);
-
-        // Ensure cursor's orderBy is applied
-        // In a real translator, this might need more complex logic to ensure correct order
-        // and avoid duplicates if already in criteria.orders.
-        // For simplicity, we add them here.
-        criteria.orders.forEach(order => { // Assuming cursor orders are in criteria.orders
-             queryBuilder.orderBy.push(`${criteria.alias}.${String(order.field)} ${order.direction}`);
-        });
-    }
+---
 
-    // 6. ORDER BY
-    // Ordering logic must be careful, especially with cursors.
-    // The translator is responsible for:
-    //   a. If a cursor exists, its sort fields MUST take precedence.
-    //   b. Then, other `Order`s defined in the `RootCriteria` and `JoinCriteria`s are applied.
-    //   c. All `Order`s (after cursor-defined ones) must be globally sorted by their `sequenceId`
-    //      before being applied, to maintain deterministic sorting.
-    // (See section "4.1. Ordering (orderBy)" and the PseudoSqlTranslator example
-    // for a more detailed implementation of this logic).
-
-    // Conceptual simplified example (actual logic is more complex and shown in section 4.1 and the example):
-    if (criteria.cursor) {
-      // Cursor's orderBy fields are applied first.
-      // Example: criteria.cursor.filters.forEach(cf => queryBuilder.orderBy.push(`${criteria.alias}.${String(cf.field)} ${criteria.cursor.order}`));
-      // Then, other orders, avoiding duplicates and using sequenceId.
-    } else {
-      // If no cursor, apply all collected orders, sorted by sequenceId.
-      // Example:
-      // const allOrders = []; // Collect from criteria.orders and joins
-      // allOrders.sort((a, b) => a.order.sequenceId - b.order.sequenceId);
-      // allOrders.forEach(({alias, order}) => queryBuilder.orderBy.push(`${alias}.${String(order.field)} ${order.direction}`));
-    }
+## Helper: `escapeField`
 
-    // 7. LIMIT / OFFSET
-    if (criteria.take > 0) {
-      queryBuilder.limit = criteria.take;
-    }
-    if (criteria.skip > 0) {
-      queryBuilder.offset = criteria.skip;
-    }
+Many translators will need a utility function to properly escape field names to prevent SQL injection or to conform to the target query language's syntax. This helper is used in the conceptual examples below.
 
-    return queryBuilder;
-  }
+```typescript
+function escapeField(field: string, alias?: string): string {
+  const escape = (str: string) => `\`${str.replace(/`/g, '``')}\``;
+  return alias ? `${escape(alias)}.${escape(field)}` : escape(field);
+}
 ```
 
-**Considerations for `visitRoot`:**
+This function takes a field name and an optional alias, and returns a string with the field properly escaped and prefixed (e.g., `` `alias`.`field` ``).
 
-- **Initialization:** Set up the `FROM` part of your query using `criteria.sourceName` and `criteria.alias`.
-- **Filters:** Call `criteria.rootFilterGroup.accept(this, criteria.alias, context)` to process the `RootCriteria`'s filters. The `context` here could be your `queryBuilder` or an object where conditions are attached.
-- **Joins:** Iterate over `criteria.joins` and call `joinDetail.criteria.accept(this, joinDetail.parameters, context)` for each one.
-- **Ordering and Pagination:** Apply the logic for `orderBy`, `take`, `skip`, and `cursor` at the end.
-- **Field Selection:** Construct the `SELECT` clause based on `criteria.select`.
+---
 
-### 3.2. `visitInnerJoin`, `visitLeftJoin`, `visitOuterJoin`
+## 3. Implementing `visit...` Methods
 
-These methods handle the different types of joins. They receive the `JoinCriteria` instance, the join `parameters` (which include information about the parent and child of the join), and the `context`.
+Now, you must implement the abstract `visit...` methods from `CriteriaTranslator`.
 
-```typescript
-  private applyJoin<
-    ParentCSchema extends CriteriaSchema,
-    JoinCriteriaSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCriteriaSchema>,
-  >(
-    joinType: 'INNER' | 'LEFT' | 'OUTER',
-    criteria: // The current JoinCriteria being visited
-      | InnerJoinCriteria<JoinCriteriaSchema, JoinAlias>
-      | LeftJoinCriteria<JoinCriteriaSchema, JoinAlias>
-      | OuterJoinCriteria<JoinCriteriaSchema, JoinAlias>,
-    parameters:
-      | PivotJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>
-      | SimpleJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>,
-    queryBuilder: MyQueryBuilder, // Context: the main query builder
-  ): MyQueryBuilder {
-    const joinTable = `${criteria.sourceName} AS ${criteria.alias}`;
-    let onCondition = '';
-
-    if ('pivot_source_name' in parameters) {
-      // Many-to-many join
-      const pivotAlias = `${parameters.parent_alias}_${criteria.alias}_pivot`;
-      const pivotTable = `${parameters.pivot_source_name} AS ${pivotAlias}`;
-
-      const firstJoin = `${joinType} JOIN ${pivotTable} ON ${parameters.parent_alias}.${String(parameters.parent_field.reference)} = ${pivotAlias}.${parameters.parent_field.pivot_field}`;
-      queryBuilder.joins.push(firstJoin);
-
-      onCondition = `${pivotAlias}.${parameters.join_field.pivot_field} = ${criteria.alias}.${String(parameters.join_field.reference)}`;
-      queryBuilder.joins.push(`${joinType} JOIN ${joinTable} ON ${onCondition}`);
-    } else {
-      // Simple join
-      onCondition = `${parameters.parent_alias}.${String(parameters.parent_field)} = ${criteria.alias}.${String(parameters.join_field)}`;
-      queryBuilder.joins.push(`${joinType} JOIN ${joinTable} ON ${onCondition}`);
-    }
+### 3.1. `visitRoot`
 
-    // Filters on the JOIN (added to ON clause or as AND after)
-    if (criteria.rootFilterGroup.items.length > 0) {
-      const joinFilterResult = criteria.rootFilterGroup.accept(
-        this,
-        criteria.alias,
-        queryBuilder,
-      );
-      if (joinFilterResult.condition) {
-        const lastJoinIndex = queryBuilder.joins.length -1;
-        if(queryBuilder.joins[lastJoinIndex]) { // Ensure there's a join to append AND to
-            queryBuilder.joins[lastJoinIndex] += ` AND (${joinFilterResult.condition})`;
-            queryBuilder.params.push(...joinFilterResult.params);
-        }
-      }
-    }
+This is the main entry point for translating a `RootCriteria`. This is where you will typically initialize your query, process the main filters, joins, ordering, and pagination of the `RootCriteria`.
 
-    // Field selection from Join
-    criteria.select.forEach((field) => {
-      queryBuilder.selectFields.push(`${criteria.alias}.${String(field)}`);
-    });
-    if (criteria.selectAll && criteria.select.length === 0) {
-        queryBuilder.selectFields.push(`${criteria.alias}.*`);
-    }
+```typescript
+public override visitRoot<RootCSchema extends CriteriaSchema>(
+  criteria: RootCriteria<RootCSchema>,
+  context: PseudoSqlParts,
+): void {}
+```
 
-    // Collect OrderBy from join to apply globally
-    // (This logic might need refinement to ensure correct global order)
-    criteria.orders.forEach(order => {
-        // Example: queryBuilder.orderBy.push(`${criteria.alias}.${String(order.field)} ${order.direction}`);
-        // Or store them in a class property to apply at the end in visitRoot.
-    });
-
-    // ***** START OF MODIFICATION FOR NESTED JOINS *****
-    // If this JoinCriteria (the current 'criteria') has its own joins defined,
-    // process them recursively.
-    for (const subJoinDetail of criteria.joins) {
-      // The 'queryBuilder' (context) is passed along and modified.
-      subJoinDetail.criteria.accept(this, subJoinDetail.parameters, queryBuilder);
-    }
-    // ***** END OF MODIFICATION FOR NESTED JOINS *****
+**Explanation:**
 
-    return queryBuilder;
-  }
+This method is the starting point of the translation process. It receives the `RootCriteria` object and the `TranslationContext` (our `sqlParts` object). Its primary responsibilities are:
 
-  visitInnerJoin<
-    ParentCSchema extends CriteriaSchema,
-    JoinCriteriaSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCriteriaSchema>,
-  >(
-    criteria: InnerJoinCriteria<JoinCriteriaSchema, JoinAlias>,
-    parameters:
-      | PivotJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>
-      | SimpleJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>,
-    context: MyQueryBuilder,
-  ): MyQueryBuilder {
-    return this.applyJoin('INNER', criteria, parameters, context);
-  }
+- **Initializing the `FROM` clause:** It uses `criteria.sourceName` and `criteria.alias` to set up the main table for the query.
+- **Processing field selection:** It maps `criteria.select` to the `SELECT` clause, ensuring fields are properly qualified with the entity's alias.
+- **Handling joins:** It iterates through `criteria.joins` and recursively calls `accept` on each `JoinCriteria` to process nested joins.
+- **Processing root filters:** If `criteria.rootFilterGroup` contains filters, it calls `accept` on this group to translate them into `WHERE` conditions.
+- **Applying pagination:** It checks `criteria.take` and `criteria.skip` for offset-based pagination, and `criteria.cursor` for cursor-based pagination, adding the corresponding `LIMIT`, `OFFSET`, or complex `WHERE` clauses.
+- **Collecting ordering rules:** It gathers `Order` objects from `criteria.orders` to be applied later.
 
-  visitLeftJoin<
-    ParentCSchema extends CriteriaSchema,
-    JoinCriteriaSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCriteriaSchema>,
-  >(
-    criteria: LeftJoinCriteria<JoinCriteriaSchema, JoinAlias>,
-    parameters:
-      | PivotJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>
-      | SimpleJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>,
-    context: MyQueryBuilder,
-  ): MyQueryBuilder {
-    return this.applyJoin('LEFT', criteria, parameters, context);
-  }
+**Available `Criteria` properties:** `criteria.sourceName`, `criteria.alias`, `criteria.select`, `criteria.orders`, `criteria.joins`, `criteria.rootFilterGroup`, `criteria.cursor`, `criteria.take`, `criteria.skip`.
 
-  visitOuterJoin<
-    ParentCSchema extends CriteriaSchema,
-    JoinCriteriaSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCriteriaSchema>,
-  >(
-    criteria: OuterJoinCriteria<JoinCriteriaSchema, JoinAlias>,
-    parameters:
-      | PivotJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>
-      | SimpleJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>,
-    context: MyQueryBuilder,
-  ): MyQueryBuilder {
-    // Note: FULL OUTER JOIN support can vary and might require special syntax.
-    return this.applyJoin('OUTER', criteria, parameters, context);
-  }
-```
+For a complete implementation, refer to the `visitRoot` method in `src/criteria/translator/example/pseudo-sql.translator.ts`.
 
-**Considerations for `visitJoin...` methods:**
-
-- **Join Type:** Use the appropriate join type (`INNER JOIN`, `LEFT JOIN`, etc.) based on the specific `visit...` method being implemented.
-- **Table and Alias:** Use `criteria.sourceName` and `criteria.alias` for the table being joined (the `criteria` object is the `JoinCriteria` instance passed to the method).
-- **`ON` Condition:**
-  - For `SimpleJoin` (relations like 'one_to_one', 'one_to_many', 'many_to_one' as defined by `parameters.relation_type`): Construct the `ON` condition using `parameters.parent_alias`.`parameters.parent_field` = `criteria.alias`.`parameters.join_field`.
-  - For `PivotJoin` (relation 'many_to_many' as defined by `parameters.relation_type`): You will typically need two join operations in your native query. The first joins the parent table (identified by `parameters.parent_alias`) to the pivot table (`parameters.pivot_source_name`) using `parameters.parent_field.reference` (from parent) and `parameters.parent_field.pivot_field` (from pivot). The second joins the pivot table to the target joined table (`criteria.sourceName` aliased as `criteria.alias`) using `parameters.join_field.pivot_field` (from pivot) and `parameters.join_field.reference` (from target).
-- **Accessing Metadata:** The `parameters` object (of type `PivotJoin` or `SimpleJoin`) passed to these join visit methods contains:
-  - `parameters.parent_schema_metadata`: Metadata from the root `CriteriaSchema` of the parent criteria.
-  - `parameters.join_metadata`: Metadata from the specific join configuration in the parent schema's `joins` array.
-    Translators can use this metadata for custom logic, such as applying database-specific hints or handling custom join conditions.
-- **Filters on the Join:** If `criteria.rootFilterGroup` (from the `JoinCriteria` being visited) has filters, these should be applied as additional conditions. This is typically done by appending them to the `ON` clause of the join (e.g., `... ON condition AND (join_filters)`) or as separate `WHERE` conditions if the database/ORM handles it that way for outer joins. Call `criteria.rootFilterGroup.accept(this, criteria.alias, context)` to process these filters.
-- **Field Selection from Join:**
-  - If `criteria.selectAll` (from the `JoinCriteria`) is `true`, all fields from `criteria.schema.fields` should be added to the main query's selection, prefixed with `criteria.alias`.
-  - If `criteria.selectAll` is `false`, only the fields in `criteria.select` should be added, prefixed with `criteria.alias`.
-- **Ordering from Join:** If `criteria.orders` (from the `JoinCriteria`) has ordering rules, these should be collected. All collected orders (from root and all joins) must be sorted globally by their `sequenceId` at the end of the `visitRoot` method before being applied to the final query, to ensure a deterministic sort order.
-- **Nested Joins:** Crucially, if the `criteria` (the `JoinCriteria` being visited) itself has `criteria.joins` defined (i.e., joins chained off a join), you must iterate over them and recursively call `subJoinDetail.criteria.accept(this, subJoinDetail.parameters, context)` to process these nested joins. The `context` (e.g., your query builder) is passed along and modified.
+### 3.2. `visitInnerJoin`, `visitLeftJoin`, `visitOuterJoin`
 
-### 3.3. `visitFilter`
+These methods handle the different types of joins. They receive the `JoinCriteria` instance, the join `parameters` (which include information about the parent and child of the join), and the `context`.
 
-This method translates an individual `Filter` into a condition for your query language.
+To avoid code repetition, a common practice is to create a private helper method (like `applyJoin` below) that handles the shared logic for all join types.
 
 ```typescript
-    visitFilter<
-FieldType extends string,
-        Operator extends FilterOperator,
+private applyJoin<
+  ParentCSchema extends CriteriaSchema,
+  JoinCSchema extends CriteriaSchema,
 >(
-        filter: Filter<FieldType, Operator>,
-        currentAlias: string,
-        // queryBuilder: MyQueryBuilder, // Context might not be needed here if only returning the condition
-): MyFilterConditionOutput {
-  const fieldName = `${currentAlias}.${String(filter.field)}`;
-  // const paramName = this.generateParamPlaceholder(); // Generate unique placeholder
-  let condition = '';
-  const params: any[] = []; // Array to collect parameters
-
-  switch (filter.operator) {
-    case FilterOperator.EQUALS:
-      const eqParam = this.generateParamPlaceholder();
-      condition = `${fieldName} = ${eqParam}`; // Use placeholder
-      params.push(filter.value);
-      break;
-    case FilterOperator.NOT_EQUALS:
-      const neqParam = this.generateParamPlaceholder();
-      condition = `${fieldName} != ${neqParam}`;
-      params.push(filter.value);
-      break;
-    case FilterOperator.LIKE:
-      const likeParam = this.generateParamPlaceholder();
-      condition = `${fieldName} LIKE ${likeParam}`;
-      params.push(filter.value); // Assume value already has '%'
-      break;
-    case FilterOperator.CONTAINS: // Could be same as LIKE or use a specific function
-      const containsParam = this.generateParamPlaceholder();
-      condition = `${fieldName} LIKE ${containsParam}`;
-      params.push(`%${filter.value}%`);
-      break;
-    case FilterOperator.IN:
-      if (Array.isArray(filter.value) && filter.value.length > 0) {
-        const inPlaceholders = filter.value
-                .map(() => this.generateParamPlaceholder())
-                .join(', ');
-        condition = `${fieldName} IN (${inPlaceholders})`;
-        params.push(...filter.value);
-      } else {
-        // If array is empty or not an array, condition is usually false.
-        condition = '1=0'; // Or your DB's way for an always-false condition
-      }
-      break;
-    case FilterOperator.IS_NULL:
-      condition = `${fieldName} IS NULL`;
-      // No parameters for IS NULL
-      break;
-          // ... Implement all necessary FilterOperators
-    case FilterOperator.BETWEEN: // NEW CASE
-      if (Array.isArray(filter.value) && filter.value.length === 2) {
-        const paramMin = this.generateParamPlaceholder();
-        const paramMax = this.generateParamPlaceholder();
-        condition = `${fieldName} BETWEEN ${paramMin} AND ${paramMax}`;
-        params.push(filter.value[0], filter.value[1]);
-      } else {
-        // Handle invalid value for BETWEEN, perhaps throw error or false condition
-        condition = '1=0'; // Condition that is always false
-      }
-      break;
-    case FilterOperator.MATCHES_REGEX: // NEW CASE
-      // Implementation will depend on the database (e.g., REGEXP in MySQL, ~ in PostgreSQL)
-      const regexParam = this.generateParamPlaceholder();
-      condition = `${fieldName} REGEXP ${regexParam}`; // Example MySQL
-      params.push(filter.value);
-      break;
-    case FilterOperator.JSON_CONTAINS:
-      // ... (your existing implementation for JSON_CONTAINS)
-      // Conceptual example for MySQL:
-      if (typeof filter.value === 'object' && filter.value !== null) {
-        const conditions: string[] = [];
-        for (const pathKey in filter.value) {
-          const pathValue = (filter.value as Record<string, any>)[pathKey];
-          // Example: JSON_CONTAINS(metadata, '"tech"', '$.tags')
-          // Or for equality of a value at a path: JSON_EXTRACT(metadata, '$.views') = 100
-          conditions.push(
-                  `JSON_CONTAINS(${fieldName}, CAST(${this.generateParamPlaceholder()} AS JSON), '$.${pathKey}')`,
-          );
-          params.push(pathValue); // Translator might need to cast pathValue to JSON string
-        }
-        condition = conditions.join(' AND ');
-      } else {
-        condition = '1=0';
-      }
-      break;
-    case FilterOperator.ARRAY_CONTAINS_ELEMENT:
-      // ... (your existing implementation for ARRAY_CONTAINS_ELEMENT)
-      const arrayElemParam = this.generateParamPlaceholder();
-      if (
-              typeof filter.value === 'object' &&
-              filter.value !== null &&
-              !Array.isArray(filter.value)
-      ) {
-        const jsonPath = Object.keys(filter.value)[0]!;
-        const elementToFind = (filter.value as Record<string, any>)[
-                jsonPath
-                ];
-        condition = `JSON_CONTAINS(${fieldName}, CAST(${arrayElemParam} AS JSON), '$.${jsonPath}')`;
-        params.push(elementToFind);
-      } else {
-        condition = `${arrayElemParam} = ANY(${fieldName})`; // Example PostgreSQL
-        params.push(filter.value);
-      }
-      break;
-    default:
-      throw new Error(
-              `Translator: Unsupported filter operator '${filter.operator}'`,
-      );
-  }
-  // Ensure undefined parameters are converted to null if necessary
-  return { condition, params: params.map((p) => (p === undefined ? null : p)) };
-}
+  joinType: 'INNER' | 'LEFT' | 'FULL OUTER',
+  criteria:
+    | InnerJoinCriteria<JoinCSchema>
+    | LeftJoinCriteria<JoinCSchema>
+    | OuterJoinCriteria<JoinCSchema>,
+  parameters:
+    | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+    | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
+  sqlParts: PseudoSqlParts,
+): void {}
 ```
 
-**Considerations for `visitFilter`:**
-
-- **Field and Alias:** The `currentAlias` tells you which entity the `filter.field` belongs to.
-- **Operator:** Implement the logic for each `FilterOperator` that your data source supports.
-- **Value:** The `filter.value` must be formatted or parameterized appropriately. For operators like `IN`, `value` will be an array. For JSON/Array operators, `value` can be an object or an array, and you'll need to interpret the JSON path if applicable.
-- **Parameterization:** It is **crucial** to use parameterized queries to prevent SQL injection. Do not directly concatenate `filter.value` into the query string. Instead, use placeholders and pass the values through your query builder's parameter mechanism.
-
-### 3.4. `visitAndGroup`, `visitOrGroup`
-
-These methods handle groups of filters. They receive a `FilterGroup` and must iterate over its `items`, processing them recursively and joining them with the appropriate logical operator (`AND` or `OR`).
-
 ```typescript
-  visitAndGroup<FieldType extends string>(
-    group: FilterGroup<FieldType>,
-    currentAlias: string,
-    _context: MyQueryBuilder, // Context may or may not be used/modified here
-  ): MyFilterConditionOutput {
-    const conditions: string[] = [];
-    const allParams: any[] = [];
-
-    group.items.forEach((item) => {
-      const result = item.accept(this, currentAlias, _context); // _context is passed
-      if (result.condition) {
-        conditions.push(result.condition);
-        allParams.push(...result.params);
-      }
-    });
-
-    if (conditions.length === 0) return { condition: '', params: [] };
-    return {
-      condition: `(${conditions.join(' AND ')})`,
-      params: allParams,
-    };
-  }
+public override visitInnerJoin<
+  ParentCSchema extends CriteriaSchema,
+  JoinCSchema extends CriteriaSchema,
+>(
+  criteria: InnerJoinCriteria<JoinCSchema>,
+  parameters:
+    | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+    | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
+  context: PseudoSqlParts,
+): void {}
+```
 
-  visitOrGroup<FieldType extends string>(
-    group: FilterGroup<FieldType>,
-    currentAlias: string,
-    _context: MyQueryBuilder,
-  ): MyFilterConditionOutput {
-    const conditions: string[] = [];
-    const allParams: any[] = [];
-
-    group.items.forEach((item) => {
-      const result = item.accept(this, currentAlias, _context);
-      if (result.condition) {
-        conditions.push(result.condition);
-        allParams.push(...result.params);
-      }
-    });
-
-    if (conditions.length === 0) return { condition: '', params: [] };
-    return {
-      condition: `(${conditions.join(' OR ')})`,
-      params: allParams,
-    };
-  }
+```typescript
+public override visitLeftJoin<
+  ParentCSchema extends CriteriaSchema,
+  JoinCSchema extends CriteriaSchema,
+>(
+  criteria: LeftJoinCriteria<JoinCSchema>,
+  parameters:
+    | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+    | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
+  context: PseudoSqlParts,
+): void {}
 ```
 
-**Considerations for `visit...Group` methods:**
+```typescript
+public override visitOuterJoin<
+  ParentCSchema extends CriteriaSchema,
+  JoinCSchema extends CriteriaSchema,
+>(
+  criteria: OuterJoinCriteria<JoinCSchema>,
+  parameters:
+    | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+    | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
+  context: PseudoSqlParts,
+): void {}
+```
 
-- **Recursion:** Each `item` in `group.items` can be another `FilterGroup` or a `Filter`. Call `item.accept(this, currentAlias, context)` for each one.
-- **Grouping:** Ensure that the generated conditions are correctly grouped with parentheses if necessary, especially when mixing `AND` and `OR`.
+**Explanation (for `applyJoin` and the `visit...Join` methods):**
 
----
+These methods are responsible for translating join conditions into the target query language. Each `visit...Join` method simply calls the `applyJoin` helper, passing the specific `joinType` (e.g., 'INNER', 'LEFT', 'FULL OUTER').
 
-## 4. Handling Ordering, Pagination, and Selection
+The `applyJoin` helper's responsibilities include:
 
-These logics are generally applied in `visitRoot` after all main joins and filters have been processed.
+- **Constructing the `JOIN` clause:** It uses `criteria.sourceName` (the table being joined) and `parameters.join_alias` (its alias in the query) to build the `JOIN` part of the query.
+- **Defining the `ON` condition:**
+- For `SimpleJoin` (one-to-one, one-to-many, many-to-one relations), it constructs the `ON` condition using `parameters.parent_alias`.`parameters.parent_field` = `parameters.join_alias`.`parameters.join_field`.
+- For `PivotJoin` (many-to-many relations), it typically involves two `JOIN` operations: one from the parent to the pivot table, and another from the pivot table to the target joined table. It constructs the `ON` conditions for both.
+- **Applying filters on the join:** If `criteria.rootFilterGroup` (from the `JoinCriteria` being visited) has filters, it processes them by calling `criteria.rootFilterGroup.accept(this, parameters.join_alias, context)` and appends their conditions to the `ON` clause using `AND`.
+- **Selecting fields from the joined entity:** It maps `criteria.select` (from the `JoinCriteria`) to the main `SELECT` clause, ensuring fields are prefixed with `parameters.join_alias`.
+- **Collecting ordering rules:** It adds `criteria.orders` (from the `JoinCriteria`) to a global collection of orders (e.g., `this.collectedOrders` in [`PseudoSqlTranslator`](../../../criteria/translator/example/pseudo-sql.translator.ts)) to be processed later in `visitRoot`.
+- **Processing nested joins:** Crucially, if the `JoinCriteria` being visited itself has `criteria.joins` defined (i.e., joins chained off a join), it iterates over them and recursively calls `subJoinDetail.criteria.accept(this, subJoinDetail.parameters, context)` to process them.
 
-### 4.1. Ordering (`orderBy`)
+**Available `Criteria` properties:** `criteria.sourceName`, `criteria.alias`, `criteria.select`, `criteria.orders`, `criteria.joins`, `criteria.rootFilterGroup`.
+**Available `parameters` properties:** `parameters.parent_alias`, `parameters.join_alias`, `parameters.parent_field`, `parameters.join_field`, `parameters.pivot_source_name`, `parameters.parent_identifier`, `parameters.parent_schema_metadata`, `parameters.join_metadata`.
 
-Ordering defines how the query results should be sorted.
+For a complete implementation, refer to the `visitInnerJoin`, `visitLeftJoin`, `visitOuterJoin` methods and the `applyPseudoJoin` helper in `src/criteria/translator/example/pseudo-sql.translator.ts`.
 
-- During the visit of each `Criteria` (root or join) via their respective `visit...` methods, your translator should **collect** all `Order` objects defined using `.orderBy()`. Each `Order` object contains the field, direction, and a unique internal `sequenceId`.
-- At the end of processing in `visitRoot` (after all joins have been processed and before applying `LIMIT`/`OFFSET`):
-  1. If `criteria.cursor` exists, the fields defined in `cursor.filters` must be used to generate the **first** `ORDER BY` clauses, using the direction specified in `cursor.order`.
-  2. Then, take all collected `Order`s (from the root and all joins).
-  3. Sort this global collection of `Order`s by their `sequenceId`. This ensures that the order in which `orderBy` was defined throughout the `Criteria` construction is respected sequentially.
-  4. Convert these `Order`s (now sorted by sequence and following any cursor-defined orders) into the `ORDER BY` clauses of your native query. Ensure you avoid duplicating fields if they were already ordered by the cursor logic.
-- The `order.sequenceId` is crucial for maintaining a deterministic and predictable global order when multiple `orderBy` calls are applied in different parts of the `Criteria` (both on the root and in nested joins).
+### 3.3. `visitFilter`
 
-### 4.2. Offset Pagination (`setTake`, `setSkip`)
+This method translates an individual `Filter` into a condition for your query language.
 
-- If `criteria.take > 0`, apply a limit to the number of results.
-- If `criteria.skip > 0`, skip the specified number of results.
+```typescript
+public override visitFilter<FieldType extends string>(
+  filter: Filter<FieldType, FilterOperator>,
+  currentAlias: string,
+  context: PseudoSqlParts,
+): PseudoSqlFilterOutput {
+  return { condition: '', params: [] };
+}
+```
 
-### 4.3. Cursor Pagination (`setCursor`)
+**Explanation:**
 
-This is more complex and requires careful coordination with ordering. If `criteria.cursor` is defined:
+This method is responsible for converting a single `Filter` object into a query condition string and collecting any necessary parameters.
 
-- `cursor.filters`: Provides one or two `Filter`s (without the `operator`) that define the fields and values of the last item from the previous page.
-  - A single `Filter`: For simple pagination over one field (e.g., `created_at`).
-  - Two `Filter`s: For composite pagination (e.g., `created_at` and `uuid`).
-- `cursor.operator`: Will be `FilterOperator.GREATER_THAN` (for next page) or `FilterOperator.LESS_THAN` (for previous page, if the main order is inverted).
-- `cursor.order`: The main `OrderDirection` in which pagination is occurring.
+- **Generating the field name:** It constructs the fully qualified field name using `currentAlias` and `filter.field` (e.g., `` `alias`.`field` ``).
+- **Parameterization:** It is **crucial** to use placeholders (e.g., `?`, `$1`, `:paramName`) for `filter.value` to prevent SQL injection. It adds `filter.value` to the `TranslationContext`'s parameter list.
+- **Implementing operator logic:** It uses a `switch` statement or similar to handle each `FilterOperator`. The logic for each operator will vary based on the target query language and the expected type of `filter.value` (e.g., `BETWEEN` expects a tuple, `IN` expects an array, JSON operators expect objects).
+- **Returning the condition:** It returns an object containing the generated condition string and the collected parameters.
 
-**Translator Responsibilities:**
+**Available `Filter` properties:** `filter.field`, `filter.operator`, `filter.value`.
+**Available context:** `currentAlias`.
 
-1.  **Construct the Cursor `WHERE` Condition:**
+For a complete implementation, refer to the `visitFilter` method in `src/criteria/translator/example/pseudo-sql.translator.ts`.
 
-- For a simple cursor: `WHERE (cursor_field translated_cursor_operator cursor_value)`
-- For a composite cursor: `WHERE ( (primary_sort_field translated_op primary_cursor_value) OR (primary_sort_field = primary_cursor_value AND tie_breaker_field translated_op tie_breaker_cursor_value) )`. Adjust operators based on direction.
-- **Note on NULLs:** If a `cursor_value` is `null`, the translator must generate the appropriate SQL (e.g., `IS NULL` or `IS NOT NULL` conditions) rather than direct comparisons like `field = NULL`.
+### 3.4. `visitAndGroup`, `visitOrGroup`
 
-2.  **Apply Cursor Ordering with Priority:**
+These methods handle groups of filters. They receive a `FilterGroup` and must iterate over its `items`, processing them recursively and joining them with the appropriate logical operator (`AND` or `OR`).
 
-- The fields defined in `cursor.filters` **must** be the first in the final `ORDER BY` clause. The direction for these fields comes from `cursor.order`.
-- For example, if `cursor.filters` are `[{field: 'created_at', ...}, {field: 'uuid', ...}]` and `cursor.order` is `ASC`, the query must start with `ORDER BY created_at ASC, uuid ASC`.
+A common pattern is to use a private helper method (like `_buildConditionFromGroup` below) to handle the recursive logic for both `AND` and `OR` groups.
 
-3.  **Apply Additional Orderings:**
+```typescript
+private _buildConditionFromGroup(
+  group: FilterGroup<any>,
+  alias: string,
+  context: PseudoSqlParts,
+): PseudoSqlFilterOutput | undefined {
+  return undefined;
+}
+```
 
-- After the cursor fields, add any other `orderBy` clauses defined in the `Criteria` (root and joins). These should be globally sorted by their `sequenceId` before being added, and should be omitted if the field was already covered by the cursor's ordering.
-- **Important:** The `Criteria` **must** have `orderBy()` defined for the same fields used in `cursor.filters` and in the same direction as `cursor.order`. Although the translator prioritizes cursor fields for the `ORDER BY`, this consistency in the `Criteria` definition is crucial for pagination logic.
+```typescript
+public override visitAndGroup<FieldType extends string>(
+  group: FilterGroup<FieldType>,
+  currentAlias: string,
+  context: PseudoSqlParts,
+): void {}
+```
 
-### 4.4. Field Selection (`setSelect`)
+```typescript
+public override visitOrGroup<FieldType extends string>(
+  group: FilterGroup<FieldType>,
+  currentAlias: string,
+  context: PseudoSqlParts,
+): void {}
+```
 
-- In `visitRoot`, construct the initial `SELECT` clause using `criteria.select` (from the `RootCriteria`).
-- In each `visitJoin...`, if the `joinCriteria.select` has specific fields, add them to the main selection, usually prefixed with the join's alias (e.g., `SELECT root.field1, joined_alias.fieldA`).
-- If `criteria.selectAll` is `true` (or `criteria.select` is empty, which is the default behavior), select all fields from the corresponding schema.
+**Explanation (for `_buildConditionFromGroup` and the `visit...Group` methods):**
 
----
+These methods are responsible for translating `FilterGroup` objects into a combined query condition. The `visitAndGroup` and `visitOrGroup` methods typically call a helper like `_buildConditionFromGroup` and then add the resulting condition to the `TranslationContext`.
 
-## 5. State and Parameter Management
+The `_buildConditionFromGroup` helper's responsibilities include:
 
-Your translator will likely need to manage some state:
+- **Recursive traversal:** It iterates over `group.items`. For each `item` (which can be a `Filter` or another `FilterGroup`), it recursively calls `item.accept(this, currentAlias, context)`.
+- **Collecting conditions and parameters:** It accumulates the condition strings and parameters returned by the recursive `accept` calls.
+- **Combining conditions:** It joins the collected conditions using the `group.logicalOperator` (`AND` or `OR`).
+- **Ensuring grouping:** It wraps the combined conditions in parentheses (e.g., `(condition1 AND condition2)`) to ensure correct logical precedence, especially when mixing `AND` and `OR` groups.
+- **Returning the combined condition:** It returns an object containing the combined condition string and all collected parameters.
 
-- **Query Parameters:** Maintain a list or object for parameterized values. Each time you process a `filter.value` or a pagination value, add it to this collection and use a placeholder in the query.
-- **Parameter Counter:** If you use numbered placeholders (e.g., `$1, $2` or `?`), you'll need a counter.
-- **Accumulated Clauses:** You might have properties in your translator class to build up the different parts of the query (SELECT, FROM, JOINs, WHERE, ORDER BY, etc.).
+**Available `FilterGroup` properties:** `group.items`, `group.logicalOperator`.
+**Available context:** `currentAlias`.
 
-```typescript
-// (Inside your MyCustomTranslator class)
-
-// Example of simple state management:
-// private collectedSelects: string[] = [];
-// private collectedFrom: string = '';
-// private collectedJoins: string[] = [];
-// private collectedWhere: string[] = [];
-// private collectedOrderBy: string[] = [];
-// private collectedLimit?: number;
-// private collectedOffset?: number;
-// private queryParams: any[] = [];
-// private paramCounter: number = 0;
-
-// constructor() {
-//   super();
-//   this.resetState();
-// }
-
-// private resetState(): void {
-//   this.collectedSelects = [];
-//   this.collectedFrom = '';
-//   // ... reset all others
-//   this.queryParams = [];
-//   this.paramCounter = 0;
-// }
-
-// private addQueryParam(value: any): string {
-//   this.queryParams.push(value);
-//   return `?`; // Or $1, $2, etc., depending on your DB
-// }
-
-// The translate method could then assemble these parts.
-// public translate(criteria: RootCriteria<any, any>, initialContext?: any): string {
-//   this.resetState();
-//   criteria.accept(this, initialContext || {}); // Initial context could be an empty object
-//
-//   let sql = `SELECT ${this.collectedSelects.join(', ') || '*'}`;
-//   sql += ` FROM ${this.collectedFrom}`;
-//   if (this.collectedJoins.length > 0) sql += ` ${this.collectedJoins.join(' ')}`;
-//   if (this.collectedWhere.length > 0) sql += ` WHERE ${this.collectedWhere.join(' AND ')}`; // Simplified
-//   if (this.collectedOrderBy.length > 0) sql += ` ORDER BY ${this.collectedOrderBy.join(', ')}`;
-//   if (this.collectedLimit) sql += ` LIMIT ${this.collectedLimit}`;
-//   if (this.collectedOffset) sql += ` OFFSET ${this.collectedOffset}`;
-//   return sql;
-// }
-// public getParameters(): any[] {
-//    return this.queryParams;
-// }
-```
+For a complete implementation, refer to the `visitAndGroup` and `visitOrGroup` methods and the `_buildConditionFromGroup` helper in `src/criteria/translator/example/pseudo-sql.translator.ts`.
 
 ---
 
-## 6. Simplified Example: Pseudo-SQL Translator
+## 4. Handling Ordering, Pagination, and Selection
 
-This very basic example shows the structure, translating to a pseudo-SQL string.
+These logics are generally applied in `visitRoot` after all main joins and filters have been processed.
 
-```typescript
-import {
-  CriteriaTranslator,
-  RootCriteria,
-  InnerJoinCriteria,
-  LeftJoinCriteria,
-  OuterJoinCriteria,
-  Filter,
-  FilterGroup,
-  FilterOperator,
-  OrderDirection,
-  type Order,
-  type CriteriaSchema,
-  type SelectedAliasOf,
-  type PivotJoin,
-  type SimpleJoin,
-  type JoinRelationType,
-} from '@nulledexp/translatable-criteria';
+- **Ordering (`orderBy`):** Your translator should collect all `Order` objects from the root and all joins. At the end, sort this global collection by `order.sequenceId` to ensure a deterministic sort order, and then apply them to the query.
+- **Offset Pagination (`setTake`, `setSkip`):** If `criteria.take > 0` or `criteria.skip > 0`, apply the corresponding `LIMIT` and `OFFSET` to your query.
+- **Cursor Pagination (`setCursor`):** This is more complex. The translator must construct a `WHERE` condition based on `cursor.filters` and `cursor.operator`. The fields from `cursor.filters` must also be the first fields in the `ORDER BY` clause, using the direction from `cursor.order`.
+- **Field Selection (`setSelect`):** In `visitRoot` and `visit...Join`, construct the `SELECT` clause based on `criteria.select`. If `criteria.selectAll` is `true`, select all fields from the schema.
 
-type PseudoSqlParts = {
-  select: string[];
-  from: string;
-  joins: string[];
-  where: string[];
-  orderBy: string[];
-  limit?: number;
-  offset?: number;
-  params: any[];
-};
+---
 
-type PseudoSqlFilterOutput = {
-  condition: string;
-  params: any[];
-};
+## 5. State and Parameter Management
 
-type PseudoSqlTranslationResult = {
-  query: string;
-  params: any[];
-};
+Since the `translate` method is abstract, you are required to implement it. This implementation is where you manage the entire translation lifecycle, including state and parameter management. The recommended pattern is to encapsulate this logic within the translator class and reset it for each `translate()` call.
 
-function escapeField(field: string, alias?: string): string {
-  const escape = (str: string) => `\`${str.replace(/`/g, '``')}\``;
-  return alias ? `${escape(alias)}.${escape(field)}` : escape(field);
-}
+The following example shows the required implementation pattern for the `translate` method:
 
-class PseudoSqlTranslator extends CriteriaTranslator<
+```typescript
+class MyTranslatorWithState extends CriteriaTranslator<
   PseudoSqlParts,
-  PseudoSqlTranslationResult,
+  { query: string; params: any[] },
   PseudoSqlFilterOutput
 > {
-  private paramCounter = 0;
+  private paramCounter: number = 0;
   private collectedOrders: Array<{ alias: string; order: Order<string> }> = [];
 
-  private generateParamPlaceholder(): string {
-    this.paramCounter++;
-    return `?`;
-  }
-
-  public translate(
-    criteria: RootCriteria<any, any>,
-  ): PseudoSqlTranslationResult {
+  public override translate<RootCriteriaSchema extends CriteriaSchema>(
+    criteria: RootCriteria<RootCriteriaSchema>,
+    source: PseudoSqlParts,
+  ): { query: string; params: any[] } {
     this.paramCounter = 0;
     this.collectedOrders = [];
 
-    const initialSqlParts: PseudoSqlParts = {
-      select: [],
-      from: '',
-      joins: [],
-      where: [],
-      orderBy: [],
-      params: [],
-    };
-
-    const finalSqlParts = criteria.accept(this, initialSqlParts);
-
-    let sqlString = `SELECT ${finalSqlParts.select.join(', ') || '*'}`;
-    sqlString += ` FROM ${finalSqlParts.from}`;
-    if (finalSqlParts.joins.length > 0)
-      sqlString += ` ${finalSqlParts.joins.join(' ')}`;
-    if (finalSqlParts.where.length > 0)
-      sqlString += ` WHERE ${finalSqlParts.where.join(' AND ')}`;
-    if (finalSqlParts.orderBy.length > 0)
-      sqlString += ` ORDER BY ${finalSqlParts.orderBy.join(', ')}`;
-    if (finalSqlParts.limit !== undefined)
-      sqlString += ` LIMIT ${finalSqlParts.limit}`;
-    if (finalSqlParts.offset !== undefined)
-      sqlString += ` OFFSET ${finalSqlParts.offset}`;
+    const queryBuilder = source;
 
-    return {
-      query: sqlString,
-      params: finalSqlParts.params,
-    };
-  }
+    criteria.accept(this, queryBuilder);
 
-  visitRoot<
-    RootCriteriaSchema extends CriteriaSchema,
-    RootAlias extends SelectedAliasOf<RootCriteriaSchema>,
-  >(
-    criteria: RootCriteria<RootCriteriaSchema, RootAlias>,
-    sqlParts: PseudoSqlParts,
-  ): PseudoSqlParts {
-    sqlParts.from = `${escapeField(criteria.sourceName)} AS ${escapeField(
-      criteria.alias,
-    )}`;
-    sqlParts.select = criteria.select.map((f) =>
-      escapeField(String(f), criteria.alias),
-    );
-    if (criteria.selectAll && sqlParts.select.length === 0) {
-      sqlParts.select.push(`${escapeField(criteria.alias)}.*`);
+    let sqlString = `SELECT ${queryBuilder.select.join(', ') || '*'}`;
+    sqlString += ` FROM ${queryBuilder.from}`;
+    if (queryBuilder.joins.length > 0) {
+      sqlString += ` ${queryBuilder.joins.join(' ')}`;
     }
-
-    criteria.orders.forEach((order) =>
-      this.collectedOrders.push({ alias: criteria.alias, order }),
-    );
-
-    for (const joinDetail of criteria.joins) {
-      joinDetail.criteria.accept(this, joinDetail.parameters, sqlParts);
+    if (queryBuilder.where.length > 0) {
+      sqlString += ` WHERE ${queryBuilder.where.join(' AND ')}`;
     }
-
-    if (criteria.rootFilterGroup.items.length > 0) {
-      const filterResult = criteria.rootFilterGroup.accept(
-        this,
-        criteria.alias,
-        sqlParts,
-      );
-      if (filterResult.condition) {
-        sqlParts.where.push(filterResult.condition);
-        sqlParts.params.push(...filterResult.params);
-      }
+    if (queryBuilder.orderBy.length > 0) {
+      sqlString += ` ORDER BY ${queryBuilder.orderBy.join(', ')}`;
     }
-
-    const finalOrderByStrings: string[] = [];
-    const appliedOrderFieldsForCursor = new Set<string>();
-
-    if (criteria.cursor) {
-      const cursorFilters = criteria.cursor.filters;
-      const op =
-        criteria.cursor.operator === FilterOperator.GREATER_THAN ? '>' : '<';
-      let cursorWhereCondition = '';
-
-      if (cursorFilters.length === 1) {
-        const primaryFilter = cursorFilters[0]!;
-        const primaryPlaceholder = this.generateParamPlaceholder();
-        sqlParts.params.push(primaryFilter.value);
-        cursorWhereCondition = `(${escapeField(
-          String(primaryFilter.field),
-          criteria.alias,
-        )} ${op} ${primaryPlaceholder})`;
-      } else if (cursorFilters.length === 2) {
-        const primaryFilter = cursorFilters[0]!;
-        const secondaryFilter = cursorFilters[1]!;
-        const primaryPlaceholder = this.generateParamPlaceholder();
-        const secondaryPlaceholder = this.generateParamPlaceholder();
-        sqlParts.params.push(primaryFilter.value, secondaryFilter.value);
-        cursorWhereCondition = `((${escapeField(
-          String(primaryFilter.field),
-          criteria.alias,
-        )} ${op} ${primaryPlaceholder}) OR (${escapeField(
-          String(primaryFilter.field),
-          criteria.alias,
-        )} = ${primaryPlaceholder} AND ${escapeField(
-          String(secondaryFilter.field),
-          criteria.alias,
-        )} ${op} ${secondaryPlaceholder}))`;
-      }
-
-      if (cursorWhereCondition) {
-        sqlParts.where.push(cursorWhereCondition);
-      }
-
-      const cursorOrderDirection = criteria.cursor.order;
-      cursorFilters.forEach((cf) => {
-        const fieldKey = `${criteria.alias}.${String(cf.field)}`;
-        finalOrderByStrings.push(
-          `${escapeField(
-            String(cf.field),
-            criteria.alias,
-          )} ${cursorOrderDirection}`,
-        );
-        appliedOrderFieldsForCursor.add(fieldKey);
-      });
+    if (queryBuilder.limit !== undefined) {
+      sqlString += ` LIMIT ${queryBuilder.limit}`;
     }
-
-    this.collectedOrders
-      .sort((a, b) => a.order.sequenceId - b.order.sequenceId)
-      .forEach(({ alias, order }) => {
-        const fieldKey = `${alias}.${String(order.field)}`;
-        if (!appliedOrderFieldsForCursor.has(fieldKey)) {
-          finalOrderByStrings.push(
-            `${escapeField(String(order.field), alias)} ${order.direction}`,
-          );
-        }
-      });
-
-    if (finalOrderByStrings.length > 0) {
-      sqlParts.orderBy = finalOrderByStrings;
+    if (queryBuilder.offset !== undefined) {
+      sqlString += ` OFFSET ${queryBuilder.offset}`;
     }
 
-    if (criteria.take > 0) sqlParts.limit = criteria.take;
-    if (criteria.skip > 0) sqlParts.offset = criteria.skip;
+    return {
+      query: sqlString,
+      params: queryBuilder.params,
+    };
+  }
 
-    return sqlParts;
+  public override visitRoot<RootCSchema extends CriteriaSchema>(
+    criteria: RootCriteria<RootCSchema>,
+    context: PseudoSqlParts,
+  ): void {
+    // Implementation would go here...
   }
 
-  private applyPseudoJoin<
+  public override visitInnerJoin<
     ParentCSchema extends CriteriaSchema,
-    JoinCriteriaSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCriteriaSchema>,
+    JoinCSchema extends CriteriaSchema,
   >(
-    joinType: string,
-    criteria:
-      | InnerJoinCriteria<JoinCriteriaSchema, JoinAlias>
-      | LeftJoinCriteria<JoinCriteriaSchema, JoinAlias>
-      | OuterJoinCriteria<JoinCriteriaSchema, JoinAlias>,
+    criteria: InnerJoinCriteria<JoinCSchema>,
     parameters:
-      | PivotJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>
-      | SimpleJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>,
-    sqlParts: PseudoSqlParts,
-  ): PseudoSqlParts {
-    const joinTable = `${escapeField(criteria.sourceName)} AS ${escapeField(
-      criteria.alias,
-    )}`;
-    let onCondition = '';
-
-    if ('pivot_source_name' in parameters) {
-      const pivotAlias = `${parameters.parent_alias}_${criteria.alias}_pivot`;
-      const pivotTable = `${escapeField(
-        parameters.pivot_source_name,
-      )} AS ${escapeField(pivotAlias)}`;
-      sqlParts.joins.push(
-        `${joinType} JOIN ${pivotTable} ON ${escapeField(
-          String(parameters.parent_field.reference),
-          parameters.parent_alias,
-        )} = ${escapeField(parameters.parent_field.pivot_field, pivotAlias)}`,
-      );
-      onCondition = `${escapeField(
-        parameters.join_field.pivot_field,
-        pivotAlias,
-      )} = ${escapeField(
-        String(parameters.join_field.reference),
-        criteria.alias,
-      )}`;
-      sqlParts.joins.push(`${joinType} JOIN ${joinTable} ON ${onCondition}`);
-    } else {
-      onCondition = `${escapeField(
-        String(parameters.parent_field),
-        parameters.parent_alias,
-      )} = ${escapeField(String(parameters.join_field), criteria.alias)}`;
-      sqlParts.joins.push(`${joinType} JOIN ${joinTable} ON ${onCondition}`);
-    }
-
-    if (criteria.rootFilterGroup.items.length > 0) {
-      const filterResult = criteria.rootFilterGroup.accept(
-        this,
-        criteria.alias,
-        sqlParts,
-      );
-      if (filterResult.condition) {
-        const lastJoinIndex = sqlParts.joins.length - 1;
-        if (sqlParts.joins[lastJoinIndex]) {
-          sqlParts.joins[lastJoinIndex] += ` AND (${filterResult.condition})`;
-          sqlParts.params.push(...filterResult.params);
-        }
-      }
-    }
-
-    criteria.select.forEach((f) =>
-      sqlParts.select.push(escapeField(String(f), criteria.alias)),
-    );
-    if (criteria.selectAll && criteria.select.length === 0) {
-      sqlParts.select.push(`${escapeField(criteria.alias)}.*`);
-    }
-
-    criteria.orders.forEach((order) =>
-      this.collectedOrders.push({ alias: criteria.alias, order }),
-    );
-
-    for (const subJoinDetail of criteria.joins) {
-      subJoinDetail.criteria.accept(this, subJoinDetail.parameters, sqlParts);
-    }
-
-    return sqlParts;
-  }
-
-  visitInnerJoin(
-    criteria: InnerJoinCriteria<any, any>,
-    parameters: any,
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
     context: PseudoSqlParts,
-  ): PseudoSqlParts {
-    return this.applyPseudoJoin('INNER', criteria, parameters, context);
+  ): void {
+    // Implementation would go here...
   }
-  visitLeftJoin(
-    criteria: LeftJoinCriteria<any, any>,
-    parameters: any,
+
+  public override visitLeftJoin<
+    ParentCSchema extends CriteriaSchema,
+    JoinCSchema extends CriteriaSchema,
+  >(
+    criteria: LeftJoinCriteria<JoinCSchema>,
+    parameters:
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
     context: PseudoSqlParts,
-  ): PseudoSqlParts {
-    return this.applyPseudoJoin('LEFT', criteria, parameters, context);
+  ): void {
+    // Implementation would go here...
   }
-  visitOuterJoin(
-    criteria: OuterJoinCriteria<any, any>,
-    parameters: any,
+
+  public override visitOuterJoin<
+    ParentCSchema extends CriteriaSchema,
+    JoinCSchema extends CriteriaSchema,
+  >(
+    criteria: OuterJoinCriteria<JoinCSchema>,
+    parameters:
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
     context: PseudoSqlParts,
-  ): PseudoSqlParts {
-    return this.applyPseudoJoin('FULL OUTER', criteria, parameters, context);
+  ): void {
+    // Implementation would go here...
   }
 
-  visitFilter<FieldType extends string, Operator extends FilterOperator>(
-    filter: Filter<FieldType, Operator>,
+  public override visitFilter<FieldType extends string>(
+    filter: Filter<FieldType, FilterOperator>,
     currentAlias: string,
+    context: PseudoSqlParts,
   ): PseudoSqlFilterOutput {
-    const fieldName = escapeField(String(filter.field), currentAlias);
-    const params: any[] = [];
-    let condition = '';
-
-    switch (filter.operator) {
-      case FilterOperator.EQUALS:
-        condition = `${fieldName} = ${this.generateParamPlaceholder()}`;
-        params.push(filter.value);
-        break;
-      case FilterOperator.NOT_EQUALS:
-        condition = `${fieldName} != ${this.generateParamPlaceholder()}`;
-        params.push(filter.value);
-        break;
-      case FilterOperator.LIKE:
-      case FilterOperator.CONTAINS:
-      case FilterOperator.STARTS_WITH:
-      case FilterOperator.ENDS_WITH:
-        let val = String(filter.value);
-        if (filter.operator === FilterOperator.CONTAINS) val = `%${val}%`;
-        else if (filter.operator === FilterOperator.STARTS_WITH)
-          val = `${val}%`;
-        else if (filter.operator === FilterOperator.ENDS_WITH) val = `%${val}`;
-        condition = `${fieldName} LIKE ${this.generateParamPlaceholder()}`;
-        params.push(val);
-        break;
-      case FilterOperator.IN:
-        if (!Array.isArray(filter.value) || filter.value.length === 0) {
-          condition = '1=0';
-        } else {
-          const placeholders = (filter.value as any[])
-            .map(() => this.generateParamPlaceholder())
-            .join(', ');
-          condition = `${fieldName} IN (${placeholders})`;
-          params.push(...(filter.value as any[]));
-        }
-        break;
-      case FilterOperator.IS_NULL:
-        condition = `${fieldName} IS NULL`;
-        break;
-      case FilterOperator.IS_NOT_NULL:
-        condition = `${fieldName} IS NOT NULL`;
-        break;
-      case FilterOperator.JSON_CONTAINS:
-        if (typeof filter.value === 'object' && filter.value !== null) {
-          const jsonConditions: string[] = [];
-          for (const path in filter.value) {
-            const pathValue = (filter.value as Record<string, any>)[path];
-            jsonConditions.push(
-              `JSON_CONTAINS(${fieldName}, '${JSON.stringify(
-                pathValue,
-              )}', '$.${path}')`,
-            );
-          }
-          condition = jsonConditions.join(' AND ');
-        } else {
-          condition = '1=0';
-        }
-        break;
-      default:
-        condition = `${fieldName} ${
-          filter.operator
-        } ${this.generateParamPlaceholder()}`;
-        params.push(filter.value);
-    }
-    return {
-      condition,
-      params: params.map((p) => (p === undefined ? null : p)),
-    };
+    // Implementation would go here...
+    return { condition: '', params: [] };
   }
 
-  visitAndGroup<FieldType extends string>(
+  public override visitAndGroup<FieldType extends string>(
     group: FilterGroup<FieldType>,
     currentAlias: string,
-    sqlParts: PseudoSqlParts,
-  ): PseudoSqlFilterOutput {
-    const conditions: string[] = [];
-    const allParams: any[] = [];
-    group.items.forEach((item) => {
-      const result = item.accept(this, currentAlias, sqlParts);
-      if (result.condition) {
-        conditions.push(result.condition);
-        allParams.push(...result.params);
-      }
-    });
-    if (conditions.length === 0) return { condition: '', params: [] };
-    return { condition: `(${conditions.join(' AND ')})`, params: allParams };
+    context: PseudoSqlParts,
+  ): void {
+    // Implementation would go here...
   }
 
-  visitOrGroup<FieldType extends string>(
+  public override visitOrGroup<FieldType extends string>(
     group: FilterGroup<FieldType>,
     currentAlias: string,
-    sqlParts: PseudoSqlParts,
-  ): PseudoSqlFilterOutput {
-    const conditions: string[] = [];
-    const allParams: any[] = [];
-    group.items.forEach((item) => {
-      const result = item.accept(this, currentAlias, sqlParts);
-      if (result.condition) {
-        conditions.push(result.condition);
-        allParams.push(...result.params);
-      }
-    });
-    if (conditions.length === 0) return { condition: '', params: [] };
-    return { condition: `(${conditions.join(' OR ')})`, params: allParams };
+    context: PseudoSqlParts,
+  ): void {
+    // Implementation would go here...
   }
 }
 ```
 
-```typescript
-// Assuming UserSchema and CriteriaFactory are defined
-// import { UserSchema } from './path/to/your/schemas';
-// import { CriteriaFactory, FilterOperator, OrderDirection } from '@nulledexp/translatable-criteria';
+**Explanation:**
+
+The `translate` method you implement is the public entry point. It is responsible for:
 
-// const userCriteria = CriteriaFactory.GetCriteria(UserSchema, 'users')
-//   .where({ field: 'email', operator: FilterOperator.CONTAINS, value: '@example.com' })
-//   .orderBy('username', OrderDirection.ASC)
-//   .setTake(10);
+1.  **Resetting internal state:** Ensures that each translation starts with a clean slate (e.g., `paramCounter` and `collectedOrders` are reset).
+2.  **Initializing the `TranslationContext`:** Creates the initial object (e.g., `queryBuilder`) that will be modified by the `visit...` methods.
+3.  **Starting the traversal:** This is the crucial step where you call `criteria.accept(this, queryBuilder)` to begin the visitor pattern. All subsequent `visit...` methods will modify the `queryBuilder` object directly.
+4.  **Assembling the final query:** After the traversal is complete, it constructs the final query string by combining the accumulated parts from `queryBuilder`.
+5.  **Returning the result:** Returns the final query and its parameters.
 
-// const pseudoTranslator = new PseudoSqlTranslator();
-// const { query: generatedSql, params: queryParams } = pseudoTranslator.translate(userCriteria);
+---
+
+## 6. Complete Example: Pseudo-SQL Translator
+
+### 6.1. Translator Implementation
+
+For a complete, functional example of a `CriteriaTranslator` implementation, please refer to the `src/criteria/translator/example/pseudo-sql.translator.ts` file in the repository. This file contains the full code for the [`PseudoSqlTranslator`](../../../criteria/translator/example/pseudo-sql.translator.ts) class, which translates `Criteria` objects into a pseudo-SQL string.
+
+### 6.2. Translator Usage
+
+Here is how you would use the [`PseudoSqlTranslator`](../../../criteria/translator/example/pseudo-sql.translator.ts):
+
+```typescript
+import {
+  CriteriaFactory,
+  FilterOperator,
+  OrderDirection,
+} from '@nulledexp/translatable-criteria';
+import { UserSchema } from './path/to/your/schemas';
+import {
+  PseudoSqlTranslator,
+  type PseudoSqlParts,
+} from './path/to/your/pseudo-sql.translator';
+
+const userCriteria = CriteriaFactory.GetCriteria(UserSchema)
+  .where({
+    field: 'email',
+    operator: FilterOperator.CONTAINS,
+    value: '@example.com',
+  })
+  .orderBy('username', OrderDirection.ASC)
+  .setTake(10);
+
+const pseudoTranslator = new PseudoSqlTranslator();
+
+const initialParts: PseudoSqlParts = {
+  select: [],
+  from: '',
+  joins: [],
+  where: [],
+  orderBy: [],
+  params: [],
+};
 
-// console.log('Generated SQL:', generatedSql);
-// console.log('Parameters:', queryParams);
+const { query: generatedSql, params: queryParams } = pseudoTranslator.translate(
+  userCriteria,
+  initialParts,
+);
 
-// Expected output (example):
-// Generated SQL: SELECT `users`.`uuid`, `users`.`email`, `users`.`username`, `users`.`created_at` FROM `user` AS `users` WHERE (`users`.`email` LIKE ?) ORDER BY `users`.`username` ASC LIMIT ? OFFSET ?;
-// Parameters: [ '%@example.com%', 10, 0 ]
+console.log('Generated SQL:', generatedSql);
+console.log('Parameters:', queryParams);
 ```
 
 ---
@@ -1132,10 +554,9 @@ class PseudoSqlTranslator extends CriteriaTranslator<
 - **Errors and Validation:** Decide how to handle operators or configurations not supported by your data source. You can throw errors or ignore them.
 - **Optimization:** Consider optimizations specific to your data source.
 - **Testing:** Write thorough unit and integration tests for your translator. Use `CriteriaFactory` to construct various `Criteria` scenarios and verify that your translator's output is as expected.
-- **Documentation:** If you share your translator, clearly document what features it supports and how to use it.
 
 ---
 
 ## Next Steps
 
-With this guide, you have the foundation to start developing your own translators. Review existing translators (if any) for reference and don't hesitate to experiment.
+With this guide, you have the foundation to start developing your own translators. For a detailed reference of all classes and types, consult the API Reference.
diff --git a/src/docs/guides/developing-translators/es.md b/src/docs/guides/developing-translators/es.md
index 29862e6..6408c57 100644
--- a/src/docs/guides/developing-translators/es.md
+++ b/src/docs/guides/developing-translators/es.md
@@ -14,30 +14,28 @@ Esta guía te mostrará los pasos y conceptos clave para desarrollar tu propio `
   - 3.3. [`visitFilter`](#33-visitfilter)
   - 3.4. [`visitAndGroup`, `visitOrGroup`](#34-visitandgroup-visitorgroup)
 - 4. [Manejando Ordenamiento, Paginación y Selección](#4-manejando-ordenamiento-paginación-y-selección)
-  - 4.1. [Ordenamiento (`orderBy`)](#41-ordenamiento-orderby)
-  - 4.2. [Paginación Offset (`setTake`, `setSkip`)](#42-paginación-offset-settake-setskip)
-  - 4.3. [Paginación por Cursor (`setCursor`)](#43-paginación-por-cursor-setcursor)
-  - 4.4. [Selección de Campos (`setSelect`)](#44-selección-de-campos-setselect)
 - 5. [Gestión de Estado y Parámetros](#5-gestión-de-estado-y-parámetros)
-- 6. [Ejemplo Simplificado: Traductor a Pseudo-SQL](#6-ejemplo-simplificado-traductor-a-pseudo-sql)
+- 6. [Ejemplo Completo: Traductor a Pseudo-SQL](#6-ejemplo-completo-traductor-a-pseudo-sql)
+  - 6.1. [Implementación del Traductor](#61-implementación-del-traductor)
+  - 6.2. [Uso del Traductor](#62-uso-del-traductor)
 - 7. [Consideraciones Adicionales](#7-consideraciones-adicionales)
-- [Próximos Pasos](#próximos-pasos-traductores)
+- [Próximos Pasos](#próximos-pasos)
 
 ---
 
 ## 1. Entendiendo `CriteriaTranslator` y `ICriteriaVisitor`
 
-Como se mencionó en los Conceptos Clave, la librería utiliza el patrón de diseño Visitor.
+La librería utiliza el patrón de diseño Visitor.
 
 - **`CriteriaTranslator<TranslationContext, TranslationOutput, TFilterVisitorOutput>`**: Es una clase abstracta que debes extender.
 
-  - `TranslationContext`: El tipo del objeto de contexto que se pasa durante el recorrido del `Criteria` (ej. un constructor de consultas como el `SelectQueryBuilder` de TypeORM, o un objeto donde acumulas partes de una consulta MongoDB).
-  - `TranslationOutput`: El tipo del resultado final de la traducción (ej. el `SelectQueryBuilder` modificado, una cadena SQL, un objeto de consulta MongoDB).
-  - `TFilterVisitorOutput`: El tipo de salida específico para los métodos `visitFilter`, `visitAndGroup` y `visitOrGroup`. Esto permite que los filtros se procesen de manera diferente si es necesario (ej. generando una cadena de condición, o un objeto de filtro).
+  - `TranslationContext`: El tipo del objeto de contexto mutable que se pasa durante el recorrido del grafo de objetos `Criteria` (ej. una instancia de un constructor de consultas, o un objeto donde acumulas partes de una consulta). Este objeto es modificado directamente por los métodos `visit...`.
+  - `TranslationOutput` (opcional, por defecto `TranslationContext`): El tipo del resultado final devuelto por el método `translate()`. Típicamente es el mismo `TranslationContext`, pero puede ser un tipo diferente si tu traductor necesita devolver una versión procesada del contexto (ej. una cadena SQL final a partir de un constructor de consultas).
+  - `TFilterVisitorOutput` (opcional, por defecto `any`): El tipo de salida específico para el método `visitFilter`. Esto permite que los filtros devuelvan una representación intermedia (ej. una cadena de condición y sus parámetros) que luego puede ser integrada en el `TranslationContext` principal. Los métodos `visitAndGroup` y `visitOrGroup`, sin embargo, devuelven `void` y modifican directamente el `TranslationContext`.
 
 - **`ICriteriaVisitor`**: La interfaz que `CriteriaTranslator` implementa. Define todos los métodos `visit...` que tu traductor necesitará sobreescribir para manejar cada tipo de nodo en el árbol de `Criteria` (filtros, grupos de filtros, joins, etc.).
 
-El proceso de traducción generalmente comienza llamando al método `translate()` de tu traductor, el cual internamente llama a `criteria.accept(this, initialContext)`.
+El proceso de traducción se inicia llamando al método `translate()`, que es un **método abstracto que debes implementar**. Dentro de tu implementación de `translate`, eres responsable de iniciar el recorrido del visitor llamando a `criteria.accept(this, initialContext)`. El método `accept` de cada componente de `Criteria` llamará entonces al método `visit...` apropiado en tu traductor, pasándole el componente mismo y el `TranslationContext`. Por ejemplo, el método `accept` de un `RootCriteria` llamará a `visitor.visitRoot(...)`, mientras que el `accept` de un `Filter` llamará a `visitor.visitFilter(...)`. Este mecanismo de "doble despacho" es el núcleo del patrón Visitor.
 
 ---
 
@@ -45,1086 +43,508 @@ El proceso de traducción generalmente comienza llamando al método `translate()
 
 El primer paso es crear una nueva clase que extienda `CriteriaTranslator`. Deberás definir los tipos genéricos según lo que tu traductor vaya a producir y necesitar.
 
-```typescript
-import {
-  CriteriaTranslator,
-  RootCriteria,
-  InnerJoinCriteria,
-  // ... otros imports necesarios
-  FilterOperator,
-  type CriteriaSchema,
-  type SelectedAliasOf,
-  type PivotJoin,
-  type SimpleJoin,
-  type JoinRelationType,
-  type Filter,
-  type FilterGroup,
-} from '@nulledexp/translatable-criteria';
+Para los ejemplos conceptuales en esta guía, utilizaremos los siguientes tipos para `TranslationContext` y `TFilterVisitorOutput`, que se alinean con el [`PseudoSqlTranslator`](../../../criteria/translator/example/pseudo-sql.translator.ts) ejemplo:
 
-// Define tus tipos para el contexto y la salida
-// Por ejemplo, si traduces a un constructor de consultas SQL:
-// type MyQueryBuilder = SomeSQLQueryBuilder;
-// type MyFilterCondition = string; // o un objeto de condición
+Aquí está la estructura básica de tu clase traductora personalizada, mostrando solo las firmas de los métodos públicos que necesitarás implementar:
 
-// Para este ejemplo, usaremos tipos simples
-type MyQueryBuilder = {
-  selectFields: string[];
-  fromTable?: string;
+```typescript
+type PseudoSqlParts = {
+  select: string[];
+  from: string;
   joins: string[];
-  conditions: string[];
+  where: string[];
   orderBy: string[];
   limit?: number;
   offset?: number;
   params: any[];
 };
 
-type MyFilterConditionOutput = {
+type PseudoSqlFilterOutput = {
   condition: string;
   params: any[];
 };
 
 export class MyCustomTranslator extends CriteriaTranslator<
-  MyQueryBuilder, // TranslationContext: El objeto que se modifica durante la traducción
-  MyQueryBuilder, // TranslationOutput: El resultado final de translate()
-  MyFilterConditionOutput // TFilterVisitorOutput: El resultado de visitar filtros/grupos
+  PseudoSqlParts,
+  { query: string; params: any[] },
+  PseudoSqlFilterOutput
 > {
-  private paramCounter = 0;
-
-  private generateParamPlaceholder(): string {
-    // La lógica interna puede variar según el tipo de placeholder que necesites:
-    // Si usas placeholders nombrados como :p0, :p1 (común en TypeORM, por ejemplo)
-    // return `:p${this.paramCounter++}`;
-    // Si usas placeholders posicionales como ? (común en MySQL nativo, SQLite)
-    this.paramCounter++; // Solo para contar si es necesario, el placeholder es fijo
-    return `?`;
-    // O el placeholder específico de tu BD/ORM.
+  public override translate<RootCriteriaSchema extends CriteriaSchema>(
+    criteria: RootCriteria<RootCriteriaSchema>,
+    source: PseudoSqlParts,
+  ): { query: string; params: any[] } {
+    return { query: '', params: [] };
   }
 
-  // Implementación de los métodos visit...
-  // ... (ver secciones siguientes)
-}
-```
-
-En este ejemplo:
-
-- `MyQueryBuilder`: Sería tu clase o interfaz para construir la consulta nativa.
-- `string`: El tipo de salida de los métodos `visitFilter` y `visitGroup`, asumiendo que generan fragmentos de condición SQL.
-
----
-
-## 3. Implementando Métodos `visit...`
-
-Ahora, debes implementar los métodos abstractos `visit...` de `CriteriaTranslator`.
+  public override visitRoot<RootCSchema extends CriteriaSchema>(
+    criteria: RootCriteria<RootCSchema>,
+    context: PseudoSqlParts,
+  ): void {}
 
-### 3.1. `visitRoot`
+  public override visitInnerJoin<
+    ParentCSchema extends CriteriaSchema,
+    JoinCSchema extends CriteriaSchema,
+  >(
+    criteria: InnerJoinCriteria<JoinCSchema>,
+    parameters:
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
+    context: PseudoSqlParts,
+  ): void {}
 
-Este es el punto de entrada principal para la traducción de un `RootCriteria`. Aquí es donde típicamente iniciarás tu consulta, procesarás los filtros principales, uniones, ordenamiento y paginación del `RootCriteria`.
+  public override visitLeftJoin<
+    ParentCSchema extends CriteriaSchema,
+    JoinCSchema extends CriteriaSchema,
+  >(
+    criteria: LeftJoinCriteria<JoinCSchema>,
+    parameters:
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
+    context: PseudoSqlParts,
+  ): void {}
 
-```typescript
-  visitRoot<
-    RootCriteriaSchema extends CriteriaSchema,
-    RootAlias extends SelectedAliasOf<RootCriteriaSchema>,
+  public override visitOuterJoin<
+    ParentCSchema extends CriteriaSchema,
+    JoinCSchema extends CriteriaSchema,
   >(
-    criteria: RootCriteria<RootCriteriaSchema, RootAlias>,
-    queryBuilder: MyQueryBuilder, // El contexto inicial
-  ): MyQueryBuilder {
-    this.paramCounter = 0; // Reiniciar contador de parámetros para cada traducción principal
-
-    // 1. FROM clause
-    queryBuilder.fromTable = `${criteria.sourceName} AS ${criteria.alias}`;
-
-    // 2. SELECT clause
-    queryBuilder.selectFields = criteria.select.map(
-      (field) => `${criteria.alias}.${String(field)}`,
-    );
-    if (criteria.selectAll && queryBuilder.selectFields.length === 0) {
-        queryBuilder.selectFields.push(`${criteria.alias}.*`);
-    }
+    criteria: OuterJoinCriteria<JoinCSchema>,
+    parameters:
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
+    context: PseudoSqlParts,
+  ): void {}
 
+  public override visitFilter<FieldType extends string>(
+    filter: Filter<FieldType, FilterOperator>,
+    currentAlias: string,
+    context: PseudoSqlParts,
+  ): PseudoSqlFilterOutput {
+    return { condition: '', params: [] };
+  }
 
-    // 3. JOINs
-    for (const joinDetail of criteria.joins) {
-      // El contexto (queryBuilder) se pasa y se modifica por los métodos visitJoin
-      joinDetail.criteria.accept(this, joinDetail.parameters, queryBuilder);
-    }
+  public override visitAndGroup<FieldType extends string>(
+    group: FilterGroup<FieldType>,
+    currentAlias: string,
+    context: PseudoSqlParts,
+  ): void {}
 
-    // 4. WHERE clause for RootCriteria
-    if (criteria.rootFilterGroup.items.length > 0) {
-      const rootFilterResult = criteria.rootFilterGroup.accept(
-        this,
-        criteria.alias,
-        queryBuilder, // El contexto aquí podría ser diferente si los filtros no modifican directamente el QB
-      );
-      if (rootFilterResult.condition) {
-        queryBuilder.conditions.push(rootFilterResult.condition);
-        queryBuilder.params.push(...rootFilterResult.params);
-      }
-    }
+  public override visitOrGroup<FieldType extends string>(
+    group: FilterGroup<FieldType>,
+    currentAlias: string,
+    context: PseudoSqlParts,
+  ): void {}
+}
+```
 
-    // 5. Cursor condition (si existe, se añade al WHERE)
-    if (criteria.cursor) {
-        const cursorFilters = criteria.cursor.filters;
-        const op = criteria.cursor.operator === FilterOperator.GREATER_THAN ? '>' : '<';
-        // const orderDir = criteria.cursor.order; // No usado directamente en este ejemplo de SQL simple
-
-        const primaryCursorFilter = cursorFilters[0]!;
-        const primaryParamName = this.generateParamPlaceholder(); // Usar un nombre de parámetro único
-        queryBuilder.params.push(primaryCursorFilter.value);
-        let cursorCondition = `(${criteria.alias}.${String(primaryCursorFilter.field)} ${op} :${primaryParamName}`;
-
-        if (cursorFilters.length === 2) {
-            const secondaryCursorFilter = cursorFilters[1]!;
-            const secondaryParamName = this.generateParamPlaceholder(); // Usar un nombre de parámetro único
-            queryBuilder.params.push(secondaryCursorFilter.value);
-            cursorCondition += ` OR (${criteria.alias}.${String(primaryCursorFilter.field)} = :${primaryParamName} AND ${criteria.alias}.${String(secondaryCursorFilter.field)} ${op} :${secondaryParamName}))`;
-        } else {
-            cursorCondition += `)`;
-        }
-        queryBuilder.conditions.push(cursorCondition);
-
-        // Asegurar que el orderBy del cursor se aplique
-        // En un traductor real, esto podría necesitar lógica más compleja para asegurar el orden correcto
-        // y evitar duplicados si ya están en criteria.orders.
-        // Por simplicidad, aquí los añadimos.
-        criteria.orders.forEach(order => { // Asumimos que los orders del cursor están en criteria.orders
-             queryBuilder.orderBy.push(`${criteria.alias}.${String(order.field)} ${order.direction}`);
-        });
-    }
+En este ejemplo:
 
+- `PseudoSqlParts`: Es nuestro `TranslationContext`, representando las partes acumuladas de la consulta SQL.
+- `{ query: string; params: any[] }`: Es nuestro `TranslationOutput`, el resultado final devuelto por el método `translate()`.
+- `PseudoSqlFilterOutput`: Es nuestro `TFilterVisitorOutput`, el resultado de visitar filtros individuales.
 
-  // 6. ORDER BY
-  // La lógica de ordenamiento debe ser cuidadosa, especialmente con cursores.
-  // El traductor es responsable de:
-  //   a. Si hay un cursor, sus campos de ordenamiento DEBEN tener prioridad.
-  //   b. Luego, se aplican los demás `Order`s definidos en el `RootCriteria` y en los `JoinCriteria`s.
-  //   c. Todos los `Order`s (después de los del cursor) deben ser ordenados globalmente por su `sequenceId`
-  //      antes de ser aplicados, para mantener un ordenamiento determinista.
-  // (Ver la sección "4.1. Ordenamiento (orderBy)" y el ejemplo del PseudoSqlTranslator
-  // para una implementación más detallada de esta lógica).
-
-  // Ejemplo conceptual simplificado (la lógica real es más compleja y se muestra en la sección 4.1 y el ejemplo):
-  if (criteria.cursor) {
-    // Los orderBy del cursor se aplican primero.
-    // Ejemplo: criteria.cursor.filters.forEach(cf => queryBuilder.orderBy.push(`${criteria.alias}.${String(cf.field)} ${criteria.cursor.order}`));
-    // Luego, los demás orders, evitando duplicados y usando sequenceId.
-  } else {
-    // Si no hay cursor, aplicar todos los orders recolectados, ordenados por sequenceId.
-    // Ejemplo:
-    // const allOrders = []; // Recolectar de criteria.orders y de los joins
-    // allOrders.sort((a, b) => a.order.sequenceId - b.order.sequenceId);
-    // allOrders.forEach(({alias, order}) => queryBuilder.orderBy.push(`${alias}.${String(order.field)} ${order.direction}`));
-  }
+---
 
+## Helper: `escapeField`
 
-    // 7. LIMIT / OFFSET
-    if (criteria.take > 0) {
-      queryBuilder.limit = criteria.take;
-    }
-    if (criteria.skip > 0) {
-      queryBuilder.offset = criteria.skip;
-    }
+Muchos traductores necesitarán una función de utilidad para escapar correctamente los nombres de campo y prevenir la inyección SQL o para ajustarse a la sintaxis del lenguaje de consulta objetivo. Este helper se utiliza en los ejemplos conceptuales a continuación.
 
-    return queryBuilder;
-  }
+```typescript
+function escapeField(field: string, alias?: string): string {
+  const escape = (str: string) => `\`${str.replace(/`/g, '``')}\``;
+  return alias ? `${escape(alias)}.${escape(field)}` : escape(field);
+}
 ```
 
-**Consideraciones para `visitRoot`:**
+Esta función toma un nombre de campo y un alias opcional, y devuelve una cadena con el campo correctamente escapado y prefijado (ej. `` `alias`.`campo` ``).
 
-- **Inicialización:** Configura la parte `FROM` de tu consulta usando `criteria.sourceName` y `criteria.alias`.
-- **Filtros:** Llama a `criteria.rootFilterGroup.accept(this, criteria.alias, context)` para procesar los filtros del `RootCriteria`. El `context` aquí podría ser tu `queryBuilder` o un objeto donde adjuntar las condiciones.
-- **Joins:** Itera sobre `criteria.joins` y llama a `joinDetail.criteria.accept(this, joinDetail.parameters, context)` para cada uno.
-- **Ordenamiento y Paginación:** Aplica la lógica de `orderBy`, `take`, `skip` y `cursor` al final.
-- **Selección de Campos:** Construye la cláusula `SELECT` basada en `criteria.select`.
+---
 
-### 3.2. `visitInnerJoin`, `visitLeftJoin`, `visitOuterJoin`
+## 3. Implementando Métodos `visit...`
 
-Estos métodos manejan los diferentes tipos de uniones. Reciben la instancia del `JoinCriteria`, los `parameters` del join (que incluyen información del padre y del hijo del join), y el `context`.
+Ahora, debes implementar los métodos abstractos `visit...` de `CriteriaTranslator`.
 
-```typescript
-  private applyJoin<
-    ParentCSchema extends CriteriaSchema,
-    JoinCriteriaSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCriteriaSchema>,
-  >(
-    joinType: 'INNER' | 'LEFT' | 'OUTER',
-    criteria: // El JoinCriteria actual que se está visitando
-      | InnerJoinCriteria<JoinCriteriaSchema, JoinAlias>
-      | LeftJoinCriteria<JoinCriteriaSchema, JoinAlias>
-      | OuterJoinCriteria<JoinCriteriaSchema, JoinAlias>,
-    parameters:
-      | PivotJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>
-      | SimpleJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>,
-    queryBuilder: MyQueryBuilder, // Contexto: el query builder principal
-  ): MyQueryBuilder {
-    const joinTable = `${criteria.sourceName} AS ${criteria.alias}`;
-    let onCondition = '';
-
-    if ('pivot_source_name' in parameters) {
-      // Many-to-many join
-      const pivotAlias = `${parameters.parent_alias}_${criteria.alias}_pivot`;
-      const pivotTable = `${parameters.pivot_source_name} AS ${pivotAlias}`;
-
-      const firstJoin = `${joinType} JOIN ${pivotTable} ON ${parameters.parent_alias}.${String(parameters.parent_field.reference)} = ${pivotAlias}.${parameters.parent_field.pivot_field}`;
-      queryBuilder.joins.push(firstJoin);
-
-      onCondition = `${pivotAlias}.${parameters.join_field.pivot_field} = ${criteria.alias}.${String(parameters.join_field.reference)}`;
-      queryBuilder.joins.push(`${joinType} JOIN ${joinTable} ON ${onCondition}`);
-    } else {
-      // Simple join
-      onCondition = `${parameters.parent_alias}.${String(parameters.parent_field)} = ${criteria.alias}.${String(parameters.join_field)}`;
-      queryBuilder.joins.push(`${joinType} JOIN ${joinTable} ON ${onCondition}`);
-    }
+### 3.1. `visitRoot`
 
-    // Filtros en el JOIN (se añaden a la cláusula ON o como AND después)
-    if (criteria.rootFilterGroup.items.length > 0) {
-      const joinFilterResult = criteria.rootFilterGroup.accept(
-        this,
-        criteria.alias,
-        queryBuilder,
-      );
-      if (joinFilterResult.condition) {
-        const lastJoinIndex = queryBuilder.joins.length -1;
-        if(queryBuilder.joins[lastJoinIndex]) {
-            queryBuilder.joins[lastJoinIndex] += ` AND (${joinFilterResult.condition})`;
-            queryBuilder.params.push(...joinFilterResult.params);
-        }
-      }
-    }
+Este es el punto de entrada principal para la traducción de un `RootCriteria`. Aquí es donde típicamente iniciarás tu consulta, procesarás los filtros principales, uniones, ordenamiento y paginación del `RootCriteria`.
 
-    // Selección de campos del Join
-    criteria.select.forEach((field) => {
-      queryBuilder.selectFields.push(`${criteria.alias}.${String(field)}`);
-    });
-    if (criteria.selectAll && criteria.select.length === 0) {
-        queryBuilder.selectFields.push(`${criteria.alias}.*`);
-    }
+```typescript
+public override visitRoot<RootCSchema extends CriteriaSchema>(
+  criteria: RootCriteria<RootCSchema>,
+  context: PseudoSqlParts,
+): void {}
+```
 
-    // Recolectar OrderBy del join para aplicarlos globalmente
-    // (Esta lógica podría necesitar refinamiento para asegurar el orden global correcto)
-    criteria.orders.forEach(order => {
-        // Ejemplo: queryBuilder.orderBy.push(`${criteria.alias}.${String(order.field)} ${order.direction}`);
-        // O almacenarlos en una propiedad de la clase para aplicarlos al final en visitRoot.
-    });
-
-    // ***** INICIO DE LA MODIFICACIÓN PARA JOINS ANIDADOS *****
-    // Si este JoinCriteria (el 'criteria' actual) tiene sus propios joins definidos,
-    // los procesamos recursivamente.
-    for (const subJoinDetail of criteria.joins) {
-      // El 'queryBuilder' (contexto) se sigue pasando y modificando.
-      subJoinDetail.criteria.accept(this, subJoinDetail.parameters, queryBuilder);
-    }
-    // ***** FIN DE LA MODIFICACIÓN PARA JOINS ANIDADOS *****
+**Explicación:**
 
-    return queryBuilder;
-  }
+Este método es el punto de partida del proceso de traducción. Recibe el objeto `RootCriteria` y el `TranslationContext` (nuestro objeto `sqlParts`). Sus responsabilidades principales son:
 
-  visitInnerJoin<
-    ParentCSchema extends CriteriaSchema,
-    JoinCriteriaSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCriteriaSchema>,
-  >(
-    criteria: InnerJoinCriteria<JoinCriteriaSchema, JoinAlias>,
-    parameters:
-      | PivotJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>
-      | SimpleJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>,
-    context: MyQueryBuilder,
-  ): MyQueryBuilder {
-    return this.applyJoin('INNER', criteria, parameters, context);
-  }
+- **Inicializar la cláusula `FROM`:** Utiliza `criteria.sourceName` y `criteria.alias` para configurar la tabla principal de la consulta.
+- **Procesar la selección de campos:** Mapea `criteria.select` a la cláusula `SELECT`, asegurándose de que los campos estén correctamente cualificados con el alias de la entidad.
+- **Manejar uniones:** Itera a través de `criteria.joins` y llama recursivamente a `accept` en cada `JoinCriteria` para procesar las uniones anidadas.
+- **Procesar filtros raíz:** Si `criteria.rootFilterGroup` contiene filtros, llama a `accept` en este grupo para traducirlos en condiciones `WHERE`.
+- **Aplicar paginación:** Comprueba `criteria.take` y `criteria.skip` para la paginación basada en offset, y `criteria.cursor` para la paginación basada en cursor, añadiendo las cláusulas `LIMIT`, `OFFSET` o `WHERE` complejas correspondientes.
+- **Recolectar reglas de ordenamiento:** Reúne los objetos `Order` de `criteria.orders` para ser aplicados más tarde.
 
-  visitLeftJoin<
-    ParentCSchema extends CriteriaSchema,
-    JoinCriteriaSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCriteriaSchema>,
-  >(
-    criteria: LeftJoinCriteria<JoinCriteriaSchema, JoinAlias>,
-    parameters:
-      | PivotJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>
-      | SimpleJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>,
-    context: MyQueryBuilder,
-  ): MyQueryBuilder {
-    return this.applyJoin('LEFT', criteria, parameters, context);
-  }
+**Propiedades `Criteria` disponibles:** `criteria.sourceName`, `criteria.alias`, `criteria.select`, `criteria.orders`, `criteria.joins`, `criteria.rootFilterGroup`, `criteria.cursor`, `criteria.take`, `criteria.skip`.
 
-  visitOuterJoin<
-    ParentCSchema extends CriteriaSchema,
-    JoinCriteriaSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCriteriaSchema>,
-  >(
-    criteria: OuterJoinCriteria<JoinCriteriaSchema, JoinAlias>,
-    parameters:
-      | PivotJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>
-      | SimpleJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>,
-    context: MyQueryBuilder,
-  ): MyQueryBuilder {
-    return this.applyJoin('OUTER', criteria, parameters, context);
-  }
-```
+Para una implementación completa, consulta el método `visitRoot` en `src/criteria/translator/example/pseudo-sql.translator.ts`.
 
-**Consideraciones para los `visitJoin...`:**
-
-- **Tipo de Join:** Usa el tipo de join (`INNER JOIN`, `LEFT JOIN`, etc.) apropiado según el método `visit...` específico que se esté implementando.
-- **Tabla y Alias:** Usa `criteria.sourceName` y `criteria.alias` para la tabla a la que se está uniendo (el objeto `criteria` es la instancia de `JoinCriteria` pasada al método).
-- **Condición `ON`:**
-  - Para `SimpleJoin` (relaciones como 'one_to_one', 'one_to_many', 'many_to_one' según lo definido por `parameters.relation_type`): Construye la condición `ON` usando `parameters.parent_alias`.`parameters.parent_field` = `criteria.alias`.`parameters.join_field`.
-  - Para `PivotJoin` (relación 'many_to_many' según lo definido por `parameters.relation_type`): Típicamente necesitarás dos operaciones de join en tu consulta nativa. La primera une la tabla padre (identificada por `parameters.parent_alias`) con la tabla pivote (`parameters.pivot_source_name`) usando `parameters.parent_field.reference` (del padre) y `parameters.parent_field.pivot_field` (del pivote). La segunda une la tabla pivote con la tabla destino unida (`criteria.sourceName` con alias `criteria.alias`) usando `parameters.join_field.pivot_field` (del pivote) y `parameters.join_field.reference` (del destino).
-- **Accediendo a Metadatos:** El objeto `parameters` (de tipo `PivotJoin` o `SimpleJoin`) pasado a estos métodos de visita de join contiene:
-  - `parameters.parent_schema_metadata`: Metadatos del `CriteriaSchema` raíz del criteria padre.
-  - `parameters.join_metadata`: Metadatos de la configuración específica del join en el array `joins` del esquema padre.
-    Los traductores pueden usar estos metadatos para lógica personalizada, como aplicar pistas específicas de la base de datos o manejar condiciones de join personalizadas.
-- **Filtros en el Join:** Si `criteria.rootFilterGroup` (del `JoinCriteria` que se está visitando) tiene filtros, estos deben aplicarse como condiciones adicionales. Esto se hace típicamente añadiéndolos a la cláusula `ON` del join (ej. `... ON condicion AND (filtros_del_join)`) o como condiciones `WHERE` separadas si la base de datos/ORM lo maneja así para uniones externas. Llama a `criteria.rootFilterGroup.accept(this, criteria.alias, context)` para procesar estos filtros.
-- **Selección de Campos del Join:**
-  - Si `criteria.selectAll` (del `JoinCriteria`) es `true`, todos los campos de `criteria.schema.fields` deben añadirse a la selección de la consulta principal, prefijados con `criteria.alias`.
-  - Si `criteria.selectAll` es `false`, solo los campos en `criteria.select` deben añadirse, prefijados con `criteria.alias`.
-- **Ordenamiento del Join:** Si `criteria.orders` (del `JoinCriteria`) tiene reglas de ordenamiento, estas deben ser recolectadas. Todos los órdenes recolectados (de la raíz y de todos los joins) deben ser ordenados globalmente por su `sequenceId` al final del método `visitRoot` antes de ser aplicados a la consulta final, para asegurar un orden de clasificación determinista.
-- **Joins Anidados:** De manera crucial, si el `criteria` (el `JoinCriteria` que se está visitando) tiene a su vez `criteria.joins` definidos (es decir, joins encadenados a partir de un join), debes iterar sobre ellos y llamar recursivamente a `subJoinDetail.criteria.accept(this, subJoinDetail.parameters, context)` para procesar estos joins anidados. El `context` (ej. tu constructor de consultas) se pasa y se modifica.
+### 3.2. `visitInnerJoin`, `visitLeftJoin`, `visitOuterJoin`
 
-### 3.3. `visitFilter`
+Estos métodos manejan los diferentes tipos de uniones. Reciben la instancia del `JoinCriteria`, los `parameters` del join (que incluyen información del padre y del hijo del join), y el `context`.
 
-Este método traduce un `Filter` individual a una condición de tu lenguaje de consulta.
+Para evitar la repetición de código, una práctica común es crear un método auxiliar privado (como `applyJoin` a continuación) que maneje la lógica compartida para todos los tipos de unión.
 
 ```typescript
-    visitFilter<
-FieldType extends string,
-        Operator extends FilterOperator,
+private applyJoin<
+  ParentCSchema extends CriteriaSchema,
+  JoinCSchema extends CriteriaSchema,
 >(
-        filter: Filter<FieldType, Operator>,
-        currentAlias: string,
-        // queryBuilder: MyQueryBuilder, // El contexto puede no ser necesario aquí si solo devolvemos la condición
-): MyFilterConditionOutput {
-  const fieldName = `${currentAlias}.${String(filter.field)}`;
-  // const paramName = this.generateParamPlaceholder(); // Generar placeholder único
-  let condition = '';
-  const params: any[] = []; // Array para recolectar parámetros
-
-  switch (filter.operator) {
-    case FilterOperator.EQUALS:
-      const eqParam = this.generateParamPlaceholder();
-      condition = `${fieldName} = ${eqParam}`; // Usar placeholder
-      params.push(filter.value);
-      break;
-    case FilterOperator.NOT_EQUALS:
-      const neqParam = this.generateParamPlaceholder();
-      condition = `${fieldName} != ${neqParam}`;
-      params.push(filter.value);
-      break;
-    case FilterOperator.LIKE:
-      const likeParam = this.generateParamPlaceholder();
-      condition = `${fieldName} LIKE ${likeParam}`;
-      params.push(filter.value); // Asume que el valor ya tiene '%'
-      break;
-    case FilterOperator.CONTAINS: // Podría ser igual que LIKE o usar una función específica
-      const containsParam = this.generateParamPlaceholder();
-      condition = `${fieldName} LIKE ${containsParam}`;
-      params.push(`%${filter.value}%`);
-      break;
-    case FilterOperator.IN:
-      if (Array.isArray(filter.value) && filter.value.length > 0) {
-        const inPlaceholders = filter.value
-                .map(() => this.generateParamPlaceholder())
-                .join(', ');
-        condition = `${fieldName} IN (${inPlaceholders})`;
-        params.push(...filter.value);
-      } else {
-        // Si el array está vacío o no es un array, la condición es usualmente falsa.
-        condition = '1=0'; // O la forma de tu BD para una condición siempre falsa
-      }
-      break;
-    case FilterOperator.IS_NULL:
-      condition = `${fieldName} IS NULL`;
-      // No hay parámetros para IS NULL
-      break;
-          // ... Implementar todos los FilterOperator necesarios
-    case FilterOperator.BETWEEN: // NUEVO CASO
-      if (Array.isArray(filter.value) && filter.value.length === 2) {
-        const paramMin = this.generateParamPlaceholder();
-        const paramMax = this.generateParamPlaceholder();
-        condition = `${fieldName} BETWEEN ${paramMin} AND ${paramMax}`;
-        params.push(filter.value[0], filter.value[1]);
-      } else {
-        // Manejar valor inválido para BETWEEN, quizás lanzar error o condición falsa
-        condition = '1=0'; // Condición que siempre es falsa
-      }
-      break;
-    case FilterOperator.MATCHES_REGEX: // NUEVO CASO
-      // La implementación dependerá de la base de datos (ej. REGEXP en MySQL, ~ en PostgreSQL)
-      const regexParam = this.generateParamPlaceholder();
-      condition = `${fieldName} REGEXP ${regexParam}`; // Ejemplo MySQL
-      params.push(filter.value);
-      break;
-    case FilterOperator.JSON_CONTAINS:
-      // ... (tu implementación existente para JSON_CONTAINS)
-      // Ejemplo conceptual para MySQL:
-      if (typeof filter.value === 'object' && filter.value !== null) {
-        const conditions: string[] = [];
-        for (const pathKey in filter.value) {
-          const pathValue = (filter.value as Record<string, any>)[pathKey];
-          const currentParamName = this.generateParamPlaceholder();
-          // Ejemplo: JSON_CONTAINS(metadata, '"tech"', '$.tags')
-          // O para igualdad de un valor en una ruta: JSON_EXTRACT(metadata, '$.views') = 100
-          conditions.push(
-                  `JSON_CONTAINS(${fieldName}, CAST(${this.generateParamPlaceholder()} AS JSON), '$.${pathKey}')`,
-          );
-          params.push(pathValue); // El traductor podría necesitar convertir pathValue a string JSON
-        }
-        condition = conditions.join(' AND ');
-      } else {
-        condition = '1=0';
-      }
-      break;
-    case FilterOperator.ARRAY_CONTAINS_ELEMENT:
-      // ... (tu implementación existente para ARRAY_CONTAINS_ELEMENT)
-      const arrayElemParam = this.generateParamPlaceholder();
-      if (
-              typeof filter.value === 'object' &&
-              filter.value !== null &&
-              !Array.isArray(filter.value)
-      ) {
-        const jsonPath = Object.keys(filter.value)[0]!;
-        const elementToFind = (filter.value as Record<string, any>)[
-                jsonPath
-                ];
-        condition = `JSON_CONTAINS(${fieldName}, CAST(${arrayElemParam} AS JSON), '$.${jsonPath}')`;
-        params.push(elementToFind);
-      } else {
-        condition = `${arrayElemParam} = ANY(${fieldName})`; // Ejemplo PostgreSQL
-        params.push(filter.value);
-      }
-      break;
-    default:
-      throw new Error(
-              `Traductor: Operador de filtro no soportado '${filter.operator}'`,
-      );
-  }
-  // Asegurarse de que los parámetros undefined se conviertan a null si es necesario
-  return { condition, params: params.map((p) => (p === undefined ? null : p)) };
-}
+  joinType: 'INNER' | 'LEFT' | 'FULL OUTER',
+  criteria:
+    | InnerJoinCriteria<JoinCSchema>
+    | LeftJoinCriteria<JoinCSchema>
+    | OuterJoinCriteria<JoinCSchema>,
+  parameters:
+    | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+    | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
+  sqlParts: PseudoSqlParts,
+): void {}
 ```
 
-**Consideraciones para `visitFilter`:**
-
-- **Campo y Alias:** El `currentAlias` te indica a qué entidad pertenece el `filter.field`.
-- **Operador:** Implementa la lógica para cada `FilterOperator` que tu fuente de datos soporte.
-- **Valor:** El `filter.value` debe ser formateado o parametrizado adecuadamente. Para operadores como `IN`, `value` será un array. Para operadores JSON/Array, `value` puede ser un objeto o un array, y necesitarás interpretar la ruta JSON si aplica.
-- **Parametrización:** Es **crucial** usar consultas parametrizadas para prevenir inyección SQL. No concatenes directamente `filter.value` en la cadena de consulta. En su lugar, usa placeholders y pasa los valores a través del mecanismo de parámetros de tu constructor de consultas.
-
-### 3.4. `visitAndGroup`, `visitOrGroup`
-
-Estos métodos manejan grupos de filtros. Reciben un `FilterGroup` y deben iterar sobre sus `items`, procesándolos recursivamente y uniéndolos con el operador lógico apropiado (`AND` u `OR`).
-
 ```typescript
-  visitAndGroup<FieldType extends string>(
-    group: FilterGroup<FieldType>,
-    currentAlias: string,
-    _context: MyQueryBuilder, // El contexto puede o no ser usado/modificado aquí
-  ): MyFilterConditionOutput {
-    const conditions: string[] = [];
-    const allParams: any[] = [];
-
-    group.items.forEach((item) => {
-      const result = item.accept(this, currentAlias, _context); // _context se pasa
-      if (result.condition) {
-        conditions.push(result.condition);
-        allParams.push(...result.params);
-      }
-    });
-
-    if (conditions.length === 0) return { condition: '', params: [] };
-    return {
-      condition: `(${conditions.join(' AND ')})`,
-      params: allParams,
-    };
-  }
+public override visitInnerJoin<
+  ParentCSchema extends CriteriaSchema,
+  JoinCSchema extends CriteriaSchema,
+>(
+  criteria: InnerJoinCriteria<JoinCSchema>,
+  parameters:
+    | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+    | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
+  context: PseudoSqlParts,
+): void {}
+```
 
-  visitOrGroup<FieldType extends string>(
-    group: FilterGroup<FieldType>,
-    currentAlias: string,
-    _context: MyQueryBuilder,
-  ): MyFilterConditionOutput {
-    const conditions: string[] = [];
-    const allParams: any[] = [];
-
-    group.items.forEach((item) => {
-      const result = item.accept(this, currentAlias, _context);
-      if (result.condition) {
-        conditions.push(result.condition);
-        allParams.push(...result.params);
-      }
-    });
-
-    if (conditions.length === 0) return { condition: '', params: [] };
-    return {
-      condition: `(${conditions.join(' OR ')})`,
-      params: allParams,
-    };
-  }
+```typescript
+public override visitLeftJoin<
+  ParentCSchema extends CriteriaSchema,
+  JoinCSchema extends CriteriaSchema,
+>(
+  criteria: LeftJoinCriteria<JoinCSchema>,
+  parameters:
+    | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+    | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
+  context: PseudoSqlParts,
+): void {}
 ```
 
-**Consideraciones para los `visit...Group`:**
+```typescript
+public override visitOuterJoin<
+  ParentCSchema extends CriteriaSchema,
+  JoinCSchema extends CriteriaSchema,
+>(
+  criteria: OuterJoinCriteria<JoinCSchema>,
+  parameters:
+    | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+    | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
+  context: PseudoSqlParts,
+): void {}
+```
 
-- **Recursión:** Cada `item` en `group.items` puede ser otro `FilterGroup` o un `Filter`. Llama a `item.accept(this, currentAlias, context)` para cada uno.
-- **Agrupación:** Asegúrate de que las condiciones generadas estén correctamente agrupadas con paréntesis si es necesario, especialmente al mezclar `AND` y `OR`.
+**Explicación (para `applyJoin` y los métodos `visit...Join`):**
 
----
+Estos métodos son responsables de traducir las condiciones de unión al lenguaje de consulta objetivo. Cada método `visit...Join` simplemente llama al auxiliar `applyJoin`, pasando el `joinType` específico (ej. 'INNER', 'LEFT', 'FULL OUTER').
 
-## 4. Manejando Ordenamiento, Paginación y Selección
+Las responsabilidades del auxiliar `applyJoin` incluyen:
 
-Estas lógicas generalmente se aplican en `visitRoot` después de que todas las uniones y filtros principales se hayan procesado.
+- **Construir la cláusula `JOIN`:** Utiliza `criteria.sourceName` (la tabla que se está uniendo) y `parameters.join_alias` (su alias en la consulta) para construir la parte `JOIN` de la consulta.
+- **Definir la condición `ON`:**
+- Para `SimpleJoin` (relaciones uno a uno, uno a muchos, muchos a uno), construye la condición `ON` utilizando `parameters.parent_alias`.`parameters.parent_field` = `parameters.join_alias`.`parameters.join_field`.
+- Para `PivotJoin` (relaciones muchos a muchos), típicamente implica dos operaciones `JOIN`: una desde el padre a la tabla pivote, y otra desde la tabla pivote a la tabla destino unida. Construye las condiciones `ON` para ambas.
+- **Aplicar filtros en la unión:** Si `criteria.rootFilterGroup` (del `JoinCriteria` que se está visitando) tiene filtros, los procesa llamando a `criteria.rootFilterGroup.accept(this, parameters.join_alias, context)` y añade sus condiciones a la cláusula `ON` utilizando `AND`.
+- **Seleccionar campos de la entidad unida:** Mapea `criteria.select` (del `JoinCriteria`) a la cláusula `SELECT` principal, asegurándose de que los campos estén prefijados con `parameters.join_alias`.
+- **Recolectar reglas de ordenamiento:** Añade `criteria.orders` (del `JoinCriteria`) a una colección global de órdenes (ej. `this.collectedOrders` en [`PseudoSqlTranslator`](../../../criteria/translator/example/pseudo-sql.translator.ts)) para ser procesadas más tarde en `visitRoot`.
+- **Procesar uniones anidadas:** Crucialmente, si el `JoinCriteria` que se está visitando tiene `criteria.joins` definidos (es decir, uniones encadenadas a partir de una unión), itera sobre ellos y llama recursivamente a `subJoinDetail.criteria.accept(this, subJoinDetail.parameters, context)` para procesarlos.
 
-### 4.1. Ordenamiento (`orderBy`)
+**Propiedades `Criteria` disponibles:** `criteria.sourceName`, `criteria.alias`, `criteria.select`, `criteria.orders`, `criteria.joins`, `criteria.rootFilterGroup`.
+**Propiedades `parameters` disponibles:** `parameters.parent_alias`, `parameters.join_alias`, `parameters.parent_field`, `parameters.join_field`, `parameters.pivot_source_name`, `parameters.parent_identifier`, `parameters.parent_schema_metadata`, `parameters.join_metadata`.
 
-El ordenamiento define cómo se deben clasificar los resultados de la consulta.
+Para una implementación completa, consulta los métodos `visitInnerJoin`, `visitLeftJoin`, `visitOuterJoin` y el auxiliar `applyPseudoJoin` en `src/criteria/translator/example/pseudo-sql.translator.ts`.
 
-- Durante la visita de cada `Criteria` (raíz o join) mediante sus respectivos métodos `visit...`, tu traductor debe **recolectar** todos los objetos `Order` que se hayan definido usando `.orderBy()`. Cada objeto `Order` contiene el campo, la dirección y un `sequenceId` interno único.
-- Al final del procesamiento en `visitRoot` (después de haber procesado todos los joins y antes de aplicar `LIMIT`/`OFFSET`):
-  1. Si existe un `criteria.cursor`, los campos definidos en `cursor.filters` deben usarse para generar las **primeras** cláusulas de `ORDER BY`, utilizando la dirección especificada en `cursor.order`.
-  2. Luego, toma todos los `Order` recolectados (de la raíz y de todos los joins).
-  3. Ordena esta colección global de `Order`s por su `sequenceId`. Esto asegura que el orden en que se definieron los `orderBy` a lo largo de la construcción del `Criteria` se respete secuencialmente.
-  4. Convierte estos `Order`s (ya ordenados por secuencia y después de los del cursor) en las cláusulas `ORDER BY` de tu consulta nativa. Asegúrate de evitar duplicar campos si ya fueron ordenados por la lógica del cursor.
-- El `order.sequenceId` es crucial para mantener un ordenamiento global determinista y predecible cuando se aplican múltiples `orderBy` en diferentes partes del `Criteria` (tanto en la raíz como en los joins anidados).
--
+### 3.3. `visitFilter`
 
-### 4.2. Paginación Offset (`setTake`, `setSkip`)
+Este método traduce un `Filter` individual a una condición para tu lenguaje de consulta.
 
-- Si `criteria.take > 0`, aplica un límite al número de resultados.
-- Si `criteria.skip > 0`, omite el número especificado de resultados.
+```typescript
+public override visitFilter<FieldType extends string>(
+  filter: Filter<FieldType, FilterOperator>,
+  currentAlias: string,
+  context: PseudoSqlParts,
+): PseudoSqlFilterOutput {
+  return { condition: '', params: [] };
+}
+```
 
-### 4.3. Paginación por Cursor (`setCursor`)
+**Explicación:**
 
-Esta es más compleja y requiere una coordinación cuidadosa con el ordenamiento. Si `criteria.cursor` está definido:
+Este método es responsable de convertir un objeto `Filter` individual en una cadena de condición de consulta y de recolectar los parámetros necesarios.
 
-- `cursor.filters`: Proporciona uno o dos `Filter`s (sin el `operator`) que definen los campos y valores del último ítem de la página anterior.
-  - Un solo `Filter`: Para paginación simple sobre un campo (ej. `created_at`).
-  - Dos `Filter`s: Para paginación compuesta (ej. `created_at` y `uuid`).
-- `cursor.operator`: Será `FilterOperator.GREATER_THAN` (para página siguiente) o `FilterOperator.LESS_THAN` (para página anterior, si se invierte el orden principal).
-- `cursor.order`: La `OrderDirection` principal en la que se está paginando.
+- **Generar el nombre de campo:** Construye el nombre de campo completamente cualificado utilizando `currentAlias` y `filter.field` (ej. `` `alias`.`campo` ``).
+- **Parametrización:** Es **crucial** utilizar placeholders (ej. `?`, `$1`, `:nombreParam`) para `filter.value` para prevenir la inyección SQL. Añade `filter.value` a la lista de parámetros de tu `TranslationContext`.
+- **Implementar la lógica del operador:** Utiliza una sentencia `switch` o similar para manejar cada `FilterOperator`. La lógica para cada operador variará según el lenguaje de consulta objetivo y el tipo esperado de `filter.value` (ej. `BETWEEN` espera una tupla, `IN` espera un array, los operadores JSON esperan objetos).
+- **Devolver la condición:** Devuelve un objeto que contiene la cadena de condición generada y los parámetros recolectados.
 
-**Responsabilidades del Traductor:**
+**Propiedades `Filter` disponibles:** `filter.field`, `filter.operator`, `filter.value`.
+**Contexto disponible:** `currentAlias`.
 
-1.  **Construir la Condición `WHERE` del Cursor:**
+Para una implementación completa, consulta el método `visitFilter` en `src/criteria/translator/example/pseudo-sql.translator.ts`.
 
-- Para un cursor simple: `WHERE (campo_cursor operador_cursor_traducido valor_cursor)`
-- Para un cursor compuesto: `WHERE ( (campo_orden_primario op_traducido valor_primario_cursor) OR (campo_orden_primario = valor_primario_cursor AND campo_desempate op_traducido valor_desempate_cursor) )`. Ajusta los operadores según la dirección.
-- **Nota sobre NULLs:** Si un `valor_cursor` es `null`, el traductor debe generar el SQL apropiado (ej. condiciones `IS NULL` o `IS NOT NULL`) en lugar de comparaciones directas como `campo = NULL`.
+### 3.4. `visitAndGroup`, `visitOrGroup`
 
-2.  **Aplicar Ordenamiento del Cursor con Prioridad:**
+Estos métodos manejan grupos de filtros. Reciben un `FilterGroup` y deben iterar sobre sus `items`, procesándolos recursivamente y uniéndolos con el operador lógico apropiado (`AND` u `OR`).
 
-- Los campos definidos en `cursor.filters` **deben** ser los primeros en la cláusula `ORDER BY` final. La dirección para estos campos viene de `cursor.order`.
-- Por ejemplo, si `cursor.filters` son `[{field: 'created_at', ...}, {field: 'uuid', ...}]` y `cursor.order` es `ASC`, la consulta debe empezar con `ORDER BY created_at ASC, uuid ASC`.
+Un patrón común es utilizar un método auxiliar privado (como `_buildConditionFromGroup` a continuación) para manejar la lógica recursiva tanto para grupos `AND` como `OR`.
 
-3.  **Aplicar Ordenamientos Adicionales:**
+```typescript
+private _buildConditionFromGroup(
+  group: FilterGroup<any>,
+  alias: string,
+  context: PseudoSqlParts,
+): PseudoSqlFilterOutput | undefined {
+  return undefined;
+}
+```
 
-- Después de los campos del cursor, añade los demás `orderBy` que se hayan definido en el `Criteria` (raíz y joins). Estos deben ser ordenados globalmente por su `sequenceId` antes de ser añadidos, y se deben omitir si el campo ya fue cubierto por el ordenamiento del cursor.
-- **Importante:** El `Criteria` **debe** tener `orderBy()` definidos para los mismos campos que se usan en `cursor.filters` y en la misma dirección que `cursor.order`. Aunque el traductor prioriza los campos del cursor para el `ORDER BY`, esta consistencia en la definición del `Criteria` es crucial para la lógica de paginación.
+```typescript
+public override visitAndGroup<FieldType extends string>(
+  group: FilterGroup<FieldType>,
+  currentAlias: string,
+  context: PseudoSqlParts,
+): void {}
+```
 
-### 4.4. Selección de Campos (`setSelect`)
+```typescript
+public override visitOrGroup<FieldType extends string>(
+  group: FilterGroup<FieldType>,
+  currentAlias: string,
+  context: PseudoSqlParts,
+): void {}
+```
 
-- En `visitRoot`, construye la cláusula `SELECT` inicial usando `criteria.select` (del `RootCriteria`).
-- En cada `visitJoin...`, si el `joinCriteria.select` tiene campos específicos, añádelos a la selección principal, usualmente prefijados con el alias del join (ej. `SELECT root.field1, joined_alias.fieldA`).
-- Si `criteria.selectAll` es `true` (o `criteria.select` está vacío y es el comportamiento por defecto), selecciona todos los campos del esquema correspondiente.
+**Explicación (para `_buildConditionFromGroup` y los métodos `visit...Group`):**
 
----
+Estos métodos son responsables de traducir los objetos `FilterGroup` en una condición de consulta combinada. Los métodos `visitAndGroup` y `visitOrGroup` típicamente llaman a un auxiliar como `_buildConditionFromGroup` y luego añaden la condición resultante al `TranslationContext`.
 
-## 5. Gestión de Estado y Parámetros
+Las responsabilidades del auxiliar `_buildConditionFromGroup` incluyen:
 
-Tu traductor probablemente necesitará gestionar algún estado:
+- **Recorrido recursivo:** Itera sobre `group.items`. Para cada `item` (que puede ser un `Filter` o otro `FilterGroup`), llama recursivamente a `item.accept(this, currentAlias, context)`.
+- **Recolectar condiciones y parámetros:** Acumula las cadenas de condición y los parámetros devueltos por las llamadas recursivas a `accept`.
+- **Combinar condiciones:** Une las condiciones recolectadas utilizando el `group.logicalOperator` (`AND` u `OR`).
+- **Asegurar el agrupamiento:** Envuelve las condiciones combinadas entre paréntesis (ej. `(condicion1 AND condicion2)`) para asegurar la precedencia lógica correcta, especialmente al mezclar grupos `AND` y `OR`.
+- **Añadir al contexto:** Añade la condición final combinada y sus parámetros a la cláusula `where` del `TranslationContext`.
 
-- **Parámetros de Consulta:** Mantén una lista o un objeto para los valores parametrizados. Cada vez que proceses un `filter.value` o un valor de paginación, añádelo a esta colección y usa un placeholder en la consulta.
-- **Contador de Parámetros:** Si usas placeholders numerados (ej. `$1, $2` o `?`), necesitarás un contador.
-- **Cláusulas Acumuladas:** Puedes tener propiedades en tu clase traductora para ir construyendo las diferentes partes de la consulta (SELECT, FROM, JOINs, WHERE, ORDER BY, etc.).
+**Propiedades `FilterGroup` disponibles:** `group.items`, `group.logicalOperator`.
+**Contexto disponible:** `currentAlias`.
 
-```typescript
-// (Dentro de tu clase MyCustomTranslator)
-
-// Ejemplo de gestión de estado simple:
-// private collectedSelects: string[] = [];
-// private collectedFrom: string = '';
-// private collectedJoins: string[] = [];
-// private collectedWhere: string[] = [];
-// private collectedOrderBy: string[] = [];
-// private collectedLimit?: number;
-// private collectedOffset?: number;
-// private queryParams: any[] = [];
-// private paramCounter: number = 0;
-
-// constructor() {
-//   super();
-//   this.resetState();
-// }
-
-// private resetState(): void {
-//   this.collectedSelects = [];
-//   this.collectedFrom = '';
-//   // ... resetear todos los demás
-//   this.queryParams = [];
-//   this.paramCounter = 0;
-// }
-
-// private addQueryParam(value: any): string {
-//   this.queryParams.push(value);
-//   return `?`; // O $1, $2, etc., según tu DB
-// }
-
-// El método translate podría entonces ensamblar estas partes.
-// public translate(criteria: RootCriteria<any, any>, initialContext?: any): string {
-//   this.resetState();
-//   criteria.accept(this, initialContext || {}); // El contexto inicial podría ser un objeto vacío
-//
-//   let sql = `SELECT ${this.collectedSelects.join(', ') || '*'}`;
-//   sql += ` FROM ${this.collectedFrom}`;
-//   if (this.collectedJoins.length > 0) sql += ` ${this.collectedJoins.join(' ')}`;
-//   if (this.collectedWhere.length > 0) sql += ` WHERE ${this.collectedWhere.join(' AND ')}`; // Simplificado
-//   if (this.collectedOrderBy.length > 0) sql += ` ORDER BY ${this.collectedOrderBy.join(', ')}`;
-//   if (this.collectedLimit) sql += ` LIMIT ${this.collectedLimit}`;
-//   if (this.collectedOffset) sql += ` OFFSET ${this.collectedOffset}`;
-//   return sql;
-// }
-// public getParameters(): any[] {
-//    return this.queryParams;
-// }
-```
+Para una implementación completa, consulta los métodos `visitAndGroup` y `visitOrGroup` y el auxiliar `_buildConditionFromGroup` en `src/criteria/translator/example/pseudo-sql.translator.ts`.
 
 ---
 
-## 6. Ejemplo Simplificado: Traductor a Pseudo-SQL
+## 4. Manejando Ordenamiento, Paginación y Selección
 
-Este ejemplo muy básico muestra la estructura, traduciendo a una cadena de pseudo-SQL.
+Estas lógicas generalmente se aplican en `visitRoot` después de que todas las uniones y filtros principales se hayan procesado.
 
-```typescript
-import {
-  CriteriaTranslator,
-  RootCriteria,
-  InnerJoinCriteria,
-  LeftJoinCriteria,
-  OuterJoinCriteria,
-  Filter,
-  FilterGroup,
-  FilterOperator,
-  OrderDirection,
-  type Order,
-  type CriteriaSchema,
-  type SelectedAliasOf,
-  type PivotJoin,
-  type SimpleJoin,
-  type JoinRelationType,
-} from '@nulledexp/translatable-criteria';
+- **Ordenamiento (`orderBy`):** Tu traductor debe recolectar todos los objetos `Order` de la raíz y de todos los joins. Al final, ordena esta colección global por `order.sequenceId` para asegurar un orden de clasificación determinista, y luego aplícalos a la consulta.
+- **Paginación Offset (`setTake`, `setSkip`):** Si `criteria.take > 0` o `criteria.skip > 0`, aplica los correspondientes `LIMIT` y `OFFSET` a tu consulta.
+- **Paginación por Cursor (`setCursor`):** Esta es más compleja. El traductor debe construir una condición `WHERE` basada en `cursor.filters` y `cursor.operator`. Los campos de `cursor.filters` también deben ser los primeros campos en la cláusula `ORDER BY`, usando la dirección de `cursor.order`.
+- **Selección de Campos (`setSelect`):** En `visitRoot` y `visit...Join`, construye la cláusula `SELECT` basada en `criteria.select`. Si `criteria.selectAll` es `true`, selecciona todos los campos del esquema.
 
-type PseudoSqlParts = {
-  select: string[];
-  from: string;
-  joins: string[];
-  where: string[];
-  orderBy: string[];
-  limit?: number;
-  offset?: number;
-  params: any[];
-};
+---
 
-type PseudoSqlFilterOutput = {
-  condition: string;
-  params: any[];
-};
+## 5. Gestión de Estado y Parámetros
 
-type PseudoSqlTranslationResult = {
-  query: string;
-  params: any[];
-};
+Dado que el método `translate` es abstracto, estás obligado a implementarlo. Esta implementación es donde gestionas todo el ciclo de vida de la traducción, incluyendo el estado y los parámetros. El patrón recomendado es encapsular esta lógica dentro de la clase del traductor y reiniciarla para cada llamada a `translate()`.
 
-function escapeField(field: string, alias?: string): string {
-  const escape = (str: string) => `\`${str.replace(/`/g, '``')}\``;
-  return alias ? `${escape(alias)}.${escape(field)}` : escape(field);
-}
+El siguiente ejemplo muestra el patrón de implementación requerido para el método `translate`:
 
-class PseudoSqlTranslator extends CriteriaTranslator<
+```typescript
+class MyTranslatorWithState extends CriteriaTranslator<
   PseudoSqlParts,
-  PseudoSqlTranslationResult,
+  { query: string; params: any[] },
   PseudoSqlFilterOutput
 > {
-  private paramCounter = 0;
+  private paramCounter: number = 0;
   private collectedOrders: Array<{ alias: string; order: Order<string> }> = [];
 
-  private generateParamPlaceholder(): string {
-    this.paramCounter++;
-    return `?`;
-  }
-
-  public translate(
-    criteria: RootCriteria<any, any>,
-  ): PseudoSqlTranslationResult {
+  public override translate<RootCriteriaSchema extends CriteriaSchema>(
+    criteria: RootCriteria<RootCriteriaSchema>,
+    source: PseudoSqlParts,
+  ): { query: string; params: any[] } {
     this.paramCounter = 0;
     this.collectedOrders = [];
 
-    const initialSqlParts: PseudoSqlParts = {
-      select: [],
-      from: '',
-      joins: [],
-      where: [],
-      orderBy: [],
-      params: [],
-    };
-
-    const finalSqlParts = criteria.accept(this, initialSqlParts);
-
-    let sqlString = `SELECT ${finalSqlParts.select.join(', ') || '*'}`;
-    sqlString += ` FROM ${finalSqlParts.from}`;
-    if (finalSqlParts.joins.length > 0)
-      sqlString += ` ${finalSqlParts.joins.join(' ')}`;
-    if (finalSqlParts.where.length > 0)
-      sqlString += ` WHERE ${finalSqlParts.where.join(' AND ')}`;
-    if (finalSqlParts.orderBy.length > 0)
-      sqlString += ` ORDER BY ${finalSqlParts.orderBy.join(', ')}`;
-    if (finalSqlParts.limit !== undefined)
-      sqlString += ` LIMIT ${finalSqlParts.limit}`;
-    if (finalSqlParts.offset !== undefined)
-      sqlString += ` OFFSET ${finalSqlParts.offset}`;
+    const queryBuilder = source;
 
-    return {
-      query: sqlString,
-      params: finalSqlParts.params,
-    };
-  }
+    criteria.accept(this, queryBuilder);
 
-  visitRoot<
-    RootCriteriaSchema extends CriteriaSchema,
-    RootAlias extends SelectedAliasOf<RootCriteriaSchema>,
-  >(
-    criteria: RootCriteria<RootCriteriaSchema, RootAlias>,
-    sqlParts: PseudoSqlParts,
-  ): PseudoSqlParts {
-    sqlParts.from = `${escapeField(criteria.sourceName)} AS ${escapeField(
-      criteria.alias,
-    )}`;
-    sqlParts.select = criteria.select.map((f) =>
-      escapeField(String(f), criteria.alias),
-    );
-    if (criteria.selectAll && sqlParts.select.length === 0) {
-      sqlParts.select.push(`${escapeField(criteria.alias)}.*`);
+    let sqlString = `SELECT ${queryBuilder.select.join(', ') || '*'}`;
+    sqlString += ` FROM ${queryBuilder.from}`;
+    if (queryBuilder.joins.length > 0) {
+      sqlString += ` ${queryBuilder.joins.join(' ')}`;
     }
-
-    criteria.orders.forEach((order) =>
-      this.collectedOrders.push({ alias: criteria.alias, order }),
-    );
-
-    for (const joinDetail of criteria.joins) {
-      joinDetail.criteria.accept(this, joinDetail.parameters, sqlParts);
+    if (queryBuilder.where.length > 0) {
+      sqlString += ` WHERE ${queryBuilder.where.join(' AND ')}`;
     }
-
-    if (criteria.rootFilterGroup.items.length > 0) {
-      const filterResult = criteria.rootFilterGroup.accept(
-        this,
-        criteria.alias,
-        sqlParts,
-      );
-      if (filterResult.condition) {
-        sqlParts.where.push(filterResult.condition);
-        sqlParts.params.push(...filterResult.params);
-      }
+    if (queryBuilder.orderBy.length > 0) {
+      sqlString += ` ORDER BY ${queryBuilder.orderBy.join(', ')}`;
     }
-
-    const finalOrderByStrings: string[] = [];
-    const appliedOrderFieldsForCursor = new Set<string>();
-
-    if (criteria.cursor) {
-      const cursorFilters = criteria.cursor.filters;
-      const op =
-        criteria.cursor.operator === FilterOperator.GREATER_THAN ? '>' : '<';
-      let cursorWhereCondition = '';
-
-      if (cursorFilters.length === 1) {
-        const primaryFilter = cursorFilters[0]!;
-        const primaryPlaceholder = this.generateParamPlaceholder();
-        sqlParts.params.push(primaryFilter.value);
-        cursorWhereCondition = `(${escapeField(
-          String(primaryFilter.field),
-          criteria.alias,
-        )} ${op} ${primaryPlaceholder})`;
-      } else if (cursorFilters.length === 2) {
-        const primaryFilter = cursorFilters[0]!;
-        const secondaryFilter = cursorFilters[1]!;
-        const primaryPlaceholder = this.generateParamPlaceholder();
-        const secondaryPlaceholder = this.generateParamPlaceholder();
-        sqlParts.params.push(primaryFilter.value, secondaryFilter.value);
-        cursorWhereCondition = `((${escapeField(
-          String(primaryFilter.field),
-          criteria.alias,
-        )} ${op} ${primaryPlaceholder}) OR (${escapeField(
-          String(primaryFilter.field),
-          criteria.alias,
-        )} = ${primaryPlaceholder} AND ${escapeField(
-          String(secondaryFilter.field),
-          criteria.alias,
-        )} ${op} ${secondaryPlaceholder}))`;
-      }
-
-      if (cursorWhereCondition) {
-        sqlParts.where.push(cursorWhereCondition);
-      }
-
-      const cursorOrderDirection = criteria.cursor.order;
-      cursorFilters.forEach((cf) => {
-        const fieldKey = `${criteria.alias}.${String(cf.field)}`;
-        finalOrderByStrings.push(
-          `${escapeField(
-            String(cf.field),
-            criteria.alias,
-          )} ${cursorOrderDirection}`,
-        );
-        appliedOrderFieldsForCursor.add(fieldKey);
-      });
+    if (queryBuilder.limit !== undefined) {
+      sqlString += ` LIMIT ${queryBuilder.limit}`;
     }
-
-    this.collectedOrders
-      .sort((a, b) => a.order.sequenceId - b.order.sequenceId)
-      .forEach(({ alias, order }) => {
-        const fieldKey = `${alias}.${String(order.field)}`;
-        if (!appliedOrderFieldsForCursor.has(fieldKey)) {
-          finalOrderByStrings.push(
-            `${escapeField(String(order.field), alias)} ${order.direction}`,
-          );
-        }
-      });
-
-    if (finalOrderByStrings.length > 0) {
-      sqlParts.orderBy = finalOrderByStrings;
+    if (queryBuilder.offset !== undefined) {
+      sqlString += ` OFFSET ${queryBuilder.offset}`;
     }
 
-    if (criteria.take > 0) sqlParts.limit = criteria.take;
-    if (criteria.skip > 0) sqlParts.offset = criteria.skip;
+    return {
+      query: sqlString,
+      params: queryBuilder.params,
+    };
+  }
 
-    return sqlParts;
+  public override visitRoot<RootCSchema extends CriteriaSchema>(
+    criteria: RootCriteria<RootCSchema>,
+    context: PseudoSqlParts,
+  ): void {
+    // Implementation would go here...
   }
 
-  private applyPseudoJoin<
+  public override visitInnerJoin<
     ParentCSchema extends CriteriaSchema,
-    JoinCriteriaSchema extends CriteriaSchema,
-    JoinAlias extends SelectedAliasOf<JoinCriteriaSchema>,
+    JoinCSchema extends CriteriaSchema,
   >(
-    joinType: string,
-    criteria:
-      | InnerJoinCriteria<JoinCriteriaSchema, JoinAlias>
-      | LeftJoinCriteria<JoinCriteriaSchema, JoinAlias>
-      | OuterJoinCriteria<JoinCriteriaSchema, JoinAlias>,
+    criteria: InnerJoinCriteria<JoinCSchema>,
     parameters:
-      | PivotJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>
-      | SimpleJoin<ParentCSchema, JoinCriteriaSchema, JoinRelationType>,
-    sqlParts: PseudoSqlParts,
-  ): PseudoSqlParts {
-    const joinTable = `${escapeField(criteria.sourceName)} AS ${escapeField(
-      criteria.alias,
-    )}`;
-    let onCondition = '';
-
-    if ('pivot_source_name' in parameters) {
-      const pivotAlias = `${parameters.parent_alias}_${criteria.alias}_pivot`;
-      const pivotTable = `${escapeField(
-        parameters.pivot_source_name,
-      )} AS ${escapeField(pivotAlias)}`;
-      sqlParts.joins.push(
-        `${joinType} JOIN ${pivotTable} ON ${escapeField(
-          String(parameters.parent_field.reference),
-          parameters.parent_alias,
-        )} = ${escapeField(parameters.parent_field.pivot_field, pivotAlias)}`,
-      );
-      onCondition = `${escapeField(
-        parameters.join_field.pivot_field,
-        pivotAlias,
-      )} = ${escapeField(
-        String(parameters.join_field.reference),
-        criteria.alias,
-      )}`;
-      sqlParts.joins.push(`${joinType} JOIN ${joinTable} ON ${onCondition}`);
-    } else {
-      onCondition = `${escapeField(
-        String(parameters.parent_field),
-        parameters.parent_alias,
-      )} = ${escapeField(String(parameters.join_field), criteria.alias)}`;
-      sqlParts.joins.push(`${joinType} JOIN ${joinTable} ON ${onCondition}`);
-    }
-
-    if (criteria.rootFilterGroup.items.length > 0) {
-      const filterResult = criteria.rootFilterGroup.accept(
-        this,
-        criteria.alias,
-        sqlParts,
-      );
-      if (filterResult.condition) {
-        const lastJoinIndex = sqlParts.joins.length - 1;
-        if (sqlParts.joins[lastJoinIndex]) {
-          sqlParts.joins[lastJoinIndex] += ` AND (${filterResult.condition})`;
-          sqlParts.params.push(...filterResult.params);
-        }
-      }
-    }
-
-    criteria.select.forEach((f) =>
-      sqlParts.select.push(escapeField(String(f), criteria.alias)),
-    );
-    if (criteria.selectAll && criteria.select.length === 0) {
-      sqlParts.select.push(`${escapeField(criteria.alias)}.*`);
-    }
-
-    criteria.orders.forEach((order) =>
-      this.collectedOrders.push({ alias: criteria.alias, order }),
-    );
-
-    for (const subJoinDetail of criteria.joins) {
-      subJoinDetail.criteria.accept(this, subJoinDetail.parameters, sqlParts);
-    }
-
-    return sqlParts;
-  }
-
-  visitInnerJoin(
-    criteria: InnerJoinCriteria<any, any>,
-    parameters: any,
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
     context: PseudoSqlParts,
-  ): PseudoSqlParts {
-    return this.applyPseudoJoin('INNER', criteria, parameters, context);
+  ): void {
+    // Implementation would go here...
   }
-  visitLeftJoin(
-    criteria: LeftJoinCriteria<any, any>,
-    parameters: any,
+
+  public override visitLeftJoin<
+    ParentCSchema extends CriteriaSchema,
+    JoinCSchema extends CriteriaSchema,
+  >(
+    criteria: LeftJoinCriteria<JoinCSchema>,
+    parameters:
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
     context: PseudoSqlParts,
-  ): PseudoSqlParts {
-    return this.applyPseudoJoin('LEFT', criteria, parameters, context);
+  ): void {
+    // Implementation would go here...
   }
-  visitOuterJoin(
-    criteria: OuterJoinCriteria<any, any>,
-    parameters: any,
+
+  public override visitOuterJoin<
+    ParentCSchema extends CriteriaSchema,
+    JoinCSchema extends CriteriaSchema,
+  >(
+    criteria: OuterJoinCriteria<JoinCSchema>,
+    parameters:
+      | PivotJoin<ParentCSchema, JoinCSchema, JoinRelationType>
+      | SimpleJoin<ParentCSchema, JoinCSchema, JoinRelationType>,
     context: PseudoSqlParts,
-  ): PseudoSqlParts {
-    return this.applyPseudoJoin('FULL OUTER', criteria, parameters, context);
+  ): void {
+    // Implementation would go here...
   }
 
-  visitFilter<FieldType extends string, Operator extends FilterOperator>(
-    filter: Filter<FieldType, Operator>,
+  public override visitFilter<FieldType extends string>(
+    filter: Filter<FieldType, FilterOperator>,
     currentAlias: string,
+    context: PseudoSqlParts,
   ): PseudoSqlFilterOutput {
-    const fieldName = escapeField(String(filter.field), currentAlias);
-    const params: any[] = [];
-    let condition = '';
-
-    switch (filter.operator) {
-      case FilterOperator.EQUALS:
-        condition = `${fieldName} = ${this.generateParamPlaceholder()}`;
-        params.push(filter.value);
-        break;
-      case FilterOperator.NOT_EQUALS:
-        condition = `${fieldName} != ${this.generateParamPlaceholder()}`;
-        params.push(filter.value);
-        break;
-      case FilterOperator.LIKE:
-      case FilterOperator.CONTAINS:
-      case FilterOperator.STARTS_WITH:
-      case FilterOperator.ENDS_WITH:
-        let val = String(filter.value);
-        if (filter.operator === FilterOperator.CONTAINS) val = `%${val}%`;
-        else if (filter.operator === FilterOperator.STARTS_WITH)
-          val = `${val}%`;
-        else if (filter.operator === FilterOperator.ENDS_WITH) val = `%${val}`;
-        condition = `${fieldName} LIKE ${this.generateParamPlaceholder()}`;
-        params.push(val);
-        break;
-      case FilterOperator.IN:
-        if (!Array.isArray(filter.value) || filter.value.length === 0) {
-          condition = '1=0';
-        } else {
-          const placeholders = (filter.value as any[])
-            .map(() => this.generateParamPlaceholder())
-            .join(', ');
-          condition = `${fieldName} IN (${placeholders})`;
-          params.push(...(filter.value as any[]));
-        }
-        break;
-      case FilterOperator.IS_NULL:
-        condition = `${fieldName} IS NULL`;
-        break;
-      case FilterOperator.IS_NOT_NULL:
-        condition = `${fieldName} IS NOT NULL`;
-        break;
-      case FilterOperator.JSON_CONTAINS:
-        if (typeof filter.value === 'object' && filter.value !== null) {
-          const jsonConditions: string[] = [];
-          for (const path in filter.value) {
-            const pathValue = (filter.value as Record<string, any>)[path];
-            jsonConditions.push(
-              `JSON_CONTAINS(${fieldName}, '${JSON.stringify(
-                pathValue,
-              )}', '$.${path}')`,
-            );
-          }
-          condition = jsonConditions.join(' AND ');
-        } else {
-          condition = '1=0';
-        }
-        break;
-      default:
-        condition = `${fieldName} ${
-          filter.operator
-        } ${this.generateParamPlaceholder()}`;
-        params.push(filter.value);
-    }
-    return {
-      condition,
-      params: params.map((p) => (p === undefined ? null : p)),
-    };
+    // Implementation would go here...
+    return { condition: '', params: [] };
   }
 
-  visitAndGroup<FieldType extends string>(
+  public override visitAndGroup<FieldType extends string>(
     group: FilterGroup<FieldType>,
     currentAlias: string,
-    sqlParts: PseudoSqlParts,
-  ): PseudoSqlFilterOutput {
-    const conditions: string[] = [];
-    const allParams: any[] = [];
-    group.items.forEach((item) => {
-      const result = item.accept(this, currentAlias, sqlParts);
-      if (result.condition) {
-        conditions.push(result.condition);
-        allParams.push(...result.params);
-      }
-    });
-    if (conditions.length === 0) return { condition: '', params: [] };
-    return { condition: `(${conditions.join(' AND ')})`, params: allParams };
+    context: PseudoSqlParts,
+  ): void {
+    // Implementation would go here...
   }
 
-  visitOrGroup<FieldType extends string>(
+  public override visitOrGroup<FieldType extends string>(
     group: FilterGroup<FieldType>,
     currentAlias: string,
-    sqlParts: PseudoSqlParts,
-  ): PseudoSqlFilterOutput {
-    const conditions: string[] = [];
-    const allParams: any[] = [];
-    group.items.forEach((item) => {
-      const result = item.accept(this, currentAlias, sqlParts);
-      if (result.condition) {
-        conditions.push(result.condition);
-        allParams.push(...result.params);
-      }
-    });
-    if (conditions.length === 0) return { condition: '', params: [] };
-    return { condition: `(${conditions.join(' OR ')})`, params: allParams };
+    context: PseudoSqlParts,
+  ): void {
+    // Implementation would go here...
   }
 }
 ```
 
-```typescript
-// ... (definición de UserSchema, CriteriaFactory, etc.)
+**Explicación:**
+
+El método `translate` que implementas es el punto de entrada público. Es responsable de:
 
-// const userCriteria = CriteriaFactory.GetCriteria(UserSchema, 'users')
-//   .where({ field: 'email', operator: FilterOperator.CONTAINS, value: '@example.com' })
-//   .orderBy('username', OrderDirection.ASC)
-//   .setTake(10);
+1.  **Reiniciar el estado interno:** Asegura que cada traducción comience con un estado limpio (ej. `paramCounter` y `collectedOrders` se reinician).
+2.  **Inicializar el `TranslationContext`:** Crea el objeto inicial (ej. `queryBuilder`) que será modificado por los métodos `visit...`.
+3.  **Iniciar el recorrido:** Este es el paso crucial donde llamas a `criteria.accept(this, queryBuilder)` para comenzar el patrón Visitor. Todos los métodos `visit...` posteriores modificarán el objeto `queryBuilder` directamente.
+4.  **Ensamblar la consulta final:** Después de que el recorrido se complete, construye la cadena de consulta final (ej. SQL) combinando las partes acumuladas de `queryBuilder`.
+5.  **Devolver el resultado:** Devuelve la consulta final y sus parámetros.
 
-// const pseudoTranslator = new PseudoSqlTranslator();
-// const { query: generatedSql, params: queryParams } = pseudoTranslator.translate(userCriteria);
+---
+
+## 6. Ejemplo Completo: Traductor a Pseudo-SQL
+
+### 6.1. Implementación del Traductor
+
+Para un ejemplo completo y funcional de una implementación de `CriteriaTranslator`, por favor consulta el archivo [`PseudoSqlTranslator`](../../../criteria/translator/example/pseudo-sql.translator.ts) en el repositorio. Este archivo contiene el código completo de la clase [`PseudoSqlTranslator`](../../../criteria/translator/example/pseudo-sql.translator.ts), que traduce objetos `Criteria` a una cadena de pseudo-SQL.
+
+### 6.2. Uso del Traductor
+
+Así es como usarías el [`PseudoSqlTranslator`](../../../criteria/translator/example/pseudo-sql.translator.ts):
+
+```typescript
+import {
+  CriteriaFactory,
+  FilterOperator,
+  OrderDirection,
+} from '@nulledexp/translatable-criteria';
+import { UserSchema } from './path/to/your/schemas';
+import {
+  PseudoSqlTranslator,
+  type PseudoSqlParts,
+} from './path/to/your/pseudo-sql.translator';
+
+const userCriteria = CriteriaFactory.GetCriteria(UserSchema)
+  .where({
+    field: 'email',
+    operator: FilterOperator.CONTAINS,
+    value: '@example.com',
+  })
+  .orderBy('username', OrderDirection.ASC)
+  .setTake(10);
+
+const pseudoTranslator = new PseudoSqlTranslator();
+
+const initialParts: PseudoSqlParts = {
+  select: [],
+  from: '',
+  joins: [],
+  where: [],
+  orderBy: [],
+  params: [],
+};
 
-// console.log('Generated SQL:', generatedSql);
-// console.log('Parameters:', queryParams);
+const { query: generatedSql, params: queryParams } = pseudoTranslator.translate(
+  userCriteria,
+  initialParts,
+);
 
-// Salida esperada (ejemplo):
-// Generated SQL: SELECT `users`.`uuid`, `users`.`email`, `users`.`username`, `users`.`created_at` FROM `user` AS `users` WHERE (`users`.`email` LIKE ?) ORDER BY `users`.`username` ASC LIMIT ? OFFSET ?;
-// Parameters: [ '%@example.com%', 10, 0 ]
+console.log('Generated SQL:', generatedSql);
+console.log('Parameters:', queryParams);
 ```
 
 ---
@@ -1134,10 +554,9 @@ class PseudoSqlTranslator extends CriteriaTranslator<
 - **Errores y Validación:** Decide cómo manejar operadores o configuraciones no soportadas por tu fuente de datos. Puedes lanzar errores o ignorarlos.
 - **Optimización:** Considera las optimizaciones específicas de tu fuente de datos.
 - **Pruebas:** Escribe pruebas unitarias y de integración exhaustivas para tu traductor. Usa `CriteriaFactory` para construir diversos escenarios de `Criteria` y verifica que la salida de tu traductor sea la esperada.
-- **Documentación:** Si compartes tu traductor, documenta claramente qué características soporta y cómo usarlo.
 
 ---
 
-## Próximos Pasos Traductores
+## Próximos Pasos
 
-Con esta guía, tienes las bases para empezar a desarrollar tus propios traductores. Revisa los traductores existentes (si los hay) como referencia y no dudes en experimentar.
+Con esta guía, tienes las bases para empezar a desarrollar tus propios traductores. Para una referencia detallada de todas las clases y tipos, consulta la Referencia de API.
diff --git a/src/docs/guides/schema-definitions/en.md b/src/docs/guides/schema-definitions/en.md
index cb76903..f464b43 100644
--- a/src/docs/guides/schema-definitions/en.md
+++ b/src/docs/guides/schema-definitions/en.md
@@ -8,106 +8,114 @@ This guide will show you how to define schemas for your entities using the `GetT
 
 The `GetTypedCriteriaSchema` function is crucial because:
 
-1.  **Preserves Literal Types:** It maintains the exact types of your `fields` and `alias` (e.g., `'uuid' | 'email'` instead of `string`). This is fundamental for autocompletion and strict compile-time validation when you build your `Criteria`.
-2.  **Structural Validation:** Although `GetTypedCriteriaSchema` is an identity function at runtime (it simply returns the object you pass to it), its typing helps ensure that the structure of your schema (presence of `source_name`, `alias`, `fields`, `joins`) is correct.
+1.  **Preserves Literal Types:** It maintains the exact types of your `fields` and `alias` (e.g., `'id' | 'email'` instead of `string`). This is fundamental for autocompletion and strict compile-time validation when you build your `Criteria`.
+
+2.  **Structural Validation:** Although `GetTypedCriteriaSchema` is an identity function at runtime (it simply returns the object you pass to it), its typing helps ensure that the structure of your schema (presence of `source_name`, `alias`, `fields`, `identifier_field`, `joins`) is correct.
 3.  **Avoids `as const`:** It eliminates the need to use `as const` assertions in your schema definitions to achieve literal type preservation, making the code cleaner.
 
 ## Structure of a Schema
 
 A `CriteriaSchema` is defined with the following main fields:
 
+```typescript
+{
+    source_name: string;
+    alias: string;
+    fields: readonly string[];
+    identifier_field: string;
+    joins: readonly {
+        alias: string;
+        target_source_name: string;
+        relation_type: 'one_to_one' | 'one_to_many' | 'many_to_one' | 'many_to_many';
+        metadata?: { [key: string]: any };
+    }[];
+    metadata?: { [key: string]: any };
+}
+```
+
 - `source_name`: (string) The actual name of the table or collection in your database.
-- `alias`: (array of strings) A list of aliases you can use to refer to this entity when building `Criteria`. The first alias is usually the primary or most descriptive one.
-- `fields`: (array of strings) A list of all queryable fields for this entity.
-- `joins`: (array of objects) Defines the relationships this entity has with others. Each join object specifies:
-  - `alias`: (string) The alias you will use to refer to the joined entity (must match one of the `alias` defined in the joined entity's schema).
-  - `join_relation_type`: (string) The type of relationship, such as `'one_to_many'`, `'many_to_one'`, `'one_to_one'`, or `'many_to_many'`.
-  - `metadata`: (optional object) An optional field to store arbitrary, translator-specific information or hints directly within the schema definition for this specific join.
-- `metadata`: (optional object) An optional field at the root of the schema to store arbitrary, translator-specific information or configuration relevant to the entire entity this schema represents.
+- `alias`: (string) A **single, canonical alias** you will use to refer to this entity when it's the root of a query.
+- `fields`: (readonly string[]) A list of all queryable fields for this entity.
+- `identifier_field`: (string) **(Mandatory)** The name of the field that uniquely identifies an entity of this schema (e.g., its primary key). This field **must** be one of the names listed in the `fields` array.
+- `joins`: (readonly object[]) Defines the relationships this entity has with others. Each join object specifies:
+- `alias`: (string) The alias you will use to refer to this specific **join relation** (e.g., `'posts'`, `'author'`). This is the alias you will pass to the `.join()` method.
+- `target_source_name`: (string) The `source_name` of the entity schema you are joining to. This is used for robust validation.
+- `relation_type`: (string) The type of relationship, such as `'one_to_many'`, `'many_to_one'`, or `'many_to_many'`.
+- `metadata`: (optional object) An optional field to store arbitrary, translator-specific information for this specific join.
+- `metadata`: (optional object) An optional field at the root of the schema to store arbitrary, translator-specific information for the entire entity.
 
-## Example: Defining the `UserSchema`
+## Schema Examples
 
-Based on a `User` entity that might have fields like `uuid`, `email`, `username`, `created_at` and relationships with `Address`, `Permission`, and `Post`, here's how we would define its schema:
+To ensure consistency across the documentation, we will use a unified set of schemas. These examples define `User`, `Post`, and `Role` entities and their relationships.
 
 ```typescript
 import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
 
 export const UserSchema = GetTypedCriteriaSchema({
-  source_name: 'user', // Table name in the database
-  alias: ['users', 'user', 'publisher'], // Possible aliases for this entity
-  fields: ['uuid', 'email', 'username', 'created_at'],
+  source_name: 'users',
+  alias: 'u',
+  fields: ['id', 'username', 'email', 'age', 'isActive', 'createdAt', 'tags'],
+  identifier_field: 'id',
   joins: [
     {
-      alias: 'permissions', // Alias for the Permission entity
-      join_relation_type: 'many_to_many',
-    },
-    {
-      alias: 'addresses', // Alias for the Address entity
-      join_relation_type: 'one_to_many',
+      alias: 'posts',
+      target_source_name: 'posts',
+      relation_type: 'one_to_many',
     },
     {
-      alias: 'posts', // Alias for the Post entity
-      join_relation_type: 'one_to_many',
+      alias: 'roles',
+      target_source_name: 'roles',
+      relation_type: 'many_to_many',
     },
   ],
 });
 
-// Export the type for use in your application
-export type UserSchema = typeof UserSchema;
-```
-
-**Breakdown of the `UserSchema` Example:**
-
-- `source_name: 'user'`: Indicates that user data is located in a table/collection named `user`.
-- `alias: ['users', 'user', 'publisher']`: We can refer to the `User` entity as `users`, `user`, or `publisher` when creating `Criteria`.
-- `fields: [...]`: Lists the directly queryable fields of the `User` entity.
-- `joins: [...]`:
-  - Defines a `many_to_many` relationship with an entity whose alias is `permissions`.
-  - Defines a `one_to_many` relationship with an entity whose alias is `addresses`.
-  - Defines a `one_to_many` relationship with an entity whose alias is `posts`.
-
-## Example: Defining the `PostSchema`
-
-Similarly, for a `Post` entity:
-
-```typescript
-import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
-
 export const PostSchema = GetTypedCriteriaSchema({
-  source_name: 'post',
-  alias: ['posts', 'post'],
+  source_name: 'posts',
+  alias: 'p',
   fields: [
-    'uuid',
-    'categories',
+    'id',
     'title',
-    'body',
-    'user_uuid', // Foreign key to the User (publisher)
-    'created_at',
-    'metadata', // Example of a JSON field
+    'content',
+    'userId',
+    'createdAt',
+    'categories',
+    'metadata',
   ],
+  identifier_field: 'id',
   joins: [
     {
-      alias: 'comments', // Alias for the Comment entity
-      join_relation_type: 'one_to_many',
-    },
-    {
-      alias: 'publisher', // Alias for the User entity (the post author)
-      join_relation_type: 'many_to_one',
+      alias: 'user',
+      target_source_name: 'users',
+      relation_type: 'many_to_one',
     },
   ],
 });
 
-export type PostSchema = typeof PostSchema;
+export const RoleSchema = GetTypedCriteriaSchema({
+  source_name: 'roles',
+  alias: 'r',
+  fields: ['id', 'name'],
+  identifier_field: 'id',
+  joins: [],
+});
 ```
 
-**Key Points of the `PostSchema`:**
+### Breakdown of the `UserSchema` Example
+
+- **`source_name: 'users'`**: Indicates that user data is located in a source (e.g., table) named `users`.
+- **`alias: 'u'`**: The canonical alias for the `User` entity is `'u'`. When creating a `RootCriteria` for users, it will be aliased as `u` in the query.
+- **`fields: [...]`**: Lists the directly queryable fields of the `User` entity, including fields like `tags` that can be used with advanced operators.
+- **`identifier_field: 'id'`**: Specifies `id` as the unique identifier for `User` entities.
+- **`joins: [...]`**:
+    - The first join defines a relationship named `'posts'`. This is the alias you will use in the `.join('posts', ...)` method. It targets the `posts` source and is a `one_to_many` relation.
+    - The second join defines a relationship named `'roles'`, targeting the `roles` source with a `many_to_many` relation.
+
+### Breakdown of the `PostSchema` Example
 
-- `fields`: Includes fields like `categories` and `metadata`. These fields might be of complex types (arrays, JSON) in your database, and the library allows filtering them using specific operators (see the guide on building criteria).
-- `user_uuid`: This field likely represents the foreign key to the `User` entity. Although the relationship is defined in `joins`, listing the FK field in `fields` allows direct filtering by it if needed.
-- `joins`:
-  - `comments`: A post can have many comments (`one_to_many`).
-  - `publisher`: A post belongs to one user (`many_to_one`). Note how the `alias` `publisher` here matches one of the `alias` defined in `UserSchema`.
+- **`joins: [...]`**:
+    - Defines a relationship named `'user'`. This allows you to join from a `Post` back to its author (`User`) using `.join('user', ...)`.
 
-## Exporting the Schema Type
+## Next Steps
 
-It is a recommended practice to also export the inferred type of your schema:
+Now that you know how to define schemas, the next step is to learn how to [Build Criteria using these schemas.](../building-criteria/en.md)
\ No newline at end of file
diff --git a/src/docs/guides/schema-definitions/es.md b/src/docs/guides/schema-definitions/es.md
index 9e76e5d..51a0221 100644
--- a/src/docs/guides/schema-definitions/es.md
+++ b/src/docs/guides/schema-definitions/es.md
@@ -8,112 +8,115 @@ Esta guía te mostrará cómo definir esquemas para tus entidades utilizando la
 
 La función `GetTypedCriteriaSchema` es crucial porque:
 
-1.  **Preserva los Tipos Literales:** Mantiene los tipos exactos de tus `fields` y `alias` (por ejemplo, `'uuid' | 'email'` en lugar de `string`). Esto es fundamental para el autocompletado y la validación estricta en tiempo de compilación cuando construyes tus `Criteria`.
-2.  **Validación Estructural:** Aunque `GetTypedCriteriaSchema` es una función de identidad en tiempo de ejecución (simplemente devuelve el objeto que le pasas), su tipado ayuda a asegurar que la estructura de tu esquema (presencia de `source_name`, `alias`, `fields`, `joins`) sea correcta.
+1.  **Preserva los Tipos Literales:** Mantiene los tipos exactos de tus `fields` y `alias` (por ejemplo, `'id' | 'email'` en lugar de `string`). Esto es fundamental para el autocompletado y la validación estricta en tiempo de compilación cuando construyes tus `Criteria`.
+
+2.  **Validación Estructural:** Aunque `GetTypedCriteriaSchema` es una función de identidad en tiempo de ejecución (simplemente devuelve el objeto que le pasas), su tipado ayuda a asegurar que la estructura de tu esquema (presencia de `source_name`, `alias`, `fields`, `identifier_field`, `joins`) sea correcta.
 3.  **Evita `as const`:** Elimina la necesidad de usar aserciones `as const` en tus definiciones de esquema para lograr la preservación de tipos literales, haciendo el código más limpio.
 
 ## Estructura de un Esquema
 
 Un `CriteriaSchema` se define con los siguientes campos principales:
 
+```typescript
+{
+    source_name: string;
+    alias: string;
+    fields: readonly string[];
+    identifier_field: string;
+    joins: readonly {
+        alias: string;
+        target_source_name: string;
+        relation_type: 'one_to_one' | 'one_to_many' | 'many_to_one' | 'many_to_many';
+        metadata?: { [key: string]: any };
+    }[];
+    metadata?: { [key: string]: any };
+}
+```
+
 - `source_name`: (string) El nombre real de la tabla o colección en tu base de datos.
-- `alias`: (array de strings) Una lista de alias que puedes usar para referirte a esta entidad al construir `Criteria`. El primer alias suele ser el principal o el más descriptivo.
-- `fields`: (array de strings) Una lista de todos los campos consultables para esta entidad.
-- `joins`: (array de objetos) Define las relaciones que esta entidad tiene con otras. Cada objeto de join especifica:
-  - `alias`: (string) El alias que usarás para referirte a la entidad unida (debe coincidir con uno de los `alias` definidos en el esquema de la entidad unida).
-  - `join_relation_type`: (string) El tipo de relación, como `'one_to_many'`, `'many_to_one'`, `'one_to_one'`, o `'many_to_many'`.
-  - `metadata`: (objeto opcional) Un campo opcional para almacenar información arbitraria específica del traductor o pistas directamente dentro de la definición del esquema para esta unión específica.
-- `metadata`: (objeto opcional) Un campo opcional en la raíz del esquema para almacenar información arbitraria específica del traductor o configuración relevante para toda la entidad que este esquema representa.
+- `alias`: (string) Un **único alias canónico** que usarás para referirte a esta entidad cuando sea la raíz de una consulta.
+- `fields`: (readonly string[]) Una lista de todos los campos consultables para esta entidad.
+- `identifier_field`: (string) **(Obligatorio)** El nombre del campo que identifica unívocamente una entidad de este esquema (ej. su clave primaria). Este campo **debe** ser uno de los nombres listados en el array `fields`.
+- `joins`: (readonly object[]) Define las relaciones que esta entidad tiene con otras. Cada objeto de join especifica:
+- `alias`: (string) El alias que usarás para referirte a esta **relación de unión específica** (ej. `'posts'`, `'autor'`). Este es el alias que pasarás al método `.join()`.
+- `target_source_name`: (string) El `source_name` del esquema de la entidad a la que te estás uniendo. Esto se usa para una validación robusta.
+- `relation_type`: (string) El tipo de relación, como `'one_to_many'`, `'many_to_one'`, o `'many_to_many'`.
+- `metadata`: (objeto opcional) Un campo opcional para almacenar información arbitraria, específica del traductor para esta unión específica.
+- `metadata`: (objeto opcional) Un campo opcional en la raíz del esquema para almacenar información arbitraria, específica del traductor para toda la entidad.
 
-## Ejemplo: Definiendo el Esquema `UserSchema`
+## Ejemplos de Esquemas
 
-Basándonos en una entidad `User` que podría tener campos como `uuid`, `email`, `username`, `created_at` y relaciones con `Address`, `Permission` y `Post`, así es como definiríamos su esquema:
+Para asegurar la consistencia a lo largo de la documentación, usaremos un conjunto unificado de esquemas. Estos ejemplos definen las entidades `User`, `Post` y `Role` y sus relaciones.
 
 ```typescript
 import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
 
 export const UserSchema = GetTypedCriteriaSchema({
-  source_name: 'user', // Nombre de la tabla en la base de datos
-  alias: ['users', 'user', 'publisher'], // Posibles alias para esta entidad
-  fields: ['uuid', 'email', 'username', 'created_at'],
+  source_name: 'users',
+  alias: 'u',
+  fields: ['id', 'username', 'email', 'age', 'isActive', 'createdAt', 'tags'],
+  identifier_field: 'id',
   joins: [
     {
-      alias: 'permissions', // Alias para la entidad Permission
-      join_relation_type: 'many_to_many',
-    },
-    {
-      alias: 'addresses', // Alias para la entidad Address
-      join_relation_type: 'one_to_many',
+      alias: 'posts',
+      target_source_name: 'posts',
+      relation_type: 'one_to_many',
     },
     {
-      alias: 'posts', // Alias para la entidad Post
-      join_relation_type: 'one_to_many',
+      alias: 'roles',
+      target_source_name: 'roles',
+      relation_type: 'many_to_many',
     },
   ],
 });
 
-// Exportar el tipo para usarlo en tu aplicación
-export type UserSchema = typeof UserSchema;
-```
-
-**Desglose del Ejemplo `UserSchema`:**
-
-- `source_name: 'user'`: Indica que los datos de los usuarios se encuentran en una tabla/colección llamada `user`.
-- `alias: ['users', 'user', 'publisher']`: Podemos referirnos a la entidad `User` como `users`, `user`, o `publisher` al crear `Criteria`.
-- `fields: [...]`: Lista los campos directamente consultables de la entidad `User`.
-- `joins: [...]`:
-  - Define una relación `many_to_many` con una entidad cuyo alias es `permissions`.
-  - Define una relación `one_to_many` con una entidad cuyo alias es `addresses`.
-  - Define una relación `one_to_many` con una entidad cuyo alias es `posts`.
-
-## Ejemplo: Definiendo el Esquema `PostSchema`
-
-De manera similar, para una entidad `Post`:
-
-```typescript
-import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
-
 export const PostSchema = GetTypedCriteriaSchema({
-  source_name: 'post',
-  alias: ['posts', 'post'],
+  source_name: 'posts',
+  alias: 'p',
   fields: [
-    'uuid',
-    'categories',
+    'id',
     'title',
-    'body',
-    'user_uuid', // Clave foránea al User (publisher)
-    'created_at',
-    'metadata', // Ejemplo de un campo JSON
+    'content',
+    'userId',
+    'createdAt',
+    'categories',
+    'metadata',
   ],
+  identifier_field: 'id',
   joins: [
     {
-      alias: 'comments', // Alias para la entidad Comment
-      join_relation_type: 'one_to_many',
-    },
-    {
-      alias: 'publisher', // Alias para la entidad User (el autor del post)
-      join_relation_type: 'many_to_one',
+      alias: 'user',
+      target_source_name: 'users',
+      relation_type: 'many_to_one',
     },
   ],
 });
 
-export type PostSchema = typeof PostSchema;
-```
+export const RoleSchema = GetTypedCriteriaSchema({
+  source_name: 'roles',
+  alias: 'r',
+  fields: ['id', 'name'],
+  identifier_field: 'id',
+  joins: [],
+});
 
-**Puntos Clave del `PostSchema`:**
+```
 
-- `fields`: Incluye campos como `categories` y `metadata`. Estos campos podrían ser de tipos complejos (arrays, JSON) en tu base de datos, y la librería permite filtrarlos usando operadores específicos (ver la guía de construcción de criterios).
-- `user_uuid`: Es un campo que probablemente representa la clave foránea hacia la entidad `User`. Aunque la relación se define en `joins`, tener el campo de la FK listado en `fields` permite filtrar directamente por él si es necesario.
-- `joins`:
-  - `comments`: Un post puede tener muchos comentarios (`one_to_many`).
-  - `publisher`: Un post pertenece a un usuario (`many_to_one`). Nota cómo el `alias` `publisher` aquí coincide con uno de los `alias` definidos en `UserSchema`.
+### Desglose del Ejemplo `UserSchema`
 
-## Exportando el Tipo del Esquema
+- **`source_name: 'users'`**: Indica que los datos de los usuarios se encuentran en una fuente (ej. tabla) llamada `users`.
+- **`alias: 'u'`**: El alias canónico para la entidad `User` es `'u'`. Al crear un `RootCriteria` para usuarios, se le asignará el alias `u` en la consulta.
+- **`fields: [...]`**: Lista los campos directamente consultables de la entidad `User`, incluyendo campos como `tags` que pueden ser usados con operadores avanzados.
+- **`identifier_field: 'id'`**: Especifica `id` como el identificador único para las entidades `User`.
+- **`joins: [...]`**:
+  - La primera unión define una relación llamada `'posts'`. Este es el alias que usarás en el método `.join('posts', ...)`. Apunta a la fuente `posts` y es una relación `one_to_many`.
+  - La segunda unión define una relación llamada `'roles'`, que apunta a la fuente `roles` con una relación `many_to_many`.
 
-Es una práctica recomendada exportar también el tipo inferido de tu esquema:
+### Desglose del Ejemplo `PostSchema`
 
-Esto te permite usar `UserSchema` (el tipo) en otras partes de tu aplicación para asegurar la coherencia y aprovechar la seguridad de tipos de TypeScript al interactuar con objetos que deben conformarse a la estructura del esquema.
+- **`joins: [...]`**:
+  - Define una relación llamada `'user'`. Esto te permite unirte desde un `Post` de vuelta a su autor (`User`) usando `.join('user', ...)`.
 
 ## Próximos Pasos
 
-Ahora que sabes cómo definir esquemas, el siguiente paso es aprender a Construir Criterios utilizando estos esquemas.
+Ahora que sabes cómo definir esquemas, el siguiente paso es aprender a [Construir Criterios utilizando estos esquemas.](../building-criteria/es.md)
diff --git a/src/docs/introduction/en.md b/src/docs/introduction/en.md
index f4aa016..477e10b 100644
--- a/src/docs/introduction/en.md
+++ b/src/docs/introduction/en.md
@@ -10,7 +10,10 @@ in your TypeScript applications.
 (filtering, ordering, joins, pagination, etc.) in an abstract, data-source-agnostic manner.
 
 With `@nulledexp/translatable-criteria`, you define these criteria as structured, type-safe
-objects. This contrasts with writing SQL directly, using a specific ORM's syntax directly
+objects. The library has evolved to offer even more robust schema validation and provide
+richer contextual information to translators, further simplifying the development of
+sophisticated data source integrations.
+This contrasts with writing SQL directly, using a specific ORM's syntax directly
 in your use cases, or developing multiple methods with convoluted and tightly coupled logic
 in your repositories.
 
@@ -23,23 +26,23 @@ for your particular database or data source (e.g., SQL for TypeORM, queries for
 
 ## What Problem Does It Solve?
 
-In many applications, the logic for querying data is mixed with business code or tightly
-coupled to a specific ORM or database. This can lead to:
+Many applications face the challenge of creating flexible and reusable data access logic. A common symptom is the **proliferation of specialized query methods** like `getUserByUuid`, `getUserByEmail`, or `getPostByUuidAndTitleAndCategories`. This approach quickly becomes a maintenance bottleneck.
 
-- **Difficulty changing databases or ORMs:** If you decide to migrate, much of your query
-  code needs to be rewritten.
-- **Complexity in business logic:** Complex queries can become difficult to read, maintain,
-  and test.
-- **Code repetition:** Similar filtering or pagination logic might be duplicated in
-  different parts of the application.
-- **Reduced testability:** Testing query logic in isolation becomes complicated.
+This problem is compounded because the "context" of a query can change. For example, fetching a post for a regular user is not the same as fetching it for its author, a moderator, or an analytics service. Each context may require different fields, joins, or filters. This leads to:
 
-`@nulledexp/translatable-criteria` addresses these problems by:
+- **Method Explosion:** A constant need to write new methods for every minor variation in filtering, coupling the data access layer to specific use cases.
+- **Maintenance Burden:** New business requirements often force developers to create more and more methods, increasing complexity and the risk of bugs.
+- **Tight Coupling:** The application logic becomes tightly coupled to a specific data source or ORM, making future migrations or changes difficult.
+- **Contextual Complexity:** The logic to handle different access contexts (e.g., user vs. admin) gets scattered and duplicated.
 
-- **Decoupling query definition from execution:** Define _what_ data you need, not _how_ to get it from a specific source.
-- **Promoting reusability:** Criteria can be built, combined, and reused.
-- **Improving type safety:** Thanks to schemas, you can build criteria with compile-time and runtime validation.
-- **Facilitating testing:** You can test criteria construction logic independently.
+`@nulledexp/translatable-criteria` provides a more abstract and ideal solution. By allowing you to build query specifications dynamically, it addresses these issues by:
+
+- **Decoupling query definition from execution:** Define _what_ data you need, not _how_ to get it.
+- **Promoting reusability:** A single query method can handle countless variations by accepting a `Criteria` object.
+- **Improving type safety:** Build criteria with strong compile-time validation.
+- **Facilitating testing:** Test query construction logic independently of the database.
+
+While adopting any library introduces a degree of coupling, `@nulledexp/translatable-criteria` offers a strategic trade-off. You couple your application to a predictable and maintainable query-building flow in exchange for **decoupling your business logic from the underlying data source and its specific implementation**. This results in a more manageable, predictable, and adaptable architecture in the long run.
 
 ## Who Is This Library For?
 
@@ -53,11 +56,11 @@ This library is ideal for developers and teams who:
 
 ## Key Benefits
 
-- **Enhanced Type Safety:** Build queries with a fluent, strongly-typed interface.
-- **Powerful Filtering:** Define intricate filtering logic with multiple operators and grouping.
-- **Flexible Join System:** Support for various join types and pivot table configurations.
-- **Advanced Pagination:** Support for offset-based and cursor-based pagination.
-- **Extensible Architecture:** Create your own translators for any data source.
+- **[Enhanced Type Safety](../guides/schema-definitions/en.md):** Build queries with a fluent, strongly-typed interface, including robust schema validation and type-checked filter values.
+- **[Powerful Filtering](../guides/building-criteria/en.md#2-applying-filters):** Define intricate filtering logic with a wide array of operators (including for JSON, arrays, sets, ranges, and regex) and logical grouping.
+- **[Flexible Join System](../guides/building-criteria/en.md#3-adding-joins):** Support for various join types and pivot table configurations, with improved context for translators.
+- **[Advanced Pagination](../guides/building-criteria/en.md#5-pagination):** Support for offset-based and cursor-based pagination.
+- **[Extensible Architecture](../guides/developing-translators/en.md):** Create your own translators for any data source, aided by more comprehensive join information.
 
 ## How Is This Documentation Structured?
 
diff --git a/src/docs/introduction/es.md b/src/docs/introduction/es.md
index a3fdaa2..1a6f75a 100644
--- a/src/docs/introduction/es.md
+++ b/src/docs/introduction/es.md
@@ -10,38 +10,40 @@ datos complejas en tus aplicaciones TypeScript.
 (filtrado, ordenamiento, uniones, paginación, etc.) de una manera abstracta y agnóstica a la
 fuente de datos.
 
-Con `@nulledexp/translatable-criteria` , defines estos criterios como objetos estructurados y con
-seguridad de tipos. Esto contrasta con la escritura directa de SQL, el uso de la sintaxis de un
+Con `@nulledexp/translatable-criteria`, defines estos criterios como objetos estructurados y con
+seguridad de tipos. La librería ha evolucionado para ofrecer una validación de esquemas aún más
+robusta y proporcionar información contextual más rica a los traductores, simplificando aún más
+el desarrollo de integraciones sofisticadas con fuentes de datos.
+Esto contrasta con la escritura directa de SQL, el uso de la sintaxis de un
 ORM específico directamente en los casos de uso, o el desarrollo de múltiples métodos con
 lógica compleja y fuertemente acoplada en los repositorios.
 
 La idea central es que estos "criterios traducibles" puedan ser luego procesados por un
 **Traductor** específico (que tú o la comunidad pueden implementar) para generar la consulta
-nativa para tu base de datos o fuente de datos particular (por ejemplo, SQL para TypeORM,  
-consultas para MongoDB, etc.).
+nativa para tu base de datos o fuente de datos particular (por ejemplo, SQL para TypeORM, consultas para MongoDB, etc.).
 
 - **[Traductor TypeOrm(MySql)](https://www.npmjs.com/package/@nulledexp/typeorm-mysql-criteria-translator)**
-  - Author: [Nelson Cabrera](https://github.com/Techscq)
+  - Autor: [Nelson Cabrera](https://github.com/Techscq)
 
 ## ¿Qué Problema Resuelve?
 
-En muchas aplicaciones, la lógica para consultar datos se encuentra mezclada con el código de  
-negocio o fuertemente acoplada a un ORM o base de datos específica. Esto puede llevar a:
+Muchas aplicaciones se enfrentan al desafío de crear una lógica de acceso a datos flexible y reutilizable. Un síntoma común es la **proliferación de métodos de consulta especializados** como `getUserByUuid`, `getUserByEmail` o `getPostByUuidAndTitleAndCategories`. Este enfoque se convierte rápidamente en un cuello de botella para el mantenimiento.
 
-- **Dificultad para cambiar de base de datos o ORM:** Si decides migrar, gran parte de tu código
-  de consulta necesita ser reescrito.
-- **Complejidad en la lógica de negocio:** Las consultas complejas pueden volverse difíciles de
-  leer, mantener y probar.
-- **Repetición de código:** Lógicas de filtrado o paginación similares pueden estar duplicadas
-  en diferentes partes de la aplicación.
-- **Menor testeabilidad:** Probar la lógica de consulta de forma aislada se vuelve complicado.
+Este problema se agrava porque el "contexto" de una consulta puede cambiar. Por ejemplo, obtener un post para un usuario regular no es lo mismo que obtenerlo para su autor, un moderador o un servicio de analítica. Cada contexto puede requerir diferentes campos, uniones o filtros. Esto conduce a:
 
-`@nulledexp/translatable-criteria` aborda estos problemas al:
+- **Explosión de Métodos:** Una necesidad constante de escribir nuevos métodos para cada pequeña variación en el filtrado, acoplando la capa de acceso a datos a casos de uso específicos.
+- **Carga de Mantenimiento:** Los nuevos requisitos de negocio a menudo obligan a los desarrolladores a crear más y más métodos, aumentando la complejidad y el riesgo de errores.
+- **Acoplamiento Fuerte:** La lógica de la aplicación se acopla fuertemente a una fuente de datos u ORM específico, dificultando futuras migraciones o cambios.
+- **Complejidad Contextual:** La lógica para manejar diferentes contextos de acceso (ej. usuario vs. administrador) se dispersa y duplica.
 
-- **Desacoplar la definición de la consulta de su ejecución:** Define _qué_ datos necesitas, no _cómo_ obtenerlos de una fuente específica.
-- **Promover la reutilización:** Los criterios pueden ser construidos, combinados y reutilizados.
-- **Mejorar la seguridad de tipos:** Gracias a los esquemas, puedes construir criterios con validación en tiempo de compilación y ejecución.
-- **Facilitar las pruebas:** Puedes probar la lógica de construcción de criterios de forma independiente.
+`@nulledexp/translatable-criteria` proporciona una solución más abstracta e ideal. Al permitirte construir especificaciones de consulta de forma dinámica, aborda estos problemas al:
+
+- **Desacoplar la definición de la consulta de su ejecución:** Define _qué_ datos necesitas, no _cómo_ obtenerlos.
+- **Promover la reutilización:** Un único método de consulta puede manejar innumerables variaciones al aceptar un objeto `Criteria`.
+- **Mejorar la seguridad de tipos:** Construye criterios con una fuerte validación en tiempo de compilación.
+- **Facilitar las pruebas:** Prueba la lógica de construcción de consultas independientemente de la base de datos.
+
+Si bien adoptar cualquier librería introduce un grado de acoplamiento, `@nulledexp/translatable-criteria` ofrece una compensación estratégica. Acoplas tu aplicación a un flujo de construcción de consultas predecible y mantenible a cambio de **desacoplar tu lógica de negocio de la fuente de datos subyacente y su implementación específica**. Esto resulta en una arquitectura más manejable, predecible y adaptable a largo plazo.
 
 ## ¿Para Quién es Esta Librería?
 
@@ -55,11 +57,11 @@ Esta librería es ideal para desarrolladores y equipos que:
 
 ## Principales Beneficios
 
-- **Seguridad de Tipos Mejorada:** Construye consultas con una interfaz fluida y fuertemente tipada.
-- **Filtrado Potente:** Define lógica de filtrado intrincada con múltiples operadores y agrupación.
-- **Sistema de Uniones (Joins) Flexible:** Soporte para varios tipos de join y configuraciones de tablas pivote.
-- **Paginación Avanzada:** Soporte para paginación basada en offset y en cursor.
-- **Arquitectura Extensible:** Crea tus propios traductores para cualquier fuente de datos.
+- **[Seguridad de Tipos Mejorada](../guides/schema-definitions/es.md):** Construye consultas con una interfaz fluida y fuertemente tipada, incluyendo validación de esquemas robusta y valores de filtro tipados.
+- **[Filtrado Potente](../guides/building-criteria/es.md#2-aplicando-filtros):** Define lógica de filtrado intrincada con una amplia gama de operadores (incluyendo para JSON, arrays, sets, rangos y regex) y agrupación lógica.
+- **[Sistema de Uniones (Joins) Flexible](../guides/building-criteria/es.md#3-añadiendo-uniones-joins):** Soporte para varios tipos de join y configuraciones de tablas pivote, con contexto mejorado para los traductores.
+- **[Paginación Avanzada](../guides/building-criteria/es.md#5-paginación):** Soporte para paginación basada en offset y en cursor.
+- **[Arquitectura Extensible](../guides/developing-translators/es.md):** Crea tus propios traductores para cualquier fuente de datos, ayudado por información de join más completa.
 
 ## ¿Cómo se Estructura esta Documentación?
 
@@ -70,7 +72,7 @@ Para ayudarte a sacar el máximo provecho de `@nulledexp/translatable-criteria`,
   fundamentales como
   `Criteria`,
   `CriteriaFactory`, `Schemas`, y la interfaz `CriteriaTranslator`.
-- [**Guías Prácticas:**](../guides/)
+- **Guías Prácticas:**
   - [Definición de Esquemas.](../guides/schema-definitions/es.md)
   - [Construcción de Criterios (filtros, joins, ordenamiento, paginación).](../guides/building-criteria/es.md)
   - [Desarrollo de Traductores Personalizados.](../guides/developing-translators/es.md)
diff --git a/src/docs/use-cases/en.md b/src/docs/use-cases/en.md
index 570df19..bd0d234 100644
--- a/src/docs/use-cases/en.md
+++ b/src/docs/use-cases/en.md
@@ -1,465 +1,242 @@
-# Practical Guide: Usage Examples
+# Practical Guide: Dynamic Criteria Building
 
-The previous guides have shown you how to [Define Schemas](../guides/schema-definitions/en.md) and [Build Criteria](../guides/building-criteria/en.md). Now, let's see how these pieces fit together in a more realistic application scenario.
+The previous guides have shown you how to [Define Schemas](../guides/schema-definitions/en.md) and [Build Criteria](../guides/building-criteria/en.md). Now, let's see how these pieces fit together in a more realistic, dynamic application scenario.
 
-This guide presents a complete example demonstrating the construction of a complex `Criteria` and how it could be used by a repository to query data.
+This guide presents a complete example demonstrating the construction of a complex `Criteria` object based on optional input parameters, such as those from an API request. The goal is to illustrate how the library can be used to solve problems in a subtle, orderly, and decoupled manner, regardless of whether the context is simple or highly complex.
 
 ## Index
 
 - 1. [The Example Scenario](#1-the-example-scenario)
-- 2. [Schema Definition (Reminder)](#2-schema-definition-reminder)
-- 3. [Building the Complex Criteria](#3-building-the-complex-criteria)
-- 4. [Using Criteria in a Repository](#4-using-criteria-in-a-repository)
-  - 4.1. [Repository Interface](#41-repository-interface)
-  - 4.1.1. [Optimizing Read Models with `setSelect`](#411-optimizing-read-models-with-setselect)
-  - 4.2. [Repository Implementation (Conceptual)](#42-repository-implementation-conceptual)
-  - 4.3. [Repository Usage](#43-repository-usage)
-- 5. [Translation (Brief Mention)](#5-translation-brief-mention)
-- 6. [Conclusion](#6-conclusion)
+- 2. [Schema Definitions (Reminder)](#2-schema-definitions-reminder)
+- 3. [Building the Dynamic Criteria](#3-building-the-dynamic-criteria)
+- 4. [The Helper Function: A Good Practice](#4-the-helper-function-a-good-practice)
+- 5. [Conclusion: A Philosophy of Flexibility](#5-conclusion-a-philosophy-of-flexibility)
 
 ---
 
 ## 1. The Example Scenario
 
-Imagine you need to implement a paginated user search functionality. The specific requirement is:
+Imagine you are building an API endpoint to search for blog posts. The endpoint must support filtering by various optional parameters like title, body content, tags, and author details. It also needs to handle different pagination strategies (offset and cursor-based).
 
-> Obtain a paginated list of users whose email contains "@example.com" AND whose username starts with "user\_", who have also published posts containing the word "TypeScript" in their title and were created in the last 6 months. The results should be ordered first by username (ascending) and then by post creation date (descending).
+A typical request object might look like this, where any field can be omitted:
 
-This scenario requires:
+```typescript
+type getPostByCriteriaRequest = {
+  offset?: { page: number; order: 'ASC' | 'DESC' };
+  cursor?: {
+    uuid: string;
+    created_at: string;
+    order: 'ASC' | 'DESC';
+  };
+  title?: string;
+  body?: string;
+  metadata?: {
+    tags?: string[];
+    views?: number;
+    ratings?: number[];
+    extra?: Record<string, any>;
+  };
+  publisher_uuid?: string;
+  categories?: string[];
+};
+```
 
-- Filtering on the root entity (`User`).
-- A join (`JOIN`) to the `Post` entity.
-- Filtering on the joined entity (`Post`).
-- Ordering by fields from both entities (root and joined).
-- Offset-based pagination (`LIMIT`/`OFFSET`).
+Our goal is to build a single function that takes this request object and dynamically constructs a [`Criteria`](../api-reference/en.md#criteria-abstract-base-class) object, applying filters, joins, and pagination logic only if the corresponding parameters are provided.
 
-## 2. Schema Definition (Reminder)
+## 2. Schema Definitions (Reminder)
 
-For this example, we will use the `UserSchema` and `PostSchema` schemas that we defined in the Schema Definition guide. We assume these schemas are available in your project.
+For this example, we will use the `PostSchema` and `UserSchema`. For a detailed guide on how to create them, please refer to [the Schema Definition guide.](../guides/schema-definitions/en.md)
 
 ```typescript
-// The location of your schemas will depend on your project's architecture.
-// For example, in a hexagonal architecture:
-// - src/user/application/criteria/user-criteria.schema.ts
-// - src/post/application/criteria/post-criteria.schema.ts
-// Below, they are shown as if in a common directory for simplicity of the example.
-
-import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
+export interface EntityBase {
+  uuid: string;
+  created_at: string;
+}
+export interface User extends EntityBase {
+  email: string;
+  username: string;
+  posts: Post[];
+}
 
 export const UserSchema = GetTypedCriteriaSchema({
   source_name: 'user',
-  alias: ['users', 'user', 'publisher'],
+  alias: 'users',
   fields: ['uuid', 'email', 'username', 'created_at'],
+  identifier_field: 'uuid',
   joins: [
     {
-      alias: 'posts', // Alias for the Post entity
-      join_relation_type: 'one_to_many',
+      alias: 'posts',
+      relation_type: 'one_to_many',
+      target_source_name: 'post',
     },
-    // ... other joins if they exist (e.g., with PermissionSchema, AddressSchema)
   ],
 });
 export type UserSchema = typeof UserSchema;
 
+export interface Post extends EntityBase {
+  title: string;
+  body: string;
+  publisher: User;
+  categories: string[] | null;
+  metadata?: {
+    tags?: string[];
+    views?: number;
+    ratings?: number[];
+    extra?: Record<string, any>;
+  };
+}
 export const PostSchema = GetTypedCriteriaSchema({
   source_name: 'post',
-  alias: ['posts', 'post'],
+  alias: 'posts',
+  identifier_field: 'uuid',
   fields: [
     'uuid',
+    'categories',
     'title',
     'body',
-    'user_uuid', // Foreign key to the User (publisher)
+    'user_uuid',
     'created_at',
-    'categories', // Could be an array of strings
-    'metadata', // Could be a JSON field
+    'metadata',
   ],
   joins: [
     {
-      alias: 'publisher', // Alias for the User entity (the post's author)
-      join_relation_type: 'many_to_one',
+      alias: 'publisher',
+      relation_type: 'many_to_one',
+      target_source_name: 'user',
     },
-    // ... other joins if they exist (e.g., with PostCommentSchema)
   ],
 });
 export type PostSchema = typeof PostSchema;
-
-// You might have other schemas here if needed for the example,
-// such as PostCommentSchema, PermissionSchema, etc.
-// For simplicity, we will focus on User and Post for this main example.
-```
-
-## 3. Building the Complex Criteria
-
-Now, let's build the `Criteria` object that represents the query described in the scenario. We will use `CriteriaFactory` and fluent methods.
-
-```typescript
-import {
-  CriteriaFactory,
-  FilterOperator,
-  OrderDirection,
-} from '@nulledexp/translatable-criteria';
-// Assuming UserSchema and PostSchema are defined as in #CODIGOAQUI_EJEMPLO_SCHEMAS_EN
-import { UserSchema, PostSchema } from './domain/criteria/schemas'; // Adjust path to your project
-
-// Calculate the date 6 months ago
-const sixMonthsAgo = new Date();
-sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
-
-const userSearchCriteria = CriteriaFactory.GetCriteria(UserSchema, 'users')
-  // Filters on the root entity (User)
-  .where({
-    field: 'email',
-    operator: FilterOperator.CONTAINS,
-    value: '@example.com',
-  })
-  .andWhere({
-    field: 'username',
-    operator: FilterOperator.STARTS_WITH,
-    value: 'user_',
-  })
-  // Join with Post and apply orderBy directly to the JoinCriteria
-  .join(
-    CriteriaFactory.GetInnerJoinCriteria(PostSchema, 'posts')
-      // Filters on the joined entity (Post)
-      .where({
-        field: 'title',
-        operator: FilterOperator.CONTAINS,
-        value: 'TypeScript',
-      })
-      .andWhere({
-        field: 'created_at',
-        operator: FilterOperator.GREATER_THAN_OR_EQUALS,
-        value: sixMonthsAgo,
-      })
-      // Specific ordering for posts, applied right here
-      .orderBy('created_at', OrderDirection.DESC), // <--- orderBy on the JoinCriteria
-    // Join parameters (User.uuid = Post.user_uuid)
-    { parent_field: 'uuid', join_field: 'user_uuid' },
-  )
-  // Ordering for the root entity (User)
-  .orderBy('username', OrderDirection.ASC)
-  // Pagination
-  .setTake(10)
-  .setSkip(10);
-
-// 'userSearchCriteria' is now a complete Criteria object ready to be translated.
 ```
 
-**Criteria Breakdown:**
-
-- `CriteriaFactory.GetCriteria(UserSchema, 'users')`: We start the query from the `User` entity, using the `users` alias.
-- `.where(...)`, `.andWhere(...)`: We apply initial filters on the `email` and `username` fields of the root entity (`User`).
-- `.join(...)`: We add a join to the `Post` entity.
-  - `CriteriaFactory.GetInnerJoinCriteria(PostSchema, 'posts')`: We create the `Criteria` for the join, specifying the `PostSchema` and the `posts` alias. We use `InnerJoin` because we only want users who _have_ posts that meet the conditions.
-  - `.where(...)`, `.andWhere(...)`: We apply filters on the `title` and `created_at` fields _of the joined entity (`Post`)_.
-  - `{ parent_field: 'uuid', join_field: 'user_uuid' }`: We define how `User` (parent) and `Post` (child) are related.
-- `.orderBy(...)`: We define the ordering. First by `username` (root entity field) ascending, then by `created_at` (joined entity field) descending.
-- `.setTake(...)`, `.setSkip(...)`: We apply pagination.
-
-This `userSearchCriteria` object now encapsulates all the query logic in a database-agnostic way.
-
-## 4. Using Criteria in a Repository
-
-A repository is a design pattern that mediates between the domain and data mapping layers, using a collection-like interface to access domain objects. A repository could have methods that accept a `Criteria` to decouple query logic from the specific ORM/database.
-
-### 4.1. Repository Interface
-
-You could define an implementation-agnostic repository interface:
-
-```typescript
-import { RootCriteria } from '@nulledexp/translatable-criteria';
-import { UserSchema } from './domain/criteria/schemas'; // Adjust path to your project
-import { UserReadModel } from './domain/user.read-model'; // Adjust path to your Read Model
-
-// Define the read repository interface for Users
-export interface IUserRepository {
-  /**
-   * Finds multiple users matching the provided Criteria.
-   * @param criteria The RootCriteria defining the query.
-   * @returns A promise that resolves to an array of UserReadModel.
-   */
-  matchingMany(
-    criteria: RootCriteria<UserSchema, any>,
-  ): Promise<UserReadModel[]>;
-
-  /**
-   * Finds a single user matching the provided Criteria.
-   * The Criteria is expected to be configured to return a single result or none.
-   * @param criteria The RootCriteria defining the query.
-   * @returns A promise that resolves to a UserReadModel or null if not found.
-   */
-  matchingOne(
-    criteria: RootCriteria<UserSchema, any>,
-  ): Promise<UserReadModel | null>;
-
-  // You could add other common repository methods if needed,
-  // for example, for counting results:
-  // count(criteria: RootCriteria<UserSchema, any>): Promise<number>;
-}
-```
-
-- `UserReadModel`: This would be the interface or type representing the data structure your application layer expects to receive.
-- `RootCriteria<UserSchema, any>`: Indicates that the methods expect a `Criteria` whose root entity is `UserSchema`.
-
-### 4.1.1. Optimizing Read Models with `setSelect`
-
-While the `IUserRepository` interface defines methods returning `UserReadModel`, you can further optimize data retrieval by specifying exactly which fields are needed using the `setSelect()` method on your `Criteria` object.
+## 3. Building the Dynamic Criteria
 
-When you use `setSelect()`, you instruct the `CriteriaTranslator` (and subsequently the ORM or database driver) to fetch only those specified fields. This can significantly improve performance by reducing the amount of data transferred from the database and processed by your application.
-
-For example, if you only need a user's `uuid` and `email` for a particular list view, you could construct your `Criteria` like this:
+We will create a function, `buildPostPaginatedCriteria`, that accepts the request object and conditionally builds the `Criteria`. This approach keeps the query construction logic clean and centralized.
 
 ```typescript
-import {
-  CriteriaFactory,
-  FilterOperator,
-} from '@nulledexp/translatable-criteria';
-import { UserSchema } from './domain/criteria/schemas'; // Adjust path
-
-const lightweightUserCriteria = CriteriaFactory.GetCriteria(UserSchema, 'users')
-  .setSelect(['uuid', 'email']) // Select only uuid and email
-  .where({
-    field: 'username',
-    operator: FilterOperator.STARTS_WITH,
-    value: 'user_',
-  })
-  .setTake(10);
-```
-
-In this scenario, your `UserReadModel` might still define more fields, but the data actually populated for instances returned by `matchingMany(lightweightUserCriteria)` would ideally only contain `uuid` and `email` (plus any fields essential for ORM hydration, if applicable).
-
-Alternatively, you could define more specific read models, like a `UserEmailListReadModel`:
+const maxPostPerPage = 5;
 
-```typescript
-// Conceptual: A more specific read model
-interface UserEmailListReadModel {
-  uuid: string;
-  email: string;
-}
-```
+function buildPostPaginatedCriteria(request: getPostByCriteriaRequest) {
+  const postCriteria = CriteriaFactory.GetCriteria(PostSchema);
 
-The repository implementation, when processing `lightweightUserCriteria`, would then aim to return an array of objects matching `UserEmailListReadModel` (or `UserReadModel` instances sparsely populated). This minimizes data overhead and aligns the fetched data precisely with the use case's requirements.
+  if (request.title) {
+    dynamicFilterApplierHelper(postCriteria, {
+      field: 'title',
+      operator: FilterOperator.CONTAINS,
+      value: request.title,
+    });
+  }
 
-This approach is particularly beneficial when dealing with entities with many fields or when fetching large lists of data.
+  if (request.body) {
+    dynamicFilterApplierHelper(postCriteria, {
+      field: 'body',
+      operator: FilterOperator.CONTAINS,
+      value: request.body,
+    });
+  }
 
-### 4.2. Repository Implementation (Conceptual)
+  if (request.categories) {
+    dynamicFilterApplierHelper(postCriteria, {
+      field: 'categories',
+      operator: FilterOperator.SET_CONTAINS_ANY,
+      value: request.categories,
+    });
+  }
 
-The concrete implementation of this repository (e.g., using TypeORM, Sequelize, or a NoSQL database) would be responsible for using a `CriteriaTranslator` to convert the `Criteria` into a native query. The repository would receive necessary dependencies, such as an ORM's query builder and a translator instance, in its constructor.
+  if (request.metadata) {
+    dynamicFilterApplierHelper(postCriteria, {
+      field: 'metadata',
+      operator: FilterOperator.JSON_CONTAINS,
+      value: request.metadata,
+    });
+  }
 
-```typescript
-import { RootCriteria } from '@nulledexp/translatable-criteria';
-import { UserSchema } from './domain/criteria/schemas'; // Adjust path
-import { UserReadModel } from './domain/user.read-model'; // Adjust path
-import { IUserRepository } from './user.repository.interface'; // The interface defined above
-
-// --- Implementation-Specific Dependencies (Example with TypeORM) ---
-// import { DataSource, SelectQueryBuilder } from 'typeorm';
-// import { UserEntity } from './infrastructure/typeorm/entities/user.entity'; // Your TypeORM entity
-// import { TypeOrmMysqlTranslator } from '@nulledexp/typeorm-mysql-translator'; // Your translator
-
-export class TypeOrmUserRepository implements IUserRepository {
-  // private readonly translator: TypeOrmMysqlTranslator<UserReadModel>; // Or the entity type TypeORM returns
-
-  // constructor(
-  //   private readonly dataSource: DataSource,
-  //   // You could instantiate the translator here or inject it
-  // ) {
-  //   this.translator = new TypeOrmMysqlTranslator<UserReadModel>();
-  // }
-
-  async matchingMany(
-    criteria: RootCriteria<UserSchema, any>,
-  ): Promise<UserReadModel[]> {
-    // Conceptual example with TypeORM:
-    // const alias = criteria.alias;
-    // const queryBuilder = this.dataSource
-    //   .getRepository(UserEntity) // DB entity repository
-    //   .createQueryBuilder(alias); // Alias must match the RootCriteria's alias
-
-    // // The translator modifies the queryBuilder based on the Criteria
-    // this.translator.translate(criteria, queryBuilder);
-
-    // // Execute the query
-    // const results = await queryBuilder.getMany();
-
-    // // Map DB entity results to UserReadModel if necessary
-    // return results.map(userEntity => ({
-    //   uuid: userEntity.uuid,
-    //   email: userEntity.email,
-    //   username: userEntity.username,
-    //   // ... other fields needed for UserReadModel
-    // }));
-
-    // Simplified example without a real ORM for the guide:
-    console.log(
-      'Simulating execution of matchingMany with Criteria:',
-      criteria, // Pass the criteria object directly
+  if (request.publisher_uuid) {
+    postCriteria.join(
+      'publisher',
+      CriteriaFactory.GetInnerJoinCriteria(UserSchema).where({
+        field: 'uuid',
+        operator: FilterOperator.EQUALS,
+        value: request.publisher_uuid,
+      }),
+      {
+        join_field: 'uuid',
+        parent_field: 'user_uuid',
+      },
     );
-    // Real translation and execution logic would go here
-    // which could return UserReadModel instances directly
-    // if the translator and ORM allow (by selecting only necessary fields).
-    return Promise.resolve([]); // Return an empty array as a placeholder
   }
 
-  async matchingOne(
-    criteria: RootCriteria<UserSchema, any>,
-  ): Promise<UserReadModel | null> {
-    // Conceptual example with TypeORM:
-    // const alias = criteria.alias;
-    // const queryBuilder = this.dataSource
-    //   .getRepository(UserEntity)
-    //   .createQueryBuilder(alias);
-
-    // this.translator.translate(criteria, queryBuilder);
-
-    // const result = await queryBuilder.getOne();
-
-    // if (!result) {
-    //   return null;
-    // }
-    // // Map the result to UserReadModel
-    // return {
-    //   uuid: result.uuid,
-    //   email: result.email,
-    //   username: result.username,
-    //   // ...
-    // };
-
-    // Simplified example without a real ORM for the guide:
-    console.log(
-      'Simulating execution of matchingOne with Criteria:',
-      criteria, // Pass the criteria object directly
+  if (request.cursor) {
+    postCriteria
+      .setCursor(
+        [
+          { field: 'created_at', value: request.cursor.created_at },
+          { field: 'uuid', value: request.cursor.uuid },
+        ],
+        FilterOperator.GREATER_THAN,
+        'ASC',
+      )
+      .orderBy('created_at', request.cursor.order)
+      .orderBy('uuid', request.cursor.order);
+  } else if (request.offset) {
+    postCriteria.setSkip(
+      Math.max(0, (request.offset.page - 1) * maxPostPerPage),
     );
-    return Promise.resolve(null); // Return null as a placeholder
+    postCriteria.orderBy('created_at', request.offset.order);
+  } else {
+    postCriteria.orderBy('created_at', 'DESC');
   }
 
-  // async count(criteria: RootCriteria<UserSchema, any>): Promise<number> {
-  //   // Conceptual example with TypeORM:
-  //   // const alias = criteria.alias;
-  //   // const queryBuilder = this.dataSource
-  //   //   .getRepository(UserEntity)
-  //   //   .createQueryBuilder(alias);
-  //   //
-  //   // // For count, you usually don't need complex joins or specific selects,
-  //   // // unless the criteria filters require them.
-  //   // // You might have a simplified version of translate for count,
-  //   // // or the translator could be smart enough.
-  //   // this.translator.translate(criteria, queryBuilder); // Apply necessary filters and joins
-  //   //
-  //   // return await queryBuilder.getCount();
-  //
-  //   console.log("Simulating execution of count with Criteria:", criteria);
-  //   return Promise.resolve(0);
-  // }
+  postCriteria.setTake(maxPostPerPage);
+
+  return postCriteria;
 }
 ```
 
-**Note:** This is a conceptual example. The actual implementation will depend on your specific ORM and translator. The key point is that the `Criteria` is passed to the translator, and the translator modifies a native query builder (`queryBuilder`) or generates the query in some other way.
+**Criteria Breakdown:**
+
+- **Initialization:** We start with a base `RootCriteria` for `PostSchema`.
+- **Conditional Filters:** Each `if (request.field)` block checks for a parameter's existence. If present, it uses a helper function (`dynamicFilterApplierHelper`) to apply the corresponding filter.
+- **Conditional Join:** The `JOIN` to the `publisher` (User) is only added if a `publisher_uuid` is provided for filtering. This ensures that the join is not performed unnecessarily.
+- **Conditional Pagination:** The logic handles three scenarios: applying cursor-based pagination if a cursor is present, falling back to offset-based pagination if an offset is provided, or applying a default ordering if neither is specified.
+- **Global Limit:** A `setTake()` is applied at the end, which serves as a default page size for both pagination methods.
 
-### 4.3. Repository Usage
+## 4. The Helper Function: A Good Practice
 
-From your service or application layer, you would instantiate the repository with its dependencies and then call its methods, passing them the constructed `Criteria`.
+The example uses a helper function, `dynamicFilterApplierHelper`, to manage the application of filters.
 
 ```typescript
-import {
-  CriteriaFactory,
-  FilterOperator,
-  OrderDirection,
-  type RootCriteria,
-} from '@nulledexp/translatable-criteria';
-import { UserSchema, PostSchema } from './domain/criteria/schemas'; // Adjust path to your project
-import type { IUserRepository } from './user.repository.interface'; // Adjust path
-import type { UserReadModel } from './domain/user.read-model'; // Adjust path
-
-async function demonstrateRepositoryUsage() {
-  // 1. Criteria Construction (similar to #CODIGOAQUI_EJEMPLO_1_EN)
-  // In a real application, this Criteria might be built by a service
-  // or a dedicated class for constructing specific queries.
-  const sixMonthsAgo = new Date();
-  sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
-
-  const postJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(
-    PostSchema,
-    'posts',
-  )
-    .where({
-      field: 'title',
-      operator: FilterOperator.CONTAINS,
-      value: 'TypeScript',
-    })
-    .andWhere({
-      field: 'created_at',
-      operator: FilterOperator.GREATER_THAN_OR_EQUALS,
-      value: sixMonthsAgo,
-    })
-    .orderBy('created_at', OrderDirection.DESC);
-
-  const userSearchCriteria: RootCriteria<typeof UserSchema, 'users'> =
-    CriteriaFactory.GetCriteria(UserSchema, 'users')
-      .where({
-        field: 'email',
-        operator: FilterOperator.CONTAINS,
-        value: '@example.com',
-      })
-      .andWhere({
-        field: 'username',
-        operator: FilterOperator.STARTS_WITH,
-        value: 'user_',
-      })
-      .join(postJoinCriteria, { parent_field: 'uuid', join_field: 'user_uuid' })
-      .orderBy('username', OrderDirection.ASC)
-      .setTake(10)
-      .setSkip(10);
-
-  // 2. Repository Instantiation and Usage (Conceptual)
-  // In a real application, `userRepository` would be an injected instance
-  // of a class implementing `IUserRepository` (e.g., TypeOrmUserRepository).
-  // Such a class would receive a `DataSource` and a `CriteriaTranslator` in its constructor.
-
-  // const userRepository: IUserRepository = new ConcreteUserRepository(dataSource, translator);
-  // const users: UserReadModel[] = await userRepository.matchingMany(userSearchCriteria);
-  // console.log(`Users found (simulated):`, users.length);
-
-  // For the purpose of this guide, we illustrate the concept:
-  console.log(
-    'The `userSearchCriteria` object (just constructed) would be passed to the `matchingMany` method of an `IUserRepository` instance.',
-  );
-  console.log(
-    'The concrete repository implementation (e.g., TypeOrmUserRepository) would use a `CriteriaTranslator` to convert the `Criteria` into a native query and execute it against the database.',
-  );
-  console.log(
-    'Finally, the repository method would return the results (e.g., UserReadModel[]).',
-  );
+function dynamicFilterApplierHelper<
+  TSchema extends CriteriaSchema,
+  Operator extends FilterOperator,
+>(
+  criteria: ICriteriaBase<TSchema>,
+  filterPrimitive: FilterPrimitive<FieldOfSchema<TSchema>, Operator>,
+) {
+  if (criteria.rootFilterGroup.items.length === 0) {
+    criteria.where(filterPrimitive);
+  } else {
+    criteria.andWhere(filterPrimitive);
+  }
 }
-
-demonstrateRepositoryUsage();
 ```
 
-In this flow:
-
-1.  The `Criteria` defining the desired query is constructed.
-2.  The repository (e.g., `TypeOrmUserRepository`) is instantiated with its dependencies (e.g., a TypeORM `DataSource` and a `TypeOrmMysqlTranslator` instance).
-3.  The appropriate repository method (`matchingMany` or `matchingOne`) is called, passing it the `Criteria`.
-4.  The repository internally uses the `CriteriaTranslator` to execute the query against the database.
-5.  The repository returns the data in the expected format (e.g., `UserReadModel[]`).
+This helper is provided purely as an **example** of how a developer can handle the complexity of building a criteria object. The key takeaway is not the specific implementation of the helper, but the **principle** behind it:
 
-This keeps the query construction logic separate from the data access logic.
+- **Encapsulation:** It encapsulates the logic of solving the common problem of whether to call `.where()` (for the first filter) or `.andWhere()` (for subsequent filters) when building a query dynamically.
+- **Type Safety:** The helper is generic (`<TSchema extends CriteriaSchema, ...>`). This is a **highly recommended practice**. By extending the generic types from the library, you ensure that your own abstractions maintain full type safety and autocompletion, preventing bugs and improving code maintainability throughout your project.
 
-## 5. Translation (Brief Mention)
+Developers are entirely free to create their own solutions or helpers for dynamically building their criteria. The important thing is to leverage the library's type system to build robust and maintainable code.
 
-As detailed in the Developing Custom Translators guide, the step of converting the `Criteria` object into a native query is handled by a concrete implementation of `CriteriaTranslator`.
+## 5. Conclusion: A Philosophy of Flexibility
 
-For example, a `TypeOrmMysqlTranslator` would take the `userSearchCriteria` and a TypeORM `SelectQueryBuilder` (which the repository would have available), and would modify the `queryBuilder` by adding the corresponding `WHERE`, `JOIN`, `ORDER BY`, `LIMIT`, `OFFSET` clauses.
+This example is not intended to impose or propose any specific architectural pattern. The purpose is to demonstrate how `@nulledexp/translatable-criteria` provides the tools to solve a potentially complex problem in a decoupled and organized way.
 
-The beauty of this pattern is that the `Criteria` definition doesn't need to know _how_ the query will be translated, only that it can be translated.
-
-## 6. Conclusion
-
-This example demonstrates how `@nulledexp/translatable-criteria` allows you to build complex query specifications in a structured, typed, and data-source-agnostic manner. By integrating this library with the Repository pattern, you can achieve a cleaner, more maintainable, and testable data access architecture.
+The same principles shown here apply equally to simpler or even more complex scenarios. The library gives you the building blocks; how you integrate them into your services, repositories, or use cases is entirely up to your architectural decisions.
 
 ---
 
 ## Next Steps
 
-With an understanding of the concepts, criteria construction, and translator development, you now have the tools to start using `@nulledexp/translatable-criteria` in your own projects.
-
-For a detailed reference of all classes and types, consult the [API Reference.](../api-reference/en.md)
+- For a detailed reference of all classes and types, consult the [API Reference.](../api-reference/en.md)
+- To learn how to convert a `Criteria` object into a native query, see the [Developing Custom Translators guide.](../guides/developing-translators/en.md)
diff --git a/src/docs/use-cases/es.md b/src/docs/use-cases/es.md
index b831673..22bd49c 100644
--- a/src/docs/use-cases/es.md
+++ b/src/docs/use-cases/es.md
@@ -1,454 +1,242 @@
-# Guía Práctica: Ejemplos de Uso
+# Guía Práctica: Construcción Dinámica de Criterios
 
-Las guías anteriores te han mostrado cómo [Definir Esquemas](../guides/defining-schemas.md) y [Construir Criterios](../guides/building-criteria.md). Ahora, veamos cómo estas piezas encajan en un escenario de aplicación más realista.
+Las guías anteriores te han mostrado cómo [Definir Esquemas](../guides/schema-definitions/es.md) y [Construir Criterios](../guides/building-criteria/es.md). Ahora, veamos cómo estas piezas encajan en un escenario de aplicación más realista y dinámico.
 
-Esta guía presenta un ejemplo completo que demuestra la construcción de un `Criteria` complejo y cómo podría ser utilizado por un repositorio para consultar datos.
+Esta guía presenta un ejemplo completo que demuestra la construcción de un objeto `Criteria` complejo basado en parámetros de entrada opcionales, como los de una petición de API. El objetivo es ilustrar cómo la librería puede ser utilizada para resolver problemas de una manera sutil, ordenada y desacoplada, sin importar si el contexto es simple o muy complejo.
 
 ## Índice
 
 - 1. [El Escenario del Ejemplo](#1-el-escenario-del-ejemplo)
 - 2. [Definición de Esquemas (Recordatorio)](#2-definición-de-esquemas-recordatorio)
-- 3. [Construyendo el Criteria Complejo](#3-construyendo-el-criteria-complejo)
-- 4. [Usando el Criteria en un Repositorio](#4-usando-el-criteria-en-un-repositorio)
-  - 4.1. [Interfaz del Repositorio](#41-interfaz-del-repositorio)
-  - 4.1.1. [Optimizando Modelos de Lectura con `setSelect`](#411-optimizando-modelos-de-lectura-con-setselect)
-  - 4.2. [Implementación del Repositorio (Conceptual)](#42-implementación-del-repositorio-conceptual)
-  - 4.3. [Uso del Repositorio](#43-uso-del-repositorio)
-- 5. [La Traducción (Breve Mención)](#5-la-traducción-breve-mención)
-- 6. [Conclusión](#6-conclusión)
+- 3. [Construyendo el Criteria Dinámico](#3-construyendo-el-criteria-dinámico)
+- 4. [La Función de Ayuda (Helper): Una Buena Práctica](#4-la-función-de-ayuda-helper-una-buena-práctica)
+- 5. [Conclusión: Una Filosofía de Flexibilidad](#5-conclusión-una-filosofía-de-flexibilidad)
 
 ---
 
 ## 1. El Escenario del Ejemplo
 
-Imagina que necesitas implementar una funcionalidad de búsqueda paginada de usuarios. El requisito específico es:
+Imagina que estás construyendo un endpoint de API para buscar publicaciones de blog. El endpoint debe soportar el filtrado por varios parámetros opcionales como título, contenido del cuerpo, etiquetas y detalles del autor. También necesita manejar diferentes estrategias de paginación (offset y basada en cursor).
 
-> Obtener una lista paginada de usuarios cuyo email contenga "@example.com" Y cuyo nombre de usuario comience con "user\_", que además hayan publicado posts que contengan la palabra "TypeScript" en su título y que hayan sido creados en los últimos 6 meses. Los resultados deben estar ordenados primero por el nombre de usuario (ascendente) y luego por la fecha de creación del post (descendente).
+Un objeto de petición típico podría verse así, donde cualquier campo puede ser omitido:
 
-Este escenario requiere:
+```typescript
+type getPostByCriteriaRequest = {
+  offset?: { page: number; order: 'ASC' | 'DESC' };
+  cursor?: {
+    uuid: string;
+    created_at: string;
+    order: 'ASC' | 'DESC';
+  };
+  title?: string;
+  body?: string;
+  metadata?: {
+    tags?: string[];
+    views?: number;
+    ratings?: number[];
+    extra?: Record<string, any>;
+  };
+  publisher_uuid?: string;
+  categories?: string[];
+};
+```
 
-- Filtrado en la entidad raíz (`User`).
-- Una unión (`JOIN`) a la entidad `Post`.
-- Filtrado en la entidad unida (`Post`).
-- Ordenamiento por campos de ambas entidades (raíz y unida).
-- Paginación basada en offset (`LIMIT`/`OFFSET`).
+Nuestro objetivo es construir una única función que tome este objeto de petición y construya dinámicamente un objeto [`Criteria`](../api-reference/es.md#criteria-clase-abstracta-base), aplicando filtros, uniones y lógica de paginación solo si se proporcionan los parámetros correspondientes.
 
 ## 2. Definición de Esquemas (Recordatorio)
 
-Para este ejemplo, utilizaremos los esquemas `UserSchema` y `PostSchema` que definimos en la guía de Definición de Esquemas. Asumimos que estos esquemas están disponibles en tu proyecto.
+Para este ejemplo, utilizaremos los esquemas `PostSchema` y `UserSchema`. Para una guía detallada sobre cómo crearlos, por favor consulta [la guía de Definición de Esquemas.](../guides/schema-definitions/es.md)
 
 ```typescript
-// La ubicación de tus esquemas dependerá de la arquitectura de tu proyecto.
-// Por ejemplo, en una arquitectura hexagonal:
-// - src/user/application/criteria/user-criteria.schema.ts
-// - src/post/application/criteria/post-criteria.schema.ts
-// A continuación, se muestran como si estuvieran en un directorio común por simplicidad del ejemplo.
-
-import { GetTypedCriteriaSchema } from '@nulledexp/translatable-criteria';
+export interface EntityBase {
+  uuid: string;
+  created_at: string;
+}
+export interface User extends EntityBase {
+  email: string;
+  username: string;
+  posts: Post[];
+}
 
 export const UserSchema = GetTypedCriteriaSchema({
   source_name: 'user',
-  alias: ['users', 'user', 'publisher'],
+  alias: 'users',
   fields: ['uuid', 'email', 'username', 'created_at'],
+  identifier_field: 'uuid',
   joins: [
     {
-      alias: 'posts', // Alias para la entidad Post
-      join_relation_type: 'one_to_many',
+      alias: 'posts',
+      relation_type: 'one_to_many',
+      target_source_name: 'post',
     },
-    // ... otras uniones si existen (ej. con PermissionSchema, AddressSchema)
   ],
 });
 export type UserSchema = typeof UserSchema;
 
+export interface Post extends EntityBase {
+  title: string;
+  body: string;
+  publisher: User;
+  categories: string[] | null;
+  metadata?: {
+    tags?: string[];
+    views?: number;
+    ratings?: number[];
+    extra?: Record<string, any>;
+  };
+}
 export const PostSchema = GetTypedCriteriaSchema({
   source_name: 'post',
-  alias: ['posts', 'post'],
+  alias: 'posts',
+  identifier_field: 'uuid',
   fields: [
     'uuid',
+    'categories',
     'title',
     'body',
-    'user_uuid', // Clave foránea al User (publisher)
+    'user_uuid',
     'created_at',
-    'categories', // Podría ser un array de strings
-    'metadata', // Podría ser un campo JSON
+    'metadata',
   ],
   joins: [
     {
-      alias: 'publisher', // Alias para la entidad User (el autor del post)
-      join_relation_type: 'many_to_one',
+      alias: 'publisher',
+      relation_type: 'many_to_one',
+      target_source_name: 'user',
     },
-    // ... otras uniones si existen (ej. con PostCommentSchema)
   ],
 });
 export type PostSchema = typeof PostSchema;
-
-// Podrías tener otros esquemas aquí si fueran necesarios para el ejemplo,
-// como PostCommentSchema, PermissionSchema, etc.
-// Por simplicidad, nos centraremos en User y Post para este ejemplo principal.
 ```
 
-## 3. Construyendo el Criteria Complejo
+## 3. Construyendo el Criteria Dinámico
 
-Ahora, construyamos el objeto `Criteria` que representa la consulta descrita en el escenario. Utilizaremos `CriteriaFactory` y los métodos fluidos.
+Crearemos una función, `buildPostPaginatedCriteria`, que acepte el objeto de la petición y construya condicionalmente el objeto `Criteria`. Este enfoque mantiene la lógica de construcción de la consulta limpia y centralizada.
 
 ```typescript
-import {
-  CriteriaFactory,
-  FilterOperator,
-  OrderDirection,
-} from '@nulledexp/translatable-criteria';
-import { UserSchema, PostSchema } from './domain/criteria/schemas'; // Ajusta la ruta según tu proyecto
-
-// Calcular la fecha de hace 6 meses
-const sixMonthsAgo = new Date();
-sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
-
-const userSearchCriteria = CriteriaFactory.GetCriteria(UserSchema, 'users')
-  // Filtros en la entidad raíz (User)
-  .where({
-    field: 'email',
-    operator: FilterOperator.CONTAINS,
-    value: '@example.com',
-  })
-  .andWhere({
-    field: 'username',
-    operator: FilterOperator.STARTS_WITH,
-    value: 'user_',
-  })
-  // Unir con Post y aplicar orderBy directamente al JoinCriteria
-  .join(
-    CriteriaFactory.GetInnerJoinCriteria(PostSchema, 'posts')
-      // Filtros en la entidad unida (Post)
-      .where({
-        field: 'title',
-        operator: FilterOperator.CONTAINS,
-        value: 'TypeScript',
-      })
-      .andWhere({
-        field: 'created_at',
-        operator: FilterOperator.GREATER_THAN_OR_EQUALS,
-        value: sixMonthsAgo,
-      })
-      // Ordenamiento específico para los posts, aplicado aquí mismo
-      .orderBy('created_at', OrderDirection.DESC), // <--- orderBy en el JoinCriteria
-    // Parámetros de la unión (User.uuid = Post.user_uuid)
-    { parent_field: 'uuid', join_field: 'user_uuid' },
-  )
-  // Ordenamiento para la entidad raíz (User)
-  .orderBy('username', OrderDirection.ASC)
-  // Paginación
-  .setTake(10)
-  .setSkip(10);
-```
-
-**Desglose del Criteria:**
-
-- `CriteriaFactory.GetCriteria(UserSchema, 'users')`: Iniciamos la consulta desde la entidad `User`, usando el alias `users`.
-- `.where(...)`, `.andWhere(...)`: Aplicamos los filtros iniciales sobre los campos `email` y `username` de la entidad raíz (`User`).
-- `.join(...)`: Añadimos una unión a la entidad `Post`.
-  - `CriteriaFactory.GetInnerJoinCriteria(PostSchema, 'posts')`: Creamos el `Criteria` para la unión, especificando el esquema `PostSchema` y el alias `posts`. Usamos `InnerJoin` porque solo queremos usuarios que _tengan_ posts que cumplan las condiciones.
-  - `.where(...)`, `.andWhere(...)`: Aplicamos los filtros sobre los campos `title` y `created_at` _de la entidad unida (`Post`)_.
-  - `{ parent_field: 'uuid', join_field: 'user_uuid' }`: Definimos cómo se relacionan `User` (padre) y `Post` (hijo).
-- `.orderBy(...)`: Definimos el ordenamiento. Primero por `username` (campo de la raíz) ascendente, luego por `created_at` (campo de la unión) descendente.
-- `.setTake(...)`, `.setSkip(...)`: Aplicamos la paginación.
-
-Este objeto `userSearchCriteria` encapsula ahora toda la lógica de la consulta de forma agnóstica a la base de datos.
+const maxPostPerPage = 5;
 
-## 4. Usando el Criteria en un Repositorio
+function buildPostPaginatedCriteria(request: getPostByCriteriaRequest) {
+  const postCriteria = CriteriaFactory.GetCriteria(PostSchema);
 
-Un repositorio es un patrón de diseño que media entre el dominio y las capas de mapeo de datos, utilizando una interfaz similar a una colección para acceder a los objetos del dominio. Un repositorio podría tener métodos que acepten un `Criteria` para desacoplar la lógica de consulta del ORM/base de datos específico.
-
-### 4.1. Interfaz del Repositorio
-
-Podrías definir una interfaz de repositorio agnóstica a la implementación:
-
-```typescript
-import { RootCriteria } from '@nulledexp/translatable-criteria';
-import { UserSchema } from './domain/criteria/schemas';
-import { UserReadModel } from './domain/user.read-model';
-
-// Define la interfaz del repositorio de lectura para Usuarios
-export interface IUserRepository {
-  /**
-   * Busca múltiples usuarios que coincidan con el Criteria proporcionado.
-   * @param criteria El RootCriteria que define la consulta.
-   * @returns Una promesa que resuelve a un array de UserReadModel.
-   */
-  matchingMany(
-    criteria: RootCriteria<UserSchema, any>,
-  ): Promise<UserReadModel[]>;
-
-  /**
-   * Busca un único usuario que coincida con el Criteria proporcionado.
-   * Se espera que el Criteria esté configurado para devolver un único resultado o ninguno.
-   * @param criteria El RootCriteria que define la consulta.
-   * @returns Una promesa que resuelve a un UserReadModel o null si no se encuentra.
-   */
-  matchingOne(
-    criteria: RootCriteria<UserSchema, any>,
-  ): Promise<UserReadModel | null>;
-
-  // Podrías añadir otros métodos comunes de repositorio si fueran necesarios,
-  // por ejemplo, para contar resultados:
-  // count(criteria: RootCriteria<UserSchema, any>): Promise<number>;
-}
-```
-
-- `UserReadModel`: Sería la interfaz o tipo que representa la estructura de datos que tu capa de aplicación espera recibir.
-- `RootCriteria<UserSchema, any>`: Indica que los métodos esperan un `Criteria` cuya entidad raíz sea `UserSchema`.
-
-### 4.1.1. Optimizando Modelos de Lectura con `setSelect`
+  if (request.title) {
+    dynamicFilterApplierHelper(postCriteria, {
+      field: 'title',
+      operator: FilterOperator.CONTAINS,
+      value: request.title,
+    });
+  }
 
-Aunque la interfaz `IUserRepository` define métodos que devuelven `UserReadModel`, puedes optimizar aún más la recuperación de datos especificando exactamente qué campos se necesitan utilizando el método `setSelect()` en tu objeto `Criteria`.
+  if (request.body) {
+    dynamicFilterApplierHelper(postCriteria, {
+      field: 'body',
+      operator: FilterOperator.CONTAINS,
+      value: request.body,
+    });
+  }
 
-Cuando usas `setSelect()`, instruyes al `CriteriaTranslator` (y subsecuentemente al ORM o controlador de base de datos) para que obtenga solo esos campos especificados. Esto puede mejorar significativamente el rendimiento al reducir la cantidad de datos transferidos desde la base de datos y procesados por tu aplicación.
+  if (request.categories) {
+    dynamicFilterApplierHelper(postCriteria, {
+      field: 'categories',
+      operator: FilterOperator.SET_CONTAINS_ANY,
+      value: request.categories,
+    });
+  }
 
-Por ejemplo, si solo necesitas el `uuid` y el `email` de un usuario para una vista de lista particular, podrías construir tu `Criteria` así:
+  if (request.metadata) {
+    dynamicFilterApplierHelper(postCriteria, {
+      field: 'metadata',
+      operator: FilterOperator.JSON_CONTAINS,
+      value: request.metadata,
+    });
+  }
 
-```typescript
-import {
-  CriteriaFactory,
-  FilterOperator,
-} from '@nulledexp/translatable-criteria';
-import { UserSchema } from './domain/criteria/schemas'; // Ajusta la ruta
-
-const lightweightUserCriteria = CriteriaFactory.GetCriteria(UserSchema, 'users')
-  .setSelect(['uuid', 'email']) // Selecciona solo uuid y email
-  .where({
-    field: 'username',
-    operator: FilterOperator.STARTS_WITH,
-    value: 'user_',
-  })
-  .setTake(10);
-```
+  if (request.publisher_uuid) {
+    postCriteria.join(
+      'publisher',
+      CriteriaFactory.GetInnerJoinCriteria(UserSchema).where({
+        field: 'uuid',
+        operator: FilterOperator.EQUALS,
+        value: request.publisher_uuid,
+      }),
+      {
+        join_field: 'uuid',
+        parent_field: 'user_uuid',
+      },
+    );
+  }
 
-En este escenario, tu `UserReadModel` aún podría definir más campos, pero los datos realmente poblados para las instancias devueltas por `matchingMany(lightweightUserCriteria)` idealmente solo contendrían `uuid` y `email` (más cualquier campo esencial para la hidratación del ORM, si aplica).
+  if (request.cursor) {
+    postCriteria
+      .setCursor(
+        [
+          { field: 'created_at', value: request.cursor.created_at },
+          { field: 'uuid', value: request.cursor.uuid },
+        ],
+        FilterOperator.GREATER_THAN,
+        'ASC',
+      )
+      .orderBy('created_at', request.cursor.order)
+      .orderBy('uuid', request.cursor.order);
+  } else if (request.offset) {
+    postCriteria.setSkip(
+      Math.max(0, (request.offset.page - 1) * maxPostPerPage),
+    );
+    postCriteria.orderBy('created_at', request.offset.order);
+  } else {
+    postCriteria.orderBy('created_at', 'DESC');
+  }
 
-Alternativamente, podrías definir modelos de lectura más específicos, como un `UserEmailListReadModel`:
+  postCriteria.setTake(maxPostPerPage);
 
-```typescript
-// Conceptual: Un modelo de lectura más específico
-interface UserEmailListReadModel {
-  uuid: string;
-  email: string;
+  return postCriteria;
 }
 ```
 
-La implementación del repositorio, al procesar `lightweightUserCriteria`, buscaría entonces devolver un array de objetos que coincidan con `UserEmailListReadModel` (o instancias de `UserReadModel` escasamente pobladas). Esto minimiza la sobrecarga de datos y alinea los datos obtenidos precisamente con los requisitos del caso de uso.
+**Desglose del Criteria:**
 
-Este enfoque es particularmente beneficioso cuando se trata con entidades con muchos campos o al obtener grandes listas de datos.
+- **Inicialización:** Empezamos con un `RootCriteria` base para `PostSchema`.
+- **Filtros Condicionales:** Cada bloque `if (request.campo)` comprueba la existencia de un parámetro. Si está presente, utiliza una función de ayuda (`dynamicFilterApplierHelper`) para aplicar el filtro correspondiente.
+- **Unión Condicional:** El `JOIN` al `publisher` (User) solo se añade si se proporciona un `publisher_uuid` para filtrar. Esto asegura que la unión no se realice innecesariamente.
+- **Paginación Condicional:** La lógica maneja tres escenarios: aplica paginación basada en cursor si hay un cursor presente, recurre a la paginación por offset si se proporciona un offset, o aplica un ordenamiento por defecto si no se especifica ninguno.
+- **Límite Global:** Se aplica un `setTake()` al final, que sirve como un tamaño de página por defecto para ambos métodos de paginación.
 
-### 4.2. Implementación del Repositorio (Conceptual)
+## 4. La Función de Ayuda (Helper): Una Buena Práctica
 
-La implementación concreta de este repositorio (por ejemplo, usando TypeORM, Sequelize, o una base de datos NoSQL) sería la responsable de utilizar un `CriteriaTranslator` para convertir el `Criteria` en una consulta nativa. El repositorio recibiría las dependencias necesarias, como el constructor de consultas de un ORM y una instancia del traductor, en su constructor.
+El ejemplo utiliza una función de ayuda, `dynamicFilterApplierHelper`, para gestionar la aplicación de filtros.
 
 ```typescript
-import { RootCriteria } from '@nulledexp/translatable-criteria';
-import { UserSchema } from './domain/criteria/schemas'; // Ajusta la ruta
-import { UserReadModel } from './domain/user.read-model'; // Ajusta la ruta
-import { IUserRepository } from './user.repository.interface'; // La interfaz definida arriba
-
-// --- Dependencias Específicas de la Implementación (Ejemplo con TypeORM) ---
-// import { DataSource, SelectQueryBuilder } from 'typeorm';
-// import { UserEntity } from './infrastructure/typeorm/entities/user.entity'; // Tu entidad TypeORM
-// import { TypeOrmMysqlTranslator } from '@nulledexp/typeorm-mysql-translator'; // Tu traductor
-
-export class TypeOrmUserRepository implements IUserRepository {
-  // private readonly translator: TypeOrmMysqlTranslator<UserReadModel>; // O el tipo de entidad que devuelve TypeORM
-
-  // constructor(
-  //   private readonly dataSource: DataSource,
-  //   // Podrías instanciar el traductor aquí o inyectarlo
-  // ) {
-  //   this.translator = new TypeOrmMysqlTranslator<UserReadModel>();
-  // }
-
-  async matchingMany(
-    criteria: RootCriteria<UserSchema, any>,
-  ): Promise<UserReadModel[]> {
-    // Ejemplo conceptual con TypeORM:
-    // const alias = criteria.alias;
-    // const queryBuilder = this.dataSource
-    //   .getRepository(UserEntity) // Repositorio de la entidad de BD
-    //   .createQueryBuilder(alias); // Alias debe coincidir con el del RootCriteria
-
-    // // El traductor modifica el queryBuilder basándose en el Criteria
-    // this.translator.translate(criteria, queryBuilder);
-
-    // // Ejecuta la consulta
-    // const results = await queryBuilder.getMany();
-
-    // // Mapea los resultados de la entidad de BD a UserReadModel si es necesario
-    // return results.map(userEntity => ({
-    //   uuid: userEntity.uuid,
-    //   email: userEntity.email,
-    //   username: userEntity.username,
-    //   // ... otros campos necesarios para UserReadModel
-    // }));
-
-    // Ejemplo simplificado sin ORM real para la guía:
-    console.log('Simulando ejecución de matchingMany con Criteria:', criteria);
-    // Aquí iría la lógica real de traducción y ejecución
-    // que podría devolver instancias de UserReadModel directamente
-    // si el traductor y el ORM lo permiten (seleccionando solo los campos necesarios).
-    return Promise.resolve([]); // Devuelve un array vacío como placeholder
+function dynamicFilterApplierHelper<
+  TSchema extends CriteriaSchema,
+  Operator extends FilterOperator,
+>(
+  criteria: ICriteriaBase<TSchema>,
+  filterPrimitive: FilterPrimitive<FieldOfSchema<TSchema>, Operator>,
+) {
+  if (criteria.rootFilterGroup.items.length === 0) {
+    criteria.where(filterPrimitive);
+  } else {
+    criteria.andWhere(filterPrimitive);
   }
-
-  async matchingOne(
-    criteria: RootCriteria<UserSchema, any>,
-  ): Promise<UserReadModel | null> {
-    // Ejemplo conceptual con TypeORM:
-    // const alias = criteria.alias;
-    // const queryBuilder = this.dataSource
-    //   .getRepository(UserEntity)
-    //   .createQueryBuilder(alias);
-
-    // this.translator.translate(criteria, queryBuilder);
-
-    // const result = await queryBuilder.getOne();
-
-    // if (!result) {
-    //   return null;
-    // }
-    // // Mapea el resultado a UserReadModel
-    // return {
-    //   uuid: result.uuid,
-    //   email: result.email,
-    //   username: result.username,
-    //   // ...
-    // };
-
-    // Ejemplo simplificado sin ORM real para la guía:
-    console.log('Simulando ejecución de matchingOne con Criteria:', criteria);
-    return Promise.resolve(null); // Devuelve null como placeholder
-  }
-
-  // async count(criteria: RootCriteria<UserSchema, any>): Promise<number> {
-  //   // Ejemplo conceptual con TypeORM:
-  //   // const alias = criteria.alias;
-  //   // const queryBuilder = this.dataSource
-  //   //   .getRepository(UserEntity)
-  //   //   .createQueryBuilder(alias);
-  //   //
-  //   // // Para count, usualmente no necesitas joins complejos o selects específicos,
-  //   // // a menos que los filtros del criteria los requieran.
-  //   // // Podrías tener una versión simplificada del translate para count,
-  //   // // o el traductor podría ser lo suficientemente inteligente.
-  //   // this.translator.translate(criteria, queryBuilder); // Aplicar filtros y joins necesarios
-  //   //
-  //   // return await queryBuilder.getCount();
-  //
-  //   console.log("Simulando ejecución de count con Criteria:", criteria);
-  //   return Promise.resolve(0);
-  // }
 }
 ```
 
-**Nota:** Este es un ejemplo conceptual. La implementación real dependerá de tu ORM y traductor específico. El punto clave es que el `Criteria` se pasa al traductor, y el traductor modifica un constructor de consultas nativo (`queryBuilder`) o genera la consulta de alguna otra forma.
+Este helper se proporciona puramente como un **ejemplo** de cómo un desarrollador puede manejar la complejidad de construir un objeto de criterio. La clave no es la implementación específica del helper, sino el **principio** que hay detrás:
 
-### 4.3. Uso del Repositorio
+- **Encapsulación:** Encapsula la lógica para resolver el problema común de decidir si se debe llamar a `.where()` (para el primer filtro) o a `.andWhere()` (para los filtros posteriores) al construir una consulta de forma dinámica.
+- **Seguridad de Tipos:** El helper es genérico (`<TSchema extends CriteriaSchema, ...>`). Esta es una **práctica muy recomendada**. Al extender los tipos genéricos de la librería, te aseguras de que tus propias abstracciones mantengan una seguridad de tipos y un autocompletado completos, previniendo errores y mejorando la mantenibilidad del código en todo tu proyecto.
 
-Desde tu capa de servicio o aplicación, instanciarías el repositorio con sus dependencias y luego llamarías a sus métodos pasándoles el `Criteria` construido.
+Los desarrolladores son totalmente libres de crear sus propias soluciones o helpers para construir dinámicamente sus criterios. Lo importante es aprovechar el sistema de tipos de la librería para construir un código robusto y mantenible.
 
-```typescript
-import {
-  CriteriaFactory,
-  FilterOperator,
-  OrderDirection,
-  type RootCriteria,
-} from '@nulledexp/translatable-criteria';
-import { UserSchema, PostSchema } from './domain/criteria/schemas'; // Ajusta la ruta según tu proyecto
-import type { IUserRepository } from './user.repository.interface'; // Ajusta la ruta
-import type { UserReadModel } from './domain/user.read-model'; // Ajusta la ruta
-
-async function demostrarUsoRepositorio() {
-  // En una aplicación real, este Criteria podría ser construido por un servicio
-  // o una clase dedicada a la construcción de consultas específicas.
-  const sixMonthsAgo = new Date();
-  sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
-
-  const postJoinCriteria = CriteriaFactory.GetInnerJoinCriteria(
-    PostSchema,
-    'posts',
-  )
-    .where({
-      field: 'title',
-      operator: FilterOperator.CONTAINS,
-      value: 'TypeScript',
-    })
-    .andWhere({
-      field: 'created_at',
-      operator: FilterOperator.GREATER_THAN_OR_EQUALS,
-      value: sixMonthsAgo,
-    })
-    .orderBy('created_at', OrderDirection.DESC);
-
-  const userSearchCriteria: RootCriteria<typeof UserSchema, 'users'> =
-    CriteriaFactory.GetCriteria(UserSchema, 'users')
-      .where({
-        field: 'email',
-        operator: FilterOperator.CONTAINS,
-        value: '@example.com',
-      })
-      .andWhere({
-        field: 'username',
-        operator: FilterOperator.STARTS_WITH,
-        value: 'user_',
-      })
-      .join(postJoinCriteria, { parent_field: 'uuid', join_field: 'user_uuid' })
-      .orderBy('username', OrderDirection.ASC)
-      .setTake(10)
-      .setSkip(10);
-
-  // 2. Instanciación y Uso del Repositorio (Conceptual)
-  // En una aplicación real, `userRepository` sería una instancia inyectada
-  // de una clase que implementa `IUserRepository` (ej. TypeOrmUserRepository).=
-
-  // const userRepository: IUserRepository = new ConcreteUserRepository(dataSource, translator);
-  // const usuarios: UserReadModel[] = await userRepository.matchingMany(userSearchCriteria);
-  // console.log(`Usuarios encontrados (simulado):`, usuarios.length);
-
-  // Para fines de esta guía, ilustramos el concepto:
-  console.log(
-    'El objeto `userSearchCriteria` (recién construido) se pasaría al método `matchingMany` de una instancia de `IUserRepository`.',
-  );
-  console.log(
-    'La implementación concreta del repositorio (ej. TypeOrmUserRepository) utilizaría un `CriteriaTranslator` para convertir el `Criteria` en una consulta nativa y ejecutarla contra la base de datos.',
-  );
-  console.log(
-    'Finalmente, el método del repositorio devolvería los resultados (ej. UserReadModel[]).',
-  );
-}
-
-demostrarUsoRepositorio();
-```
-
-En este flujo:
-
-1.  Se construye el `Criteria` que define la consulta deseada.
-2.  Se instancia el repositorio (ej. `TypeOrmUserRepository`) con sus dependencias (ej. un `DataSource` de TypeORM y una instancia del `TypeOrmMysqlTranslator`).
-3.  Se llama al método apropiado del repositorio (`matchingMany` o `matchingOne`), pasándole el `Criteria`.
-4.  El repositorio utiliza internamente el `CriteriaTranslator` para ejecutar la consulta en la base de datos.
-5.  El repositorio devuelve los datos en el formato esperado (ej. `UserReadModel[]`).
+## 5. Conclusión: Una Filosofía de Flexibilidad
 
-Esto mantiene la lógica de construcción de la consulta separada de la lógica de acceso a datos.
+Este ejemplo no pretende imponer ni proponer ningún patrón de arquitectura específico. El propósito es demostrar cómo `@nulledexp/translatable-criteria` proporciona las herramientas para resolver un problema potencialmente complejo de una manera desacoplada y organizada.
 
-## 5. La Traducción (Breve Mención)
-
-Como se detalla en la guía de Desarrollo de Traductores Personalizados, el paso de convertir el objeto `Criteria` a una consulta nativa es manejado por una implementación concreta de `CriteriaTranslator`.
-
-Por ejemplo, un `TypeOrmMysqlTranslator` tomaría el `userSearchCriteria` y un `SelectQueryBuilder` de TypeORM (que el repositorio tendría disponible), y modificaría el `queryBuilder` añadiendo las cláusulas `WHERE`, `JOIN`, `ORDER BY`, `LIMIT`, `OFFSET` correspondientes.
-
-La belleza de este patrón es que la definición del `Criteria` no necesita saber _cómo_ se traducirá la consulta, solo que se puede traducir.
-
-## 6. Conclusión
-
-Este ejemplo demuestra cómo `@nulledexp/translatable-criteria` te permite construir especificaciones de consulta complejas de manera estructurada, tipada y agnóstica a la fuente de datos. Al integrar esta librería con el patrón Repositorio, puedes lograr una arquitectura de acceso a datos más limpia, mantenible y testeable.
+Los mismos principios mostrados aquí se aplican igualmente a escenarios más simples o incluso más complejos. La librería te da los bloques de construcción; cómo los integres en tus servicios, repositorios o casos de uso depende enteramente de tus decisiones de arquitectura.
 
 ---
 
 ## Próximos Pasos
 
-Con una comprensión de los conceptos, la construcción de criterios y el desarrollo de traductores, ahora tienes las herramientas para empezar a utilizar `@nulledexp/translatable-criteria` en tus propios proyectos.
-
-Para una referencia detallada de todas las clases y tipos, consulta la [Referencia de API.](../api-reference/es.md)
+- Para una referencia detallada de todas las clases y tipos, consulta la [Referencia de API.](../api-reference/es.md)
+- Para aprender a convertir un objeto `Criteria` en una consulta nativa, consulta la [guía de Desarrollo de Traductores Personalizados.](../guides/developing-translators/es.md)
diff --git a/tsconfig.json b/tsconfig.json
index e15c036..3732f2c 100644
--- a/tsconfig.json
+++ b/tsconfig.json
@@ -38,6 +38,8 @@
     "vitest.config.js",
     "vitest.config.js.map",
     "**/*.test.ts",
-    "**/test"
+    "**/test",
+    "src/docs",
+    "src/criteria/translator/example"
   ]
 }
